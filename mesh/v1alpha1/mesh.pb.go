// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mesh/v1alpha1/mesh.proto

package v1alpha1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import istio_networking_v1alpha31 "istio.io/api/networking/v1alpha3"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The type of the data source determines the protocol used to interact with
// it and obtain information.
type DataSource_SourceType int32

const (
	// Kubernetes
	DataSource_KUBERNETES DataSource_SourceType = 0
	// From a remote MCP server (Galley, CloudFoundry's MCP server, etc.)
	DataSource_ISTIO_MCP DataSource_SourceType = 1
)

var DataSource_SourceType_name = map[int32]string{
	0: "KUBERNETES",
	1: "ISTIO_MCP",
}
var DataSource_SourceType_value = map[string]int32{
	"KUBERNETES": 0,
	"ISTIO_MCP":  1,
}

func (x DataSource_SourceType) String() string {
	return proto.EnumName(DataSource_SourceType_name, int32(x))
}
func (DataSource_SourceType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMesh, []int{3, 0} }

// Mesh describes the set of service registries, configuration sources
// the networks where endpoints are resident, etc. Information gathered
// from these sources will be used to compute the mesh topology and set
// up L4/L7 connectivity between endpoints in the mesh. A single mesh can
// have one or more control planes, service registries, and networks.
//
// Multiple service registries can be configured for a single control
// plane.  For example, lets say there are three kubernetes clusters in
// two networks with no direct endpoint connectivity across the
// networks. Clusters us-east-c1 and us-east-c2 are in US-east region and
// cluster us-west-c1 is in US-west region. Assume that all clusters in
// US-east region are in the same network, i.e. endpoints in us-east-c1
// have direct L3 connectivity to endpoints in us-east-c2
// cluster. Assuming that Pilot running on any of these clusters has
// access to the mater nodes of each cluster (to talk to the API
// servers), the following configuration describes a mesh spanning all
// the clusters and using cluster-local istio-ingressgateway to route
// traffic to endpoints within the cluster.
//
// serviceRegistries:
// - name: us-east-c1
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-east-c1-kubeconfig
// - name: us-east-c2
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-east-c2-kubeconfig
// - name: us-west-c1
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-west-c1-kubeconfig
// configStores: #all configuration from local galley service
// - name: us-east-c1
//   type: ISTIO_MCP
//   uri: https://istio-galley.istio-system.svc.cluster.local:9999
//   credentials:
//     tlsSettings:
//       mode: ISTIO_MUTUAL #use istio mtls to communicate with Galley
// networks:
// - name: us-east # some arbitrary name to group endpoints
//   registries:
//   - us-east-c1
//   - us-east-c2
//   gateways:
//   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
//     port: 15443
// - name: us-west
//   registries:
//   - us-west-c1
//   gateways:
//   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
//     port: 15443
//
type Mesh struct {
	// service_registries describe the registries from which Istio should
	// construct the composite service registry for the service mesh. Note that
	// Istio will always source information from the ambient service registry
	// in addition to the registries specified here.
	ServiceRegistries []*DataSource `protobuf:"bytes,1,rep,name=service_registries,json=serviceRegistries" json:"service_registries,omitempty"`
	// One or more configuration stores that contain Istio configuration data
	// such as networking rules, auth/RBAC policies, etc.  If omitted, Pilot
	// will try to connect to the ambient service registry (when running on
	// kubernetes).
	ConfigStores []*DataSource `protobuf:"bytes,2,rep,name=config_stores,json=configStores" json:"config_stores,omitempty"`
	// One or more L3 networks where the endpoints from various service
	// registries are present. This is used to determine routing across
	// endpoints in different L3 networks.
	Networks []*Network `protobuf:"bytes,3,rep,name=networks" json:"networks,omitempty"`
}

func (m *Mesh) Reset()                    { *m = Mesh{} }
func (m *Mesh) String() string            { return proto.CompactTextString(m) }
func (*Mesh) ProtoMessage()               {}
func (*Mesh) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{0} }

func (m *Mesh) GetServiceRegistries() []*DataSource {
	if m != nil {
		return m.ServiceRegistries
	}
	return nil
}

func (m *Mesh) GetConfigStores() []*DataSource {
	if m != nil {
		return m.ConfigStores
	}
	return nil
}

func (m *Mesh) GetNetworks() []*Network {
	if m != nil {
		return m.Networks
	}
	return nil
}

// Network provides information about the endpoints in a routable L3
// network. A single routable L3 network can have one or more service
// registries. When Pilot ingests service registry information from various
// registries, it maps the endpoints to the networks defined here based on
// the CIDR range that matches the endpoint IP. Note that the network has no
// relation to the locality of the endpoint. The endpoint locality will be
// obtained from the service registry.
type Network struct {
	// A unique name assigned to the network.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// One or more service registries that are in this network. Endpoints
	// from these registries will be directly reachable to one another.
	// The names of the registries should correspond to the data sources.
	Registries []string                       `protobuf:"bytes,2,rep,name=registries" json:"registries,omitempty"`
	Gateways   []*Network_IstioNetworkGateway `protobuf:"bytes,3,rep,name=gateways" json:"gateways,omitempty"`
}

func (m *Network) Reset()                    { *m = Network{} }
func (m *Network) String() string            { return proto.CompactTextString(m) }
func (*Network) ProtoMessage()               {}
func (*Network) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{1} }

func (m *Network) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Network) GetRegistries() []string {
	if m != nil {
		return m.Registries
	}
	return nil
}

func (m *Network) GetGateways() []*Network_IstioNetworkGateway {
	if m != nil {
		return m.Gateways
	}
	return nil
}

// The gateway associated with this network. Traffic from remote networks
// will arrive at the specified gateway:port. All incoming traffic must
// use mTLS.
type Network_IstioNetworkGateway struct {
	// Types that are valid to be assigned to Gw:
	//	*Network_IstioNetworkGateway_RegistryServiceName
	//	*Network_IstioNetworkGateway_Address
	Gw isNetwork_IstioNetworkGateway_Gw `protobuf_oneof:"gw"`
	// The port associated with the gateway.
	Port uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// The locality associated with an explicitly specified gateway (i.e. ip)
	Locality string `protobuf:"bytes,4,opt,name=locality,proto3" json:"locality,omitempty"`
}

func (m *Network_IstioNetworkGateway) Reset()         { *m = Network_IstioNetworkGateway{} }
func (m *Network_IstioNetworkGateway) String() string { return proto.CompactTextString(m) }
func (*Network_IstioNetworkGateway) ProtoMessage()    {}
func (*Network_IstioNetworkGateway) Descriptor() ([]byte, []int) {
	return fileDescriptorMesh, []int{1, 0}
}

type isNetwork_IstioNetworkGateway_Gw interface {
	isNetwork_IstioNetworkGateway_Gw()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Network_IstioNetworkGateway_RegistryServiceName struct {
	RegistryServiceName string `protobuf:"bytes,1,opt,name=registry_service_name,json=registryServiceName,proto3,oneof"`
}
type Network_IstioNetworkGateway_Address struct {
	Address string `protobuf:"bytes,2,opt,name=address,proto3,oneof"`
}

func (*Network_IstioNetworkGateway_RegistryServiceName) isNetwork_IstioNetworkGateway_Gw() {}
func (*Network_IstioNetworkGateway_Address) isNetwork_IstioNetworkGateway_Gw()             {}

func (m *Network_IstioNetworkGateway) GetGw() isNetwork_IstioNetworkGateway_Gw {
	if m != nil {
		return m.Gw
	}
	return nil
}

func (m *Network_IstioNetworkGateway) GetRegistryServiceName() string {
	if x, ok := m.GetGw().(*Network_IstioNetworkGateway_RegistryServiceName); ok {
		return x.RegistryServiceName
	}
	return ""
}

func (m *Network_IstioNetworkGateway) GetAddress() string {
	if x, ok := m.GetGw().(*Network_IstioNetworkGateway_Address); ok {
		return x.Address
	}
	return ""
}

func (m *Network_IstioNetworkGateway) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Network_IstioNetworkGateway) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Network_IstioNetworkGateway) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Network_IstioNetworkGateway_OneofMarshaler, _Network_IstioNetworkGateway_OneofUnmarshaler, _Network_IstioNetworkGateway_OneofSizer, []interface{}{
		(*Network_IstioNetworkGateway_RegistryServiceName)(nil),
		(*Network_IstioNetworkGateway_Address)(nil),
	}
}

func _Network_IstioNetworkGateway_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Network_IstioNetworkGateway)
	// gw
	switch x := m.Gw.(type) {
	case *Network_IstioNetworkGateway_RegistryServiceName:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.RegistryServiceName)
	case *Network_IstioNetworkGateway_Address:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Address)
	case nil:
	default:
		return fmt.Errorf("Network_IstioNetworkGateway.Gw has unexpected type %T", x)
	}
	return nil
}

func _Network_IstioNetworkGateway_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Network_IstioNetworkGateway)
	switch tag {
	case 1: // gw.registry_service_name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Gw = &Network_IstioNetworkGateway_RegistryServiceName{x}
		return true, err
	case 2: // gw.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Gw = &Network_IstioNetworkGateway_Address{x}
		return true, err
	default:
		return false, nil
	}
}

func _Network_IstioNetworkGateway_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Network_IstioNetworkGateway)
	// gw
	switch x := m.Gw.(type) {
	case *Network_IstioNetworkGateway_RegistryServiceName:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.RegistryServiceName)))
		n += len(x.RegistryServiceName)
	case *Network_IstioNetworkGateway_Address:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Address)))
		n += len(x.Address)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Credentials provide the requisite information for Istio Pilot/Galley to
// interface with a remote data source (registry/config).
type Credentials struct {
	// Types that are valid to be assigned to Creds:
	//	*Credentials_KubernetesSecret
	//	*Credentials_TlsSettings
	Creds isCredentials_Creds `protobuf_oneof:"creds"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{2} }

type isCredentials_Creds interface {
	isCredentials_Creds()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Credentials_KubernetesSecret struct {
	KubernetesSecret string `protobuf:"bytes,1,opt,name=kubernetes_secret,json=kubernetesSecret,proto3,oneof"`
}
type Credentials_TlsSettings struct {
	TlsSettings *istio_networking_v1alpha31.TLSSettings `protobuf:"bytes,2,opt,name=tls_settings,json=tlsSettings,oneof"`
}

func (*Credentials_KubernetesSecret) isCredentials_Creds() {}
func (*Credentials_TlsSettings) isCredentials_Creds()      {}

func (m *Credentials) GetCreds() isCredentials_Creds {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *Credentials) GetKubernetesSecret() string {
	if x, ok := m.GetCreds().(*Credentials_KubernetesSecret); ok {
		return x.KubernetesSecret
	}
	return ""
}

func (m *Credentials) GetTlsSettings() *istio_networking_v1alpha31.TLSSettings {
	if x, ok := m.GetCreds().(*Credentials_TlsSettings); ok {
		return x.TlsSettings
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Credentials) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Credentials_OneofMarshaler, _Credentials_OneofUnmarshaler, _Credentials_OneofSizer, []interface{}{
		(*Credentials_KubernetesSecret)(nil),
		(*Credentials_TlsSettings)(nil),
	}
}

func _Credentials_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Credentials)
	// creds
	switch x := m.Creds.(type) {
	case *Credentials_KubernetesSecret:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.KubernetesSecret)
	case *Credentials_TlsSettings:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TlsSettings); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Credentials.Creds has unexpected type %T", x)
	}
	return nil
}

func _Credentials_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Credentials)
	switch tag {
	case 1: // creds.kubernetes_secret
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Creds = &Credentials_KubernetesSecret{x}
		return true, err
	case 2: // creds.tls_settings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(istio_networking_v1alpha31.TLSSettings)
		err := b.DecodeMessage(msg)
		m.Creds = &Credentials_TlsSettings{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Credentials_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Credentials)
	// creds
	switch x := m.Creds.(type) {
	case *Credentials_KubernetesSecret:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.KubernetesSecret)))
		n += len(x.KubernetesSecret)
	case *Credentials_TlsSettings:
		s := proto.Size(x.TlsSettings)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DataSource describes information about a remote service registry or a
// configuration store inside a mesh. A single control plane instance can
// interact with one or more data sources.
type DataSource struct {
	// A unique name assigned to this data source.
	Name string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type DataSource_SourceType `protobuf:"varint,2,opt,name=type,proto3,enum=istio.mesh.v1alpha1.DataSource_SourceType" json:"type,omitempty"`
	// URI where this data source can be reached.
	// Can be tcp://, https://, unix://, etc.
	// Note: URI will be ignored if kubernetes_secret is specified
	// as the kubeconfig file in the secret provides the URI.
	Uri string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// Credentials to access the remote data source
	Credentials *Credentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *DataSource) Reset()                    { *m = DataSource{} }
func (m *DataSource) String() string            { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()               {}
func (*DataSource) Descriptor() ([]byte, []int) { return fileDescriptorMesh, []int{3} }

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetType() DataSource_SourceType {
	if m != nil {
		return m.Type
	}
	return DataSource_KUBERNETES
}

func (m *DataSource) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *DataSource) GetCredentials() *Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func init() {
	proto.RegisterType((*Mesh)(nil), "istio.mesh.v1alpha1.Mesh")
	proto.RegisterType((*Network)(nil), "istio.mesh.v1alpha1.Network")
	proto.RegisterType((*Network_IstioNetworkGateway)(nil), "istio.mesh.v1alpha1.Network.IstioNetworkGateway")
	proto.RegisterType((*Credentials)(nil), "istio.mesh.v1alpha1.Credentials")
	proto.RegisterType((*DataSource)(nil), "istio.mesh.v1alpha1.DataSource")
	proto.RegisterEnum("istio.mesh.v1alpha1.DataSource_SourceType", DataSource_SourceType_name, DataSource_SourceType_value)
}
func (m *Mesh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mesh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceRegistries) > 0 {
		for _, msg := range m.ServiceRegistries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMesh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConfigStores) > 0 {
		for _, msg := range m.ConfigStores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMesh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Networks) > 0 {
		for _, msg := range m.Networks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Network) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesh(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Registries) > 0 {
		for _, s := range m.Registries {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Gateways) > 0 {
		for _, msg := range m.Gateways {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMesh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Network_IstioNetworkGateway) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Network_IstioNetworkGateway) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gw != nil {
		nn1, err := m.Gw.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.Port != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMesh(dAtA, i, uint64(m.Port))
	}
	if len(m.Locality) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesh(dAtA, i, uint64(len(m.Locality)))
		i += copy(dAtA[i:], m.Locality)
	}
	return i, nil
}

func (m *Network_IstioNetworkGateway_RegistryServiceName) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesh(dAtA, i, uint64(len(m.RegistryServiceName)))
	i += copy(dAtA[i:], m.RegistryServiceName)
	return i, nil
}
func (m *Network_IstioNetworkGateway_Address) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintMesh(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	return i, nil
}
func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		nn2, err := m.Creds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *Credentials_KubernetesSecret) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintMesh(dAtA, i, uint64(len(m.KubernetesSecret)))
	i += copy(dAtA[i:], m.KubernetesSecret)
	return i, nil
}
func (m *Credentials_TlsSettings) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TlsSettings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMesh(dAtA, i, uint64(m.TlsSettings.Size()))
		n3, err := m.TlsSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMesh(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMesh(dAtA, i, uint64(m.Type))
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMesh(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Credentials != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMesh(dAtA, i, uint64(m.Credentials.Size()))
		n4, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func encodeVarintMesh(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Mesh) Size() (n int) {
	var l int
	_ = l
	if len(m.ServiceRegistries) > 0 {
		for _, e := range m.ServiceRegistries {
			l = e.Size()
			n += 1 + l + sovMesh(uint64(l))
		}
	}
	if len(m.ConfigStores) > 0 {
		for _, e := range m.ConfigStores {
			l = e.Size()
			n += 1 + l + sovMesh(uint64(l))
		}
	}
	if len(m.Networks) > 0 {
		for _, e := range m.Networks {
			l = e.Size()
			n += 1 + l + sovMesh(uint64(l))
		}
	}
	return n
}

func (m *Network) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMesh(uint64(l))
	}
	if len(m.Registries) > 0 {
		for _, s := range m.Registries {
			l = len(s)
			n += 1 + l + sovMesh(uint64(l))
		}
	}
	if len(m.Gateways) > 0 {
		for _, e := range m.Gateways {
			l = e.Size()
			n += 1 + l + sovMesh(uint64(l))
		}
	}
	return n
}

func (m *Network_IstioNetworkGateway) Size() (n int) {
	var l int
	_ = l
	if m.Gw != nil {
		n += m.Gw.Size()
	}
	if m.Port != 0 {
		n += 1 + sovMesh(uint64(m.Port))
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovMesh(uint64(l))
	}
	return n
}

func (m *Network_IstioNetworkGateway_RegistryServiceName) Size() (n int) {
	var l int
	_ = l
	l = len(m.RegistryServiceName)
	n += 1 + l + sovMesh(uint64(l))
	return n
}
func (m *Network_IstioNetworkGateway_Address) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovMesh(uint64(l))
	return n
}
func (m *Credentials) Size() (n int) {
	var l int
	_ = l
	if m.Creds != nil {
		n += m.Creds.Size()
	}
	return n
}

func (m *Credentials_KubernetesSecret) Size() (n int) {
	var l int
	_ = l
	l = len(m.KubernetesSecret)
	n += 1 + l + sovMesh(uint64(l))
	return n
}
func (m *Credentials_TlsSettings) Size() (n int) {
	var l int
	_ = l
	if m.TlsSettings != nil {
		l = m.TlsSettings.Size()
		n += 1 + l + sovMesh(uint64(l))
	}
	return n
}
func (m *DataSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMesh(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMesh(uint64(m.Type))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMesh(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovMesh(uint64(l))
	}
	return n
}

func sovMesh(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMesh(x uint64) (n int) {
	return sovMesh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Mesh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mesh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mesh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceRegistries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceRegistries = append(m.ServiceRegistries, &DataSource{})
			if err := m.ServiceRegistries[len(m.ServiceRegistries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigStores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigStores = append(m.ConfigStores, &DataSource{})
			if err := m.ConfigStores[len(m.ConfigStores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Networks = append(m.Networks, &Network{})
			if err := m.Networks[len(m.Networks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Network: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Network: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Registries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Registries = append(m.Registries, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateways = append(m.Gateways, &Network_IstioNetworkGateway{})
			if err := m.Gateways[len(m.Gateways)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Network_IstioNetworkGateway) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioNetworkGateway: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioNetworkGateway: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistryServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gw = &Network_IstioNetworkGateway_RegistryServiceName{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gw = &Network_IstioNetworkGateway_Address{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = &Credentials_KubernetesSecret{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &istio_networking_v1alpha31.TLSSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &Credentials_TlsSettings{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DataSource_SourceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMesh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &Credentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMesh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMesh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMesh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMesh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMesh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMesh
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMesh
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMesh(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMesh = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMesh   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mesh/v1alpha1/mesh.proto", fileDescriptorMesh) }

var fileDescriptorMesh = []byte{
	// 549 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0xed, 0x34, 0xf9, 0xbe, 0x36, 0xd7, 0x6d, 0x95, 0x4e, 0x85, 0x64, 0x45, 0x28, 0x44, 0x59,
	0xa0, 0xa8, 0x08, 0x87, 0x26, 0x2c, 0x58, 0xb1, 0x48, 0x1b, 0xd1, 0xa8, 0x6d, 0x40, 0xe3, 0xb0,
	0x61, 0x63, 0x4d, 0x9d, 0x8b, 0x33, 0xaa, 0x6b, 0x5b, 0x33, 0x93, 0x46, 0x79, 0x0d, 0xf6, 0x3c,
	0x01, 0x2f, 0xc2, 0x92, 0x15, 0x6b, 0x14, 0x5e, 0x04, 0x79, 0x6c, 0xc7, 0x41, 0x8a, 0x80, 0x95,
	0xe7, 0xfe, 0x9c, 0x7b, 0xce, 0x1c, 0xdf, 0x01, 0xfb, 0x1e, 0xd5, 0xac, 0xfb, 0x70, 0xc6, 0xc3,
	0x64, 0xc6, 0xcf, 0xba, 0x69, 0xe4, 0x24, 0x32, 0xd6, 0x31, 0x3d, 0x11, 0x4a, 0x8b, 0xd8, 0x31,
	0x99, 0xa2, 0xde, 0x38, 0x8d, 0x50, 0x2f, 0x62, 0x79, 0x27, 0xa2, 0xa0, 0x00, 0xf5, 0xbb, 0x53,
	0x54, 0x5a, 0x44, 0x5c, 0x8b, 0x38, 0xf2, 0xe4, 0x3c, 0xc4, 0x6c, 0x40, 0xfb, 0x3b, 0x81, 0xea,
	0x0d, 0xaa, 0x19, 0x1d, 0x03, 0x55, 0x28, 0x1f, 0x84, 0x8f, 0x9e, 0xc4, 0x40, 0x28, 0x2d, 0x05,
	0x2a, 0x9b, 0xb4, 0x2a, 0x1d, 0xab, 0xf7, 0xc4, 0xd9, 0x42, 0xe3, 0x5c, 0x70, 0xcd, 0xdd, 0x78,
	0x2e, 0x7d, 0x64, 0xc7, 0x39, 0x94, 0xad, 0x91, 0xf4, 0x02, 0x0e, 0xfd, 0x38, 0xfa, 0x28, 0x02,
	0x4f, 0xe9, 0x58, 0xa2, 0xb2, 0x77, 0xff, 0x6d, 0xd4, 0x41, 0x86, 0x72, 0x0d, 0x88, 0xbe, 0x82,
	0xfd, 0xfc, 0x32, 0xca, 0xae, 0x98, 0x01, 0x8f, 0xb7, 0x0e, 0x18, 0x67, 0x4d, 0x6c, 0xdd, 0xdd,
	0xfe, 0xb2, 0x0b, 0x7b, 0x79, 0x96, 0x52, 0xa8, 0x46, 0xfc, 0x1e, 0x6d, 0xd2, 0x22, 0x9d, 0x1a,
	0x33, 0x67, 0xda, 0x04, 0xd8, 0xb8, 0x67, 0x2a, 0xae, 0xc6, 0x36, 0x32, 0xf4, 0x1a, 0xf6, 0x03,
	0xae, 0x71, 0xc1, 0x97, 0x05, 0xf3, 0x8b, 0x3f, 0x31, 0x3b, 0xa3, 0xb4, 0x96, 0x07, 0x6f, 0x32,
	0x20, 0x5b, 0x4f, 0x68, 0x7c, 0x26, 0x70, 0xb2, 0xa5, 0x83, 0xbe, 0x84, 0x47, 0x39, 0xe7, 0xd2,
	0x2b, 0xec, 0x2f, 0xa5, 0x5e, 0xee, 0xb0, 0x93, 0xa2, 0xec, 0x66, 0xd5, 0x71, 0xaa, 0xbd, 0x01,
	0x7b, 0x7c, 0x3a, 0x95, 0xa8, 0x52, 0xe1, 0x59, 0x5f, 0x91, 0x48, 0xef, 0x9a, 0xc4, 0x52, 0xdb,
	0x95, 0x16, 0xe9, 0x1c, 0x32, 0x73, 0xa6, 0x0d, 0xd8, 0x0f, 0x63, 0x9f, 0x87, 0x42, 0x2f, 0xed,
	0xaa, 0xf1, 0x60, 0x1d, 0x0f, 0xaa, 0xb0, 0x1b, 0x2c, 0xda, 0x9f, 0x08, 0x58, 0xe7, 0x12, 0xa7,
	0x18, 0x69, 0xc1, 0x43, 0x45, 0x9f, 0xc3, 0xf1, 0xdd, 0xfc, 0x16, 0x65, 0x84, 0x1a, 0x95, 0xa7,
	0xd0, 0x97, 0xa8, 0xd7, 0x9a, 0xea, 0x65, 0xc9, 0x35, 0x15, 0x7a, 0x05, 0x07, 0x3a, 0x4c, 0xfb,
	0xb4, 0x16, 0x51, 0x90, 0xa9, 0xb2, 0x7a, 0x4f, 0x73, 0xc3, 0xca, 0x75, 0x2c, 0x6c, 0xeb, 0x3b,
	0x93, 0x6b, 0xd7, 0xcd, 0xbb, 0x2f, 0x77, 0x98, 0xa5, 0x43, 0x55, 0x84, 0x83, 0x3d, 0xf8, 0xcf,
	0x97, 0x38, 0x55, 0xed, 0x9f, 0x04, 0xa0, 0xdc, 0x8c, 0xad, 0x7f, 0xf1, 0x35, 0x54, 0xf5, 0x32,
	0x41, 0x43, 0x78, 0xd4, 0x3b, 0xfd, 0xcb, 0x72, 0x39, 0xd9, 0x67, 0xb2, 0x4c, 0x90, 0x19, 0x1c,
	0xad, 0x43, 0x65, 0x2e, 0x85, 0x31, 0xab, 0xc6, 0xd2, 0x23, 0x1d, 0x80, 0xe5, 0x97, 0x46, 0x18,
	0xbb, 0xac, 0x5e, 0x6b, 0xeb, 0xe0, 0x0d, 0xc3, 0xd8, 0x26, 0xa8, 0xfd, 0x0c, 0xa0, 0x64, 0xa2,
	0x47, 0x00, 0x57, 0xef, 0x07, 0x43, 0x36, 0x1e, 0x4e, 0x86, 0x6e, 0x7d, 0x87, 0x1e, 0x42, 0x6d,
	0xe4, 0x4e, 0x46, 0x6f, 0xbd, 0x9b, 0xf3, 0x77, 0x75, 0x32, 0xe8, 0x7c, 0x5d, 0x35, 0xc9, 0xb7,
	0x55, 0x93, 0xfc, 0x58, 0x35, 0xc9, 0x87, 0x46, 0x46, 0x24, 0xe2, 0x2e, 0x4f, 0x44, 0xf7, 0xb7,
	0x77, 0x7f, 0xfb, 0xbf, 0x79, 0xb2, 0xfd, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x78, 0x7a,
	0x6f, 0x0f, 0x04, 0x00, 0x00,
}
