// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "networking/v1alpha3/destination_rule.proto";

package istio.mesh.v1alpha1;

option go_package="istio.io/api/mesh/v1alpha1";

// Mesh describes the set of service registries, configuration sources
// the networks where endpoints are resident, etc. Information gathered
// from these sources will be used to compute the mesh topology and set
// up L4/L7 connectivity between endpoints in the mesh. A single mesh can
// have one or more control planes, service registries, and networks.
//
// Multiple service registries can be configured for a single control
// plane.  For example, lets say there are three kubernetes clusters in
// two networks with no direct endpoint connectivity across the
// networks. Clusters us-east-c1 and us-east-c2 are in US-east region and
// cluster us-west-c1 is in US-west region. Assume that all clusters in
// US-east region are in the same network, i.e. endpoints in us-east-c1
// have direct L3 connectivity to endpoints in us-east-c2
// cluster. Assuming that Pilot running on any of these clusters has
// access to the mater nodes of each cluster (to talk to the API
// servers), the following configuration describes a mesh spanning all
// the clusters and using cluster-local istio-ingressgateway to route
// traffic to endpoints within the cluster.
//
// serviceRegistries:
// - name: us-east-c1
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-east-c1-kubeconfig
// - name: us-east-c2
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-east-c2-kubeconfig
// - name: us-west-c1
//   type: KUBERNETES
//   credentials:
//     kubernetesSecret: us-west-c1-kubeconfig
// configStores: #all configuration from local galley service
// - name: us-east-c1
//   type: ISTIO_MCP
//   uri: https://istio-galley.istio-system.svc.cluster.local:9999
//   credentials:
//     tlsSettings:
//       mode: ISTIO_MUTUAL #use istio mtls to communicate with Galley
// networks:
// - name: us-east # some arbitrary name to group endpoints
//   registries:
//   - us-east-c1
//   - us-east-c2
//   gateways:
//   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
//     port: 15443
// - name: us-west
//   registries:
//   - us-west-c1
//   gateways:
//   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
//     port: 15443
//
message Mesh {
  // service_registries describe the registries from which Istio should
  // construct the composite service registry for the service mesh. Note that
  // Istio will always source information from the ambient service registry
  // in addition to the registries specified here.
  repeated DataSource service_registries = 1;

  // One or more configuration stores that contain Istio configuration data
  // such as networking rules, auth/RBAC policies, etc.  If omitted, Pilot
  // will try to connect to the ambient service registry (when running on
  // kubernetes).
  repeated DataSource config_stores = 2;

  // One or more L3 networks where the endpoints from various service
  // registries are present. This is used to determine routing across
  // endpoints in different L3 networks.
  repeated Network networks = 3;
}

// Network provides information about the endpoints in a routable L3
// network. A single routable L3 network can have one or more service
// registries. When Pilot ingests service registry information from various
// registries, it maps the endpoints to the networks defined here based on
// the CIDR range that matches the endpoint IP. Note that the network has no
// relation to the locality of the endpoint. The endpoint locality will be
// obtained from the service registry.
message Network {
  // A unique name assigned to the network.
  string name = 1;

  // One or more service registries that are in this network. Endpoints
  // from these registries will be directly reachable to one another.
  // The names of the registries should correspond to the data sources.
  repeated string registries = 2;

  // The gateway associated with this network. Traffic from remote networks
  // will arrive at the specified gateway:port. All incoming traffic must
  // use mTLS.
  message IstioNetworkGateway {
    oneof gw {
      // A fully qualified domain name of the gateway service.  Pilot will
      // lookup the service from the service registries in the network and
      // obtain the endpoint IPs of the gateway from the service
      // registry. Note that while the service name is a fully qualified
      // domain name, it need not be resolvable outside the orchestration
      // platform for the registry. e.g., this could be
      // istio-ingressgateway.istio-system.svc.cluster.local.
      string registry_service_name = 1;

      // IP address or externally resolvable DNS address associated with the gateway.
      string address = 2;
    }

    // The port associated with the gateway.
    uint32 port = 3;

    // The locality associated with an explicitly specified gateway (i.e. ip)
    string locality = 4;
  }

  repeated IstioNetworkGateway gateways = 3;
}

// Credentials provide the requisite information for Istio Pilot/Galley to
// interface with a remote data source (registry/config).
message Credentials {
  oneof creds {
    // When interfacing with a Kubernetes data source, the
    // kubernetes_secret specifies the name of the secret that contains the
    // kubeconfig file associated with the remote kubernetes cluster.
    string kubernetes_secret = 1;
    
    // When interfacing with a remote data source that supports Istio Mesh
    // Configuration Protocol (MCP), use tls_settings to specify the tls
    // mode to use. If the MCP server uses Istio MTLS and shares
    // the root CA with Pilot, specify the TLS mode as ISTIO_MUTUAL.
    istio.networking.v1alpha3.TLSSettings tls_settings = 2;
  }
}

// DataSource describes information about a remote service registry or a
// configuration store inside a mesh. A single control plane instance can
// interact with one or more data sources.
message DataSource {
  // A unique name assigned to this data source.
  string name = 1;

  // The type of the data source determines the protocol used to interact with
  // it and obtain information.
  enum SourceType {
    // Kubernetes
    KUBERNETES = 0;

    // From a remote MCP server (Galley, CloudFoundry's MCP server, etc.)
    ISTIO_MCP = 1;
  }

  SourceType type = 2;

  // URI where this data source can be reached.
  // Can be tcp://, https://, unix://, etc.
  // Note: URI will be ignored if kubernetes_secret is specified
  // as the kubeconfig file in the secret provides the URI.
  string uri = 3;

  // Credentials to access the remote data source
  Credentials credentials = 4;
}
