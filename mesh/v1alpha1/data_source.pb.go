// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mesh/v1alpha1/data_source.proto

package v1alpha1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import istio_networking_v1alpha31 "istio.io/api/networking/v1alpha3"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The type of the data source determines the protocol used to interact with
// it and obtain information.
type DataSource_SourceType int32

const (
	// Kubernetes
	DataSource_KUBERNETES DataSource_SourceType = 0
	// From a remote MCP server (Galley, CloudFoundry's MCP server, etc.)
	DataSource_ISTIO_MCP DataSource_SourceType = 1
)

var DataSource_SourceType_name = map[int32]string{
	0: "KUBERNETES",
	1: "ISTIO_MCP",
}
var DataSource_SourceType_value = map[string]int32{
	"KUBERNETES": 0,
	"ISTIO_MCP":  1,
}

func (x DataSource_SourceType) String() string {
	return proto.EnumName(DataSource_SourceType_name, int32(x))
}
func (DataSource_SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorDataSource, []int{1, 0}
}

// Credentials provide the requisite information for Istio Pilot/Galley to
// interface with a remote data source (registry/config).
type Credentials struct {
	// Types that are valid to be assigned to Creds:
	//	*Credentials_KubernetesSecret
	//	*Credentials_TlsSettings
	Creds isCredentials_Creds `protobuf_oneof:"creds"`
}

func (m *Credentials) Reset()                    { *m = Credentials{} }
func (m *Credentials) String() string            { return proto.CompactTextString(m) }
func (*Credentials) ProtoMessage()               {}
func (*Credentials) Descriptor() ([]byte, []int) { return fileDescriptorDataSource, []int{0} }

type isCredentials_Creds interface {
	isCredentials_Creds()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Credentials_KubernetesSecret struct {
	KubernetesSecret string `protobuf:"bytes,1,opt,name=kubernetes_secret,json=kubernetesSecret,proto3,oneof"`
}
type Credentials_TlsSettings struct {
	TlsSettings *istio_networking_v1alpha31.TLSSettings `protobuf:"bytes,2,opt,name=tls_settings,json=tlsSettings,oneof"`
}

func (*Credentials_KubernetesSecret) isCredentials_Creds() {}
func (*Credentials_TlsSettings) isCredentials_Creds()      {}

func (m *Credentials) GetCreds() isCredentials_Creds {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *Credentials) GetKubernetesSecret() string {
	if x, ok := m.GetCreds().(*Credentials_KubernetesSecret); ok {
		return x.KubernetesSecret
	}
	return ""
}

func (m *Credentials) GetTlsSettings() *istio_networking_v1alpha31.TLSSettings {
	if x, ok := m.GetCreds().(*Credentials_TlsSettings); ok {
		return x.TlsSettings
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Credentials) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Credentials_OneofMarshaler, _Credentials_OneofUnmarshaler, _Credentials_OneofSizer, []interface{}{
		(*Credentials_KubernetesSecret)(nil),
		(*Credentials_TlsSettings)(nil),
	}
}

func _Credentials_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Credentials)
	// creds
	switch x := m.Creds.(type) {
	case *Credentials_KubernetesSecret:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.KubernetesSecret)
	case *Credentials_TlsSettings:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TlsSettings); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Credentials.Creds has unexpected type %T", x)
	}
	return nil
}

func _Credentials_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Credentials)
	switch tag {
	case 1: // creds.kubernetes_secret
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Creds = &Credentials_KubernetesSecret{x}
		return true, err
	case 2: // creds.tls_settings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(istio_networking_v1alpha31.TLSSettings)
		err := b.DecodeMessage(msg)
		m.Creds = &Credentials_TlsSettings{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Credentials_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Credentials)
	// creds
	switch x := m.Creds.(type) {
	case *Credentials_KubernetesSecret:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.KubernetesSecret)))
		n += len(x.KubernetesSecret)
	case *Credentials_TlsSettings:
		s := proto.Size(x.TlsSettings)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// DataSource describes information about a remote service registry or a
// configuration store inside a mesh. A single control plane instance can
// interact with one or more data sources.
type DataSource struct {
	// A unique name assigned to this data source.
	Name string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type DataSource_SourceType `protobuf:"varint,2,opt,name=type,proto3,enum=istio.mesh.v1alpha1.DataSource_SourceType" json:"type,omitempty"`
	// URI where this data source can be reached.
	// Can be tcp://, https://, unix://, etc.
	// Note: URI will be ignored if kubernetes_secret is specified
	// as the kubeconfig file in the secret provides the URI.
	Uri string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri,omitempty"`
	// Credentials to access the remote data source
	Credentials *Credentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *DataSource) Reset()                    { *m = DataSource{} }
func (m *DataSource) String() string            { return proto.CompactTextString(m) }
func (*DataSource) ProtoMessage()               {}
func (*DataSource) Descriptor() ([]byte, []int) { return fileDescriptorDataSource, []int{1} }

func (m *DataSource) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataSource) GetType() DataSource_SourceType {
	if m != nil {
		return m.Type
	}
	return DataSource_KUBERNETES
}

func (m *DataSource) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *DataSource) GetCredentials() *Credentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func init() {
	proto.RegisterType((*Credentials)(nil), "istio.mesh.v1alpha1.Credentials")
	proto.RegisterType((*DataSource)(nil), "istio.mesh.v1alpha1.DataSource")
	proto.RegisterEnum("istio.mesh.v1alpha1.DataSource_SourceType", DataSource_SourceType_name, DataSource_SourceType_value)
}
func (m *Credentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Credentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		nn1, err := m.Creds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Credentials_KubernetesSecret) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintDataSource(dAtA, i, uint64(len(m.KubernetesSecret)))
	i += copy(dAtA[i:], m.KubernetesSecret)
	return i, nil
}
func (m *Credentials_TlsSettings) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TlsSettings != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDataSource(dAtA, i, uint64(m.TlsSettings.Size()))
		n2, err := m.TlsSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *DataSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDataSource(dAtA, i, uint64(m.Type))
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Credentials != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDataSource(dAtA, i, uint64(m.Credentials.Size()))
		n3, err := m.Credentials.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func encodeVarintDataSource(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Credentials) Size() (n int) {
	var l int
	_ = l
	if m.Creds != nil {
		n += m.Creds.Size()
	}
	return n
}

func (m *Credentials_KubernetesSecret) Size() (n int) {
	var l int
	_ = l
	l = len(m.KubernetesSecret)
	n += 1 + l + sovDataSource(uint64(l))
	return n
}
func (m *Credentials_TlsSettings) Size() (n int) {
	var l int
	_ = l
	if m.TlsSettings != nil {
		l = m.TlsSettings.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}
func (m *DataSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDataSource(uint64(m.Type))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.Credentials != nil {
		l = m.Credentials.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func sovDataSource(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDataSource(x uint64) (n int) {
	return sovDataSource(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Credentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Credentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Credentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creds = &Credentials_KubernetesSecret{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &istio_networking_v1alpha31.TLSSettings{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &Credentials_TlsSettings{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (DataSource_SourceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credentials", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Credentials == nil {
				m.Credentials = &Credentials{}
			}
			if err := m.Credentials.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataSource(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDataSource
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDataSource
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDataSource(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDataSource = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataSource   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mesh/v1alpha1/data_source.proto", fileDescriptorDataSource) }

var fileDescriptorDataSource = []byte{
	// 357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x51, 0x4d, 0x8f, 0xda, 0x30,
	0x10, 0xc5, 0x85, 0xb6, 0x62, 0xd2, 0xa2, 0xd4, 0xbd, 0x44, 0x1c, 0x28, 0xe2, 0x50, 0x21, 0xaa,
	0x3a, 0x02, 0xee, 0x3d, 0x84, 0x22, 0x81, 0xe8, 0x97, 0x92, 0xf4, 0xb2, 0x97, 0xc8, 0x24, 0x16,
	0x58, 0x04, 0x27, 0xb2, 0x9d, 0x5d, 0xf1, 0x37, 0xf6, 0x57, 0xed, 0x71, 0x7f, 0xc2, 0x8a, 0xfd,
	0x23, 0x2b, 0x1c, 0xa2, 0xb0, 0x12, 0x27, 0x8f, 0x35, 0x6f, 0xde, 0x7b, 0xf3, 0x06, 0xbe, 0xec,
	0x99, 0xda, 0xba, 0xb7, 0x63, 0x9a, 0xe6, 0x5b, 0x3a, 0x76, 0x13, 0xaa, 0x69, 0xa4, 0xb2, 0x42,
	0xc6, 0x8c, 0xe4, 0x32, 0xd3, 0x19, 0xfe, 0xcc, 0x95, 0xe6, 0x19, 0x39, 0xc1, 0x48, 0x05, 0xeb,
	0x8e, 0x04, 0xd3, 0x77, 0x99, 0xdc, 0x71, 0xb1, 0xa9, 0x66, 0xa7, 0x6e, 0xc2, 0x94, 0xe6, 0x82,
	0x6a, 0x9e, 0x89, 0x48, 0x16, 0xe9, 0x99, 0x60, 0x70, 0x8f, 0xc0, 0x9a, 0x49, 0x96, 0x30, 0xa1,
	0x39, 0x4d, 0x15, 0xfe, 0x0e, 0x9f, 0x76, 0xc5, 0x9a, 0x49, 0xc1, 0x34, 0x53, 0x91, 0x62, 0xb1,
	0x64, 0xda, 0x41, 0x7d, 0x34, 0x6c, 0x2f, 0x1a, 0xbe, 0x5d, 0xb7, 0x02, 0xd3, 0xc1, 0x2b, 0xf8,
	0xa0, 0xd3, 0x13, 0x4e, 0x6b, 0x2e, 0x36, 0xca, 0x79, 0xd3, 0x47, 0x43, 0x6b, 0xf2, 0x95, 0x94,
	0xb6, 0x6a, 0x1f, 0x95, 0xb9, 0x29, 0x09, 0x7f, 0x05, 0xc1, 0x19, 0xbd, 0x68, 0xf8, 0x96, 0x4e,
	0x55, 0xf5, 0xf5, 0xde, 0xc3, 0xdb, 0x58, 0xb2, 0x44, 0x0d, 0x9e, 0x11, 0xc0, 0x4f, 0xaa, 0x69,
	0x60, 0x56, 0xc5, 0x18, 0x5a, 0x82, 0xee, 0x59, 0x69, 0xc3, 0x37, 0x35, 0xfe, 0x01, 0x2d, 0x7d,
	0xc8, 0x99, 0x11, 0xec, 0x4c, 0x46, 0xe4, 0x4a, 0x0e, 0xa4, 0xa6, 0x20, 0xe5, 0x13, 0x1e, 0x72,
	0xe6, 0x9b, 0x39, 0x6c, 0x43, 0xb3, 0x90, 0xdc, 0x69, 0x1a, 0xca, 0x53, 0x89, 0x3d, 0xb0, 0xe2,
	0x3a, 0x08, 0xa7, 0x65, 0x36, 0xe9, 0x5f, 0x25, 0xbe, 0x08, 0xcc, 0xbf, 0x1c, 0x1a, 0x7c, 0x03,
	0xa8, 0x95, 0x70, 0x07, 0x60, 0xf5, 0xdf, 0x9b, 0xfb, 0x7f, 0xe6, 0xe1, 0x3c, 0xb0, 0x1b, 0xf8,
	0x23, 0xb4, 0x97, 0x41, 0xb8, 0xfc, 0x1b, 0xfd, 0x9e, 0xfd, 0xb3, 0x91, 0x37, 0x7c, 0x38, 0xf6,
	0xd0, 0xe3, 0xb1, 0x87, 0x9e, 0x8e, 0x3d, 0x74, 0xd3, 0x2d, 0x85, 0x78, 0xe6, 0xd2, 0x9c, 0xbb,
	0xaf, 0xee, 0xbe, 0x7e, 0x67, 0x6e, 0x35, 0x7d, 0x09, 0x00, 0x00, 0xff, 0xff, 0x17, 0x61, 0x56,
	0xeb, 0x0f, 0x02, 0x00, 0x00,
}
