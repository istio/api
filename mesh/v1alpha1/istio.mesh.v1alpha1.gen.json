{
  "openapi": "3.0.0",
  "info": {
    "title": "Configuration affecting the service mesh as a whole.",
    "version": "v1alpha1"
  },
  "components": {
    "schemas": {
      "istio.mesh.v1alpha1.ObjectMeta": {
        "type": "object",
        "properties": {
          "name": {
            "description": "From k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.",
            "type": "string",
            "format": "string"
          },
          "namespace": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.IstioComponentSetSpec": {
        "description": "IstioComponentSpec defines the desired installed state of Istio components.",
        "type": "object",
        "properties": {
          "pilot": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "proxy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "sidecarInjector": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "policy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "telemetry": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "citadel": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "nodeAgent": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "galley": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "cni": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "coreDNS": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ComponentSpec"
          },
          "ingressGateways": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.GatewaySpec"
            }
          },
          "egressGateways": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.GatewaySpec"
            }
          },
          "extraComponents": {
            "description": "Extra addon components which are not explicitly specified above.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.ExternalComponentSpec"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.ComponentSpec": {
        "description": "Configuration for internal components.",
        "type": "object",
        "properties": {
          "namespace": {
            "description": "Namespace for the component.",
            "type": "string",
            "format": "string"
          },
          "spec": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeInterface"
          },
          "enabled": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeBoolValueForPB"
          },
          "hub": {
            "description": "Hub for the component (overrides top level hub setting).",
            "type": "string",
            "format": "string"
          },
          "tag": {
            "description": "Tag for the component (overrides top level tag setting).",
            "type": "string",
            "format": "string"
          },
          "k8s": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.KubernetesResourcesSpec"
          }
        }
      },
      "istio.mesh.v1alpha1.GatewaySpec": {
        "description": "Configuration for gateways.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name for the gateway.",
            "type": "string",
            "format": "string"
          },
          "namespace": {
            "description": "Enablement is implied by the existence of this spec.",
            "type": "string",
            "format": "string"
          },
          "hub": {
            "description": "Hub for the component (overrides top level hub setting).",
            "type": "string",
            "format": "string"
          },
          "tag": {
            "description": "Tag for the component (overrides top level tag setting).",
            "type": "string",
            "format": "string"
          },
          "k8s": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.KubernetesResourcesSpec"
          },
          "label": {
            "description": "Labels for the gateway.",
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.ExternalComponentSpec": {
        "description": "Configuration for external components.",
        "type": "object",
        "properties": {
          "namespace": {
            "description": "Enablement is implied by the existence of this spec.",
            "type": "string",
            "format": "string"
          },
          "spec": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeInterface"
          },
          "k8s": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.KubernetesResourcesSpec"
          },
          "chartPath": {
            "description": "Chart path for addon components.",
            "type": "string",
            "format": "string"
          },
          "schema": {
            "description": "Optional schema to validate spec against.",
            "type": "object",
            "required": [
              "@type"
            ],
            "properties": {
              "@type": {
                "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `type.googleapis.com/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted). The remaining fields of this object correspond to fields of the proto messsage. If the embedded message is well-known and has a custom JSON representation, that representation is assigned to the 'value' field.",
                "type": "string",
                "format": "string"
              }
            }
          }
        }
      },
      "istio.mesh.v1alpha1.TypeBoolValueForPB": {
        "description": "GOTYPE: *BoolValueForPB",
        "type": "object"
      },
      "istio.mesh.v1alpha1.TypeInterface": {
        "description": "GOTYPE: interface{}",
        "type": "object"
      },
      "istio.mesh.v1alpha1.KubernetesResourcesSpec": {
        "description": "KubernetesResourcesConfig is a common set of k8s resource configs for components.",
        "type": "object",
        "properties": {
          "env": {
            "description": "Deployment environment variables. https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.EnvVar"
            }
          },
          "resources": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Resources"
          },
          "affinity": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Affinity"
          },
          "hpaSpec": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.HorizontalPodAutoscalerSpec"
          },
          "imagePullPolicy": {
            "description": "k8s imagePullPolicy. https://kubernetes.io/docs/concepts/containers/images/",
            "type": "string",
            "format": "string"
          },
          "nodeSelector": {
            "description": "k8s nodeSelector. https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector",
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          },
          "podDisruptionBudget": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodDisruptionBudgetSpec"
          },
          "podAnnotations": {
            "description": "k8s pod annotations. https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/",
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          },
          "priorityClassName": {
            "description": "k8s priority_class_name. Default for all resources unless overridden. https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass",
            "type": "string",
            "format": "string"
          },
          "readinessProbe": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ReadinessProbe"
          },
          "replicaCount": {
            "description": "k8s Deployment replicas setting. https://kubernetes.io/docs/concepts/workloads/controllers/deployment/",
            "type": "integer"
          },
          "service": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ServiceSpec"
          },
          "strategy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.DeploymentStrategy"
          },
          "tolerations": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Toleration"
          },
          "overlays": {
            "description": "Overlays for k8s resources in rendered manifests.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.K8sObjectOverlay"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.Affinity": {
        "description": "Mirrors k8s.io.api.core.v1.",
        "type": "object",
        "properties": {
          "nodeAffinity": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeAffinity"
          },
          "podAffinity": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodAffinity"
          },
          "podAntiAffinity": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodAntiAffinity"
          }
        }
      },
      "istio.mesh.v1alpha1.EnvVar": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "string"
          },
          "value": {
            "type": "string",
            "format": "string"
          },
          "valueFrom": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.EnvVarSource"
          }
        }
      },
      "istio.mesh.v1alpha1.PodDisruptionBudgetSpec": {
        "description": "Mirrors k8s.io.api.policy.v1beta1.PodDisruptionBudget for unmarshaling.",
        "type": "object",
        "properties": {
          "selector": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
          },
          "minAvailable": {
            "type": "integer"
          },
          "maxUnavailable": {
            "type": "integer"
          }
        }
      },
      "istio.mesh.v1alpha1.ReadinessProbe": {
        "description": "Mirrors k8s.io.api.core.v1.Probe for unmarshaling.",
        "type": "object",
        "properties": {
          "timeoutSeconds": {
            "type": "integer",
            "format": "int32"
          },
          "exec": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ExecAction"
          },
          "httpGet": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.HTTPGetAction"
          },
          "tcpSocket": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TCPSocketAction"
          },
          "initialDelaySeconds": {
            "type": "integer",
            "format": "int32"
          },
          "periodSeconds": {
            "type": "integer",
            "format": "int32"
          },
          "successThreshold": {
            "type": "integer",
            "format": "int32"
          },
          "failureThreshold": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "istio.mesh.v1alpha1.Resources": {
        "description": "Mirrors k8s.io.api.core.v1.ResourceRequirements for unmarshaling.",
        "type": "object",
        "properties": {
          "limits": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          },
          "requests": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.ServiceSpec": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "format": "string"
          },
          "selector": {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          },
          "ports": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.ServicePort"
            }
          },
          "clusterIP": {
            "type": "string",
            "format": "string"
          },
          "externalIPs": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "sessionAffinity": {
            "type": "string",
            "format": "string"
          },
          "loadBalancerIP": {
            "type": "string",
            "format": "string"
          },
          "loadBalancerSourceRanges": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "externalName": {
            "type": "string",
            "format": "string"
          },
          "externalTrafficPolicy": {
            "type": "string",
            "format": "string"
          },
          "healthCheckNodePort": {
            "type": "integer",
            "format": "int32"
          },
          "publishNotReadyAddresses": {
            "type": "boolean"
          },
          "sessionAffinityConfig": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.SessionAffinityConfig"
          }
        }
      },
      "istio.mesh.v1alpha1.DeploymentStrategy": {
        "description": "Mirrors k8s.io.api.apps.v1.DeploymentStrategy for unmarshaling.",
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "format": "string"
          },
          "rollingUpdate": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.RollingUpdateDeployment"
          }
        }
      },
      "istio.mesh.v1alpha1.Toleration": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "format": "string"
          },
          "operator": {
            "type": "string",
            "format": "string"
          },
          "value": {
            "type": "string",
            "format": "string"
          },
          "effect": {
            "type": "string",
            "format": "string"
          },
          "tolerationSeconds": {
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "istio.mesh.v1alpha1.K8sObjectOverlay": {
        "description": "Patch for an existing k8s resource.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of resource. Namespace is always the component namespace.",
            "type": "string",
            "format": "string"
          },
          "kind": {
            "description": "Resource kind.",
            "type": "string",
            "format": "string"
          },
          "apiVersion": {
            "description": "Resource API version.",
            "type": "string",
            "format": "string"
          },
          "patches": {
            "description": "List of patches to apply to resource.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.K8sObjectOverlay.PathValue"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.K8sObjectOverlay.PathValue": {
        "type": "object",
        "properties": {
          "path": {
            "description": "Path of the form a.b:c.e.:f Where b:c is a list element selector of the form key:value and :f is a list selector of the form :value. All path intermediate nodes must exist.",
            "type": "string",
            "format": "string"
          },
          "value": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeInterface"
          }
        }
      },
      "istio.mesh.v1alpha1.TypeMapStringInterface": {
        "description": "GOTYPE: map[string]interface{}",
        "type": "object"
      },
      "istio.mesh.v1alpha1.MeshConfig": {
        "description": "MeshConfig defines mesh-wide variables shared by all Envoy instances in the Istio service mesh.",
        "type": "object",
        "properties": {
          "localityLbSetting": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting"
          },
          "connectTimeout": {
            "description": "Connection timeout used by Envoy. (MUST BE \u003e=1ms)",
            "type": "string"
          },
          "tcpKeepalive": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive"
          },
          "h2UpgradePolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy"
          },
          "outboundTrafficPolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy"
          },
          "mixerCheckServer": {
            "description": "Address of the server that will be used by the proxies for policy check calls. By using different names for mixerCheckServer and mixerReportServer, it is possible to have one set of Mixer servers handle policy check calls while another set of Mixer servers handle telemetry calls.",
            "type": "string",
            "format": "string"
          },
          "mixerReportServer": {
            "description": "Address of the server that will be used by the proxies for policy report calls.",
            "type": "string",
            "format": "string"
          },
          "disablePolicyChecks": {
            "description": "Disable policy checks by the Mixer service. Default is false, i.e. Mixer policy check is enabled by default.",
            "type": "boolean"
          },
          "disableMixerHttpReports": {
            "description": "Disable telemetry reporting by the Mixer service for HTTP traffic. Default is false (telemetry reporting via Mixer is enabled). This option provides a transition path for Istio extensibility v2.",
            "type": "boolean"
          },
          "policyCheckFailOpen": {
            "description": "Allow all traffic in cases when the Mixer policy service cannot be reached. Default is false which means the traffic is denied when the client is unable to connect to Mixer.",
            "type": "boolean"
          },
          "sidecarToTelemetrySessionAffinity": {
            "description": "Enable session affinity for Envoy Mixer reports so that calls from a proxy will always target the same Mixer instance.",
            "type": "boolean"
          },
          "proxyListenPort": {
            "description": "Port on which Envoy should listen for incoming connections from other services.",
            "type": "integer",
            "format": "int32"
          },
          "proxyHttpPort": {
            "description": "Port on which Envoy should listen for HTTP PROXY requests if set.",
            "type": "integer",
            "format": "int32"
          },
          "protocolDetectionTimeout": {
            "description": "Automatic protocol detection uses a set of heuristics to determine whether the connection is using TLS or not (on the server side), as well as the application protocol being used (e.g., http vs tcp). These heuristics rely on the client sending the first bits of data. For server first protocols like MySQL, MongoDB, etc., Envoy will timeout on the protocol detection after the specified period, defaulting to non mTLS plain TCP traffic. Set this field to tweak the period that Envoy will wait for the client to send the first bits of data. (MUST BE \u003e=1ms)",
            "type": "string"
          },
          "ingressClass": {
            "description": "Class of ingress resources to be processed by Istio ingress controller. This corresponds to the value of \"kubernetes.io/ingress.class\" annotation.",
            "type": "string",
            "format": "string"
          },
          "ingressService": {
            "description": "Name of theKubernetes service used for the istio ingress controller.",
            "type": "string",
            "format": "string"
          },
          "ingressControllerMode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.IngressControllerMode"
          },
          "authPolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.AuthPolicy",
            "deprecated": true
          },
          "rdsRefreshDelay": {
            "type": "string",
            "deprecated": true
          },
          "enableTracing": {
            "description": "Flag to control generation of trace spans and request IDs. Requires a trace span collector defined in the proxy configuration.",
            "type": "boolean"
          },
          "accessLogFile": {
            "description": "File address for the proxy access log (e.g. /dev/stdout). Empty value disables access logging.",
            "type": "string",
            "format": "string"
          },
          "accessLogFormat": {
            "description": "Format for the proxy access log Empty value results in proxy's default access log format",
            "type": "string",
            "format": "string"
          },
          "accessLogEncoding": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding"
          },
          "enableEnvoyAccessLogService": {
            "description": "This flag enables Envoy's gRPC Access Log Service. See [Access Log Service](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/accesslog/v2/als.proto) for details about Envoy's gRPC Access Log Service API.",
            "type": "boolean"
          },
          "defaultConfig": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig"
          },
          "mixerAddress": {
            "type": "string",
            "format": "string",
            "deprecated": true
          },
          "enableClientSidePolicyCheck": {
            "description": "Enables client side policy checks.",
            "type": "boolean"
          },
          "sdsUdsPath": {
            "description": "Unix Domain Socket through which Envoy communicates with NodeAgent SDS to get key/cert for mTLS. Use secret-mount files instead of SDS if set to empty. @deprecated - istio agent will detect and send the path to envoy.",
            "type": "string",
            "format": "string",
            "deprecated": true
          },
          "sdsRefreshDelay": {
            "type": "string",
            "deprecated": true
          },
          "configSources": {
            "description": "ConfigSource describes a source of configuration data for networking rules, and other Istio configuration artifacts. Multiple data sources can be configured for a single control plane.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.ConfigSource"
            }
          },
          "enableAutoMtls": {
            "description": "This flag is used to enable mutual TLS automatically for service to service communication within the mesh, default false. If set to true, and a given service does not have a corresponding DestinationRule configured, or its DestinationRule does not have TLSSettings specified, Istio configures client side TLS configuration appropriately. More specifically, If the upstream authentication policy is in STRICT mode, use Istio provisioned certificate for mutual TLS to connect to upstream. If upstream service is in plain text mode, use plain text. If the upstream authentication policy is in PERMISSIVE mode, Istio configures clients to use mutual TLS when server sides are capable of accepting mutual TLS traffic. If service DestinationRule exists and has TLSSettings specified, that is always used instead.",
            "type": "boolean",
            "nullable": true
          },
          "enableSdsTokenMount": {
            "description": "This flag is used by secret discovery service(SDS). If set to true ([prerequisite](https://kubernetes.io/docs/concepts/storage/volumes/#projected)), Istio will inject volumes mount for Kubernetes service account trustworthy JWT(which is available with Kubernetes 1.12 or higher), so that the Kubernetes API server mounts Kubernetes service account trustworthy JWT to the Envoy container, which will be used to request key/cert eventually. This isn't supported for non-Kubernetes cases.",
            "type": "boolean"
          },
          "sdsUseK8sSaJwt": {
            "description": "This flag is used by secret discovery service(SDS). If set to true, Envoy will fetch a normal Kubernetes service account JWT from '/var/run/secrets/kubernetes.io/serviceaccount/token' (https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod) and pass to sds server, which will be used to request key/cert eventually. If both enable_sds_token_mount and sds_use_k8s_sa_jwt are set to true, enable_sds_token_mount(trustworthy jwt) takes precedence. This isn't supported for non-k8s case.",
            "type": "boolean"
          },
          "trustDomain": {
            "description": "The trust domain corresponds to the trust root of a system. Refer to [SPIFFE-ID](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain)",
            "type": "string",
            "format": "string"
          },
          "trustDomainAliases": {
            "description": "The trust domain aliases represent the aliases of `trust_domain`. For example, if we have ```yaml trustDomain: td1 trustDomainAliases: [\"td2\", \"td3\"] ``` Any service with the identity `td1/ns/foo/sa/a-service-account`, `td2/ns/foo/sa/a-service-account`, or `td3/ns/foo/sa/a-service-account` will be treated the same in the Istio mesh.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "defaultServiceExportTo": {
            "description": "The default value for the ServiceEntry.export_to field and services imported through container registry integrations, e.g. this applies to Kubernetes Service resources. The value is a list of namespace names and reserved namespace aliases. The allowed namespace aliases are: * - All Namespaces . - Current Namespace ~ - No Namespace",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "defaultVirtualServiceExportTo": {
            "description": "The default value for the VirtualService.export_to field. Has the same syntax as 'default_service_export_to'.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "defaultDestinationRuleExportTo": {
            "description": "The default value for the DestinationRule.export_to field. Has the same syntax as 'default_service_export_to'.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "rootNamespace": {
            "description": "The namespace to treat as the administrative root namespace for Istio configuration. When processing a leaf namespace Istio will search for declarations in that namespace first and if none are found it will search in the root namespace. Any matching declaration found in the root namespace is processed as if it were declared in the leaf namespace.",
            "type": "string",
            "format": "string"
          },
          "dnsRefreshRate": {
            "description": "Configures DNS refresh rate for Envoy clusters of type STRICT_DNS",
            "type": "string"
          },
          "disableReportBatch": {
            "description": "The flag to disable report batch.",
            "type": "boolean"
          },
          "reportBatchMaxEntries": {
            "description": "When disable_report_batch is false, this value specifies the maximum number of requests that are batched in report. If left unspecified, the default value of report_batch_max_entries == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.",
            "type": "integer"
          },
          "reportBatchMaxTime": {
            "description": "When disable_report_batch is false, this value specifies the maximum elapsed time a batched report will be sent after a user request is processed. If left unspecified, the default report_batch_max_time == 0 will use the hardcoded defaults of istio::mixerclient::ReportOptions.",
            "type": "string"
          },
          "inboundClusterStatName": {
            "description": "Name to be used while emitting statistics for inbound clusters. By default, Istio emits statistics with the pattern `inbound|\u003cport\u003e|\u003cport-name\u003e|\u003cservice-FQDN\u003e`. For example `inbound|7443|grpc-reviews|reviews.prod.svc.cluster.local`. This can be used to override that pattern.",
            "type": "string",
            "format": "string"
          },
          "outboundClusterStatName": {
            "description": "Name to be used while emitting statistics for outbound clusters. By default, Istio emits statistics with the pattern `outbound|\u003cport\u003e|\u003csubsetname\u003e|\u003cservice-FQDN\u003e`. For example `outbound|8080|v2|reviews.prod.svc.cluster.local`. This can be used to override that pattern.",
            "type": "string",
            "format": "string"
          },
          "certificates": {
            "description": "Configure the provision of certificates.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Certificate"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.IngressControllerMode": {
        "type": "string",
        "enum": [
          "OFF",
          "DEFAULT",
          "STRICT"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.AuthPolicy": {
        "type": "string",
        "enum": [
          "NONE",
          "MUTUAL_TLS"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding": {
        "type": "string",
        "enum": [
          "TEXT",
          "JSON"
        ]
      },
      "istio.mesh.v1alpha1.ProxyConfig": {
        "description": "ProxyConfig defines variables for individual Envoy instances.",
        "type": "object",
        "properties": {
          "connectTimeout": {
            "description": "Connection timeout used by Envoy for supporting services. (MUST BE \u003e=1ms)",
            "type": "string"
          },
          "configPath": {
            "description": "Path to the generated configuration file directory. Proxy agent generates the actual configuration and stores it in this directory.",
            "type": "string",
            "format": "string"
          },
          "binaryPath": {
            "description": "Path to the proxy binary",
            "type": "string",
            "format": "string"
          },
          "serviceCluster": {
            "description": "Service cluster defines the name for the service_cluster that is shared by all Envoy instances. This setting corresponds to _--service-cluster_ flag in Envoy. In a typical Envoy deployment, the _service-cluster_ flag is used to identify the caller, for source-based routing scenarios.",
            "type": "string",
            "format": "string"
          },
          "drainDuration": {
            "description": "The time in seconds that Envoy will drain connections during a hot restart. MUST be \u003e=1s (e.g., _1s/1m/1h_)",
            "type": "string"
          },
          "parentShutdownDuration": {
            "description": "The time in seconds that Envoy will wait before shutting down the parent process during a hot restart. MUST be \u003e=1s (e.g., _1s/1m/1h_). MUST BE greater than _drain_duration_ parameter.",
            "type": "string"
          },
          "discoveryAddress": {
            "description": "Address of the discovery service exposing xDS with mTLS connection. The inject configuration may override this value.",
            "type": "string",
            "format": "string"
          },
          "discoveryRefreshDelay": {
            "type": "string",
            "deprecated": true
          },
          "zipkinAddress": {
            "description": "Address of the Zipkin service (e.g. _zipkin:9411_). DEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.",
            "type": "string",
            "format": "string",
            "deprecated": true
          },
          "statsdUdpAddress": {
            "description": "IP Address and Port of a statsd UDP listener (e.g. _10.75.241.127:9125_).",
            "type": "string",
            "format": "string"
          },
          "envoyMetricsServiceAddress": {
            "type": "string",
            "format": "string",
            "deprecated": true
          },
          "proxyAdminPort": {
            "description": "Port on which Envoy should listen for administrative commands.",
            "type": "integer",
            "format": "int32"
          },
          "availabilityZone": {
            "type": "string",
            "format": "string",
            "deprecated": true
          },
          "controlPlaneAuthPolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.AuthenticationPolicy"
          },
          "customConfigFile": {
            "description": "File path of custom proxy configuration, currently used by proxies in front of Mixer and Pilot.",
            "type": "string",
            "format": "string"
          },
          "statNameLength": {
            "description": "Maximum length of name field in Envoy's metrics. The length of the name field is determined by the length of a name field in a service and the set of labels that comprise a particular version of the service. The default value is set to 189 characters. Envoy's internal metrics take up 67 characters, for a total of 256 character name per metric. Increase the value of this field if you find that the metrics from Envoys are truncated.",
            "type": "integer",
            "format": "int32"
          },
          "concurrency": {
            "description": "The number of worker threads to run. Default value is number of cores on the machine.",
            "type": "integer",
            "format": "int32"
          },
          "proxyBootstrapTemplatePath": {
            "description": "Path to the proxy bootstrap template file",
            "type": "string",
            "format": "string"
          },
          "interceptionMode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode"
          },
          "tracing": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing"
          },
          "sds": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.SDS"
          },
          "envoyAccessLogService": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.RemoteService"
          },
          "envoyMetricsService": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.RemoteService"
          },
          "proxyMetadata": {
            "description": "Additional env variables for the proxy. Names starting with ISTIO_META_ will be included in the generated bootstrap and sent to the XDS server.",
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode"
          }
        }
      },
      "istio.mesh.v1alpha1.ConfigSource": {
        "description": "ConfigSource describes information about a configuration store inside a mesh. A single control plane instance can interact with one or more data sources.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of the server implementing the Istio Mesh Configuration protocol (MCP). Can be IP address or a fully qualified DNS name. Use fs:/// to specify a file-based backend with absolute path to the directory.",
            "type": "string",
            "format": "string"
          },
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TLSSettings"
          },
          "subscribedResources": {
            "description": "Describes the source of configuration, if nothing is specified default is MCP",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Resource"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy": {
        "description": "Default Policy for upgrading http1.1 connections to http2.",
        "type": "string",
        "enum": [
          "DO_NOT_UPGRADE",
          "UPGRADE"
        ]
      },
      "istio.mesh.v1alpha1.Certificate": {
        "description": "Certificate configures the provision of a certificate and its key. Example 1: key and cert stored in a secret { secretName: galley-cert secretNamespace: istio-system dnsNames: - galley.istio-system.svc - galley.mydomain.com } Example 2: key and cert stored in a directory { dnsNames: - pilot.istio-system - pilot.istio-system.svc - pilot.mydomain.com }",
        "type": "object",
        "properties": {
          "secretName": {
            "description": "Name of the secret the certificate and its key will be stored into. If it is empty, it will not be stored into a secret. Instead, the certificate and its key will be stored into a hard-coded directory.",
            "type": "string",
            "format": "string"
          },
          "dnsNames": {
            "description": "The DNS names for the certificate. A certificate may contain multiple DNS names.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode": {
        "type": "string",
        "enum": [
          "REGISTRY_ONLY",
          "ALLOW_ANY"
        ]
      },
      "istio.mesh.v1alpha1.Resource": {
        "description": "Resource describes the source of configuration",
        "type": "string",
        "enum": [
          "SERVICE_REGISTRY"
        ]
      },
      "istio.mesh.v1alpha1.NodeAffinity": {
        "type": "object",
        "properties": {
          "requiredDuringSchedulingIgnoredDuringExecution": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeSelector"
          },
          "preferredDuringSchedulingIgnoredDuringExecution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.PreferredSchedulingTerm"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.PodAffinity": {
        "type": "object",
        "properties": {
          "requiredDuringSchedulingIgnoredDuringExecution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodAffinityTerm"
            }
          },
          "preferredDuringSchedulingIgnoredDuringExecution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.WeightedPodAffinityTerm"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.PodAntiAffinity": {
        "type": "object",
        "properties": {
          "requiredDuringSchedulingIgnoredDuringExecution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodAffinityTerm"
            }
          },
          "preferredDuringSchedulingIgnoredDuringExecution": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.WeightedPodAffinityTerm"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.NodeSelector": {
        "type": "object",
        "properties": {
          "nodeSelectorTerms": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeSelectorTerm"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.PreferredSchedulingTerm": {
        "type": "object",
        "properties": {
          "weight": {
            "type": "integer",
            "format": "int32"
          },
          "preference": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeSelectorTerm"
          }
        }
      },
      "istio.mesh.v1alpha1.NodeSelectorTerm": {
        "type": "object",
        "properties": {
          "matchExpressions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeSelectorRequirement"
            }
          },
          "matchFields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.NodeSelectorRequirement"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.NodeSelectorRequirement": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "format": "string"
          },
          "operator": {
            "type": "string",
            "format": "string"
          },
          "values": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.PodAffinityTerm": {
        "type": "object",
        "properties": {
          "labelSelector": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
          },
          "namespaces": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "topologyKey": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.WeightedPodAffinityTerm": {
        "type": "object",
        "properties": {
          "weight": {
            "type": "integer",
            "format": "int32"
          },
          "podAffinityTerm": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.PodAffinityTerm"
          }
        }
      },
      "istio.mesh.v1alpha1.ExecAction": {
        "description": "Mirrors k8s.io.api.core.v1.ExecAction for unmarshaling.",
        "type": "object",
        "properties": {
          "command": {
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.HTTPGetAction": {
        "description": "Mirrors k8s.io.api.core.v1.HTTPGetAction for unmarshaling.",
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "format": "string"
          },
          "host": {
            "type": "string",
            "format": "string"
          },
          "port": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeIntOrStringForPB"
          },
          "scheme": {
            "type": "string",
            "format": "string"
          },
          "httpHeaders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.HTTPHeader"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.TCPSocketAction": {
        "description": "Mirrors k8s.io.api.core.v1.TCPSocketAction for unmarshaling.",
        "type": "object",
        "properties": {
          "host": {
            "type": "string",
            "format": "string"
          },
          "port": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeIntOrStringForPB"
          }
        }
      },
      "istio.mesh.v1alpha1.TypeIntOrStringForPB": {
        "description": "GOTYPE: *IntOrStringForPB",
        "type": "object"
      },
      "istio.mesh.v1alpha1.HTTPHeader": {
        "description": "Mirrors k8s.io.api.core.v1.HTTPHeader for unmarshaling.",
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "string"
          },
          "value": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.RollingUpdateDeployment": {
        "description": "Mirrors k8s.io.api.apps.v1.RollingUpdateDeployment for unmarshaling.",
        "type": "object",
        "properties": {
          "maxUnavailable": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeIntOrStringForPB"
          },
          "maxSurge": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeIntOrStringForPB"
          }
        }
      },
      "istio.mesh.v1alpha1.EnvVarSource": {
        "type": "object",
        "properties": {
          "fieldRef": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ObjectFieldSelector"
          },
          "resourceFieldRef": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ResourceFieldSelector"
          },
          "configMapKeyRef": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ConfigMapKeySelector"
          },
          "secretKeyRef": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.SecretKeySelector"
          }
        }
      },
      "istio.mesh.v1alpha1.ObjectFieldSelector": {
        "type": "object",
        "properties": {
          "apiVersion": {
            "type": "string",
            "format": "string"
          },
          "fieldPath": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.ResourceFieldSelector": {
        "type": "object",
        "properties": {
          "resource": {
            "type": "string",
            "format": "string"
          },
          "containerName": {
            "type": "string",
            "format": "string"
          },
          "divisor": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          }
        }
      },
      "istio.mesh.v1alpha1.ConfigMapKeySelector": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "format": "string"
          },
          "localObjectReference": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.LocalObjectReference"
          },
          "optional": {
            "type": "boolean"
          }
        }
      },
      "istio.mesh.v1alpha1.SecretKeySelector": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "format": "string"
          },
          "localObjectReference": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.LocalObjectReference"
          },
          "optional": {
            "type": "boolean"
          }
        }
      },
      "istio.mesh.v1alpha1.LocalObjectReference": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.ServicePort": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "format": "string"
          },
          "port": {
            "type": "integer",
            "format": "int32"
          },
          "protocol": {
            "type": "string",
            "format": "string"
          },
          "targetPort": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
          },
          "nodePort": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "istio.mesh.v1alpha1.SessionAffinityConfig": {
        "type": "object",
        "properties": {
          "clientIP": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ClientIPConfig"
          }
        }
      },
      "istio.mesh.v1alpha1.ClientIPConfig": {
        "type": "object",
        "properties": {
          "timeoutSeconds": {
            "type": "integer",
            "format": "int32"
          }
        }
      },
      "istio.mesh.v1alpha1.Network": {
        "description": "Network provides information about the endpoints in a routable L3 network. A single routable L3 network can have one or more service registries. Note that the network has no relation to the locality of the endpoint. The endpoint locality will be obtained from the service registry.",
        "type": "object",
        "properties": {
          "endpoints": {
            "description": "The list of endpoints in the network (obtained through the constituent service registries or from CIDR ranges). All endpoints in the network are directly accessible to one another.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Network.NetworkEndpoints"
            }
          },
          "gateways": {
            "description": "Set of gateways associated with the network.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Network.IstioNetworkGateway"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.Network.NetworkEndpoints": {
        "description": "NetworkEndpoints describes how the network associated with an endpoint should be inferred. An endpoint will be assigned to a network based on the following rules: 1. Implicitly: If the registry explicitly provides information about the network to which the endpoint belongs to. In some cases, its possible to indicate the network associated with the endpoint by adding the `ISTIO_META_NETWORK` environment variable to the sidecar.",
        "type": "object",
        "oneOf": [
          {
            "required": [
              "fromCidr"
            ],
            "properties": {
              "fromCidr": {
                "description": "A CIDR range for the set of endpoints in this network. The CIDR ranges for endpoints from different networks must not overlap.",
                "type": "string",
                "format": "string"
              }
            }
          },
          {
            "required": [
              "fromRegistry"
            ],
            "properties": {
              "fromRegistry": {
                "description": "Add all endpoints from the specified registry into this network. The names of the registries should correspond to the kubeconfig file name inside the secret that was used to configure the registry (Kubernetes multicluster) or supplied by MCP server.",
                "type": "string",
                "format": "string"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.Network.IstioNetworkGateway": {
        "description": "The gateway associated with this network. Traffic from remote networks will arrive at the specified gateway:port. All incoming traffic must use mTLS.",
        "type": "object",
        "oneOf": [
          {
            "required": [
              "registryServiceName"
            ],
            "properties": {
              "port": {
                "description": "The port associated with the gateway.",
                "type": "integer"
              },
              "locality": {
                "description": "The locality associated with an explicitly specified gateway (i.e. ip)",
                "type": "string",
                "format": "string"
              },
              "registryServiceName": {
                "description": "A fully qualified domain name of the gateway service. Pilot will lookup the service from the service registries in the network and obtain the endpoint IPs of the gateway from the service registry. Note that while the service name is a fully qualified domain name, it need not be resolvable outside the orchestration platform for the registry. e.g., this could be istio-ingressgateway.istio-system.svc.cluster.local.",
                "type": "string",
                "format": "string"
              }
            }
          },
          {
            "required": [
              "address"
            ],
            "properties": {
              "port": {
                "description": "The port associated with the gateway.",
                "type": "integer"
              },
              "address": {
                "description": "IP address or externally resolvable DNS address associated with the gateway.",
                "type": "string",
                "format": "string"
              },
              "locality": {
                "description": "The locality associated with an explicitly specified gateway (i.e. ip)",
                "type": "string",
                "format": "string"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.MeshNetworks": {
        "description": "MeshNetworks (config map) provides information about the set of networks inside a mesh and how to route to endpoints in each network. For example",
        "type": "object",
        "properties": {
          "networks": {
            "description": "The set of networks inside this mesh. Each network should have a unique name and information about how to infer the endpoints in the network as well as the gateways associated with the network.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Network"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.IstioOperatorSpec": {
        "description": "IstioOperatorSpec defines the desired installed state of Istio components. The spec is a used to define a customization of the default profile values that are supplied with each Istio release. Because the spec is a customization API, specifying an empty IstioOperatorSpec results in a default Istio component values.",
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.IstioOperatorSpec.Status"
          },
          "values": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeMapStringInterface"
          },
          "hub": {
            "description": "Root for docker image paths e.g. docker.io/istio",
            "type": "string",
            "format": "string"
          },
          "tag": {
            "description": "Version tag for docker images e.g. 1.0.6",
            "type": "string",
            "format": "string"
          },
          "profile": {
            "description": "Path or name for the profile e.g. - minimal (looks in profiles dir for a file called minimal.yaml) - /tmp/istio/install/values/custom/custom-install.yaml (local file path) default profile is used if this field is unset.",
            "type": "string",
            "format": "string"
          },
          "installPackagePath": {
            "description": "Path for the install package. e.g. - /tmp/istio-installer/nightly (local file path)",
            "type": "string",
            "format": "string"
          },
          "resourceSuffix": {
            "description": "Resource suffix is appended to all resources installed by each component. Used in upgrade scenarios where two Istio control planes must exist in the same namespace.",
            "type": "string",
            "format": "string"
          },
          "meshConfig": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig"
          },
          "components": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.IstioComponentSetSpec"
          },
          "unvalidatedValues": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.TypeMapStringInterface"
          },
          "componentStatus": {
            "description": "Individual status of each component controlled by the operator. The map key is the name of the component.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.IstioOperatorSpec.VersionStatus"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.IstioOperatorSpec.Status": {
        "description": "Status describes the current state of a component.",
        "type": "string",
        "enum": [
          "NONE",
          "UPDATING",
          "RECONCILING",
          "HEALTHY",
          "ERROR"
        ]
      },
      "istio.mesh.v1alpha1.IstioOperatorSpec.VersionStatus": {
        "description": "VersionStatus is the status and version of a component.",
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.IstioOperatorSpec.Status"
          },
          "version": {
            "type": "string",
            "format": "string"
          },
          "statusString": {
            "type": "string",
            "format": "string"
          },
          "error": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.AuthenticationPolicy": {
        "description": "AuthenticationPolicy defines authentication policy. It can be set for different scopes (mesh, service …), and the most narrow scope with non-INHERIT value will be used. Mesh policy cannot be INHERIT.",
        "type": "string",
        "enum": [
          "NONE",
          "MUTUAL_TLS",
          "INHERIT"
        ]
      },
      "istio.mesh.v1alpha1.Tracing": {
        "description": "Tracing defines configuration for the tracing performed by Envoy instances.",
        "type": "object",
        "oneOf": [
          {
            "required": [
              "zipkin"
            ],
            "properties": {
              "zipkin": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin"
              }
            }
          },
          {
            "required": [
              "lightstep"
            ],
            "properties": {
              "lightstep": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep"
              }
            }
          },
          {
            "required": [
              "datadog"
            ],
            "properties": {
              "datadog": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog"
              }
            }
          },
          {
            "required": [
              "stackdriver"
            ],
            "properties": {
              "stackdriver": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.Tracing.Zipkin": {
        "description": "Zipkin defines configuration for a Zipkin tracer.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of the Zipkin service (e.g. _zipkin:9411_).",
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.Lightstep": {
        "description": "Defines configuration for a LightStep tracer.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of the LightStep Satellite pool.",
            "type": "string",
            "format": "string"
          },
          "accessToken": {
            "description": "The LightStep access token.",
            "type": "string",
            "format": "string"
          },
          "secure": {
            "description": "True if a secure connection should be used when communicating with the pool.",
            "type": "boolean"
          },
          "cacertPath": {
            "description": "Path to the trusted cacert used to authenticate the pool.",
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.Datadog": {
        "description": "Datadog defines configuration for a Datadog tracer.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of the Datadog Agent.",
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.Stackdriver": {
        "description": "Stackdriver defines configuration for a Stackdriver tracer. See [Opencensus trace config](https://github.com/census-instrumentation/opencensus-proto/blob/master/src/opencensus/proto/trace/v1/trace_config.proto) for details.",
        "type": "object",
        "properties": {
          "debug": {
            "description": "debug enables trace output to stdout. $hide_from_docs",
            "type": "boolean"
          },
          "maxNumberOfAttributes": {
            "description": "The global default max number of attributes per span. default is 200. $hide_from_docs",
            "type": "integer",
            "nullable": true
          },
          "maxNumberOfAnnotations": {
            "description": "The global default max number of annotation events per span. default is 200. $hide_from_docs",
            "type": "integer",
            "nullable": true
          },
          "maxNumberOfMessageEvents": {
            "description": "The global default max number of message events per span. default is 200. $hide_from_docs",
            "type": "integer",
            "nullable": true
          }
        }
      },
      "istio.mesh.v1alpha1.SDS": {
        "description": "SDS defines secret discovery service(SDS) configuration to be used by the proxy. For workload, its values are set in sidecar injector(passed as arguments to istio-proxy container). For pilot/mixer, it's passed as arguments to istio-proxy container in pilot/mixer deployment yaml files directly.",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "True if SDS is enabled.",
            "type": "boolean"
          },
          "k8sSaJwtPath": {
            "description": "Path of k8s service account JWT path.",
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode": {
        "description": "The mode used to redirect inbound traffic to Envoy. This setting has no effect on outbound traffic: iptables REDIRECT is always used for outbound connections.",
        "type": "string",
        "enum": [
          "REDIRECT",
          "TPROXY"
        ]
      },
      "istio.mesh.v1alpha1.RemoteService": {
        "type": "object",
        "properties": {
          "tcpKeepalive": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive"
          },
          "address": {
            "description": "Address of a remove service used for various purposes (access log receiver, metrics receiver, etc.). Can be IP address or a fully qualified DNS name.",
            "type": "string",
            "format": "string"
          },
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TLSSettings"
          }
        }
      },
      "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive": {
        "description": "If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.",
        "type": "object",
        "properties": {
          "time": {
            "description": "The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)",
            "type": "string"
          },
          "probes": {
            "description": "Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)",
            "type": "integer"
          },
          "interval": {
            "description": "The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)",
            "type": "string"
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting": {
        "description": "Locality based load balancing distribution or failover settings.",
        "type": "object",
        "properties": {
          "distribute": {
            "description": "Optional: only one of distribute or failover can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute"
            }
          },
          "failover": {
            "description": "Optional: only failover or distribute can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover"
            }
          }
        }
      },
      "istio.networking.v1alpha3.TLSSettings": {
        "description": "Use the tls_settings to specify the tls mode to use. If the remote service uses Istio mutual TLS and shares the root CA with Pilot, specify the TLS mode as `ISTIO_MUTUAL`.",
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TLSSettings.TLSmode"
          },
          "clientCertificate": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string",
            "format": "string"
          },
          "privateKey": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string",
            "format": "string"
          },
          "caCertificates": {
            "description": "OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string",
            "format": "string"
          },
          "subjectAltNames": {
            "description": "A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          },
          "sni": {
            "description": "SNI string to present to the server during TLS handshake.",
            "type": "string",
            "format": "string"
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.HorizontalPodAutoscalerSpec": {
        "description": "k8s HorizontalPodAutoscaler settings. https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/",
        "type": "object",
        "properties": {
          "scaleTargetRef": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.CrossVersionObjectReference"
          },
          "minReplicas": {
            "description": "minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod. minReplicas is allowed to be 0 if the alpha feature gate HPAScaleToZero is enabled and at least one Object or External metric is configured. Scaling is active as long as at least one metric value is available. +optional",
            "type": "integer",
            "format": "int32"
          },
          "maxReplicas": {
            "description": "maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.",
            "type": "integer",
            "format": "int32"
          },
          "metrics": {
            "description": "metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used). The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods. Ergo, metrics used must decrease as the pod count is increased, and vice-versa. See the individual metric source types for more information about how each type of metric must respond. +optional",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.MetricSpec"
            }
          }
        }
      },
      "k8s.io.apimachinery.pkg.api.resource.Quantity": {
        "description": "targetAverageValue is the target value of the average of the resource metric across all relevant pods, as a raw value (instead of as a percentage of the request), similar to the \"pods\" metric source type. +optional",
        "type": "object",
        "properties": {
          "string": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector": {
        "description": "selector is the string-encoded form of a standard kubernetes label selector for the given metric When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping When unset, just the metricName will be used to gather metrics. +optional",
        "type": "object",
        "properties": {
          "matchLabels": {
            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed. +optional",
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "format": "string"
            }
          },
          "matchExpressions": {
            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed. +optional",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
            }
          }
        }
      },
      "k8s.io.apimachinery.pkg.util.intstr.IntOrString": {
        "type": "object",
        "properties": {
          "type": {
            "type": "integer",
            "format": "int64"
          },
          "intVal": {
            "type": "integer",
            "format": "int32"
          },
          "strVal": {
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.",
            "type": "string",
            "format": "string"
          },
          "to": {
            "description": "Map of upstream localities to traffic distribution weights. The sum of all weights should be == 100. Any locality not assigned a weight will receive no traffic.",
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            }
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Originating region.",
            "type": "string",
            "format": "string"
          },
          "to": {
            "description": "Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.",
            "type": "string",
            "format": "string"
          }
        }
      },
      "istio.networking.v1alpha3.TLSSettings.TLSmode": {
        "description": "Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.",
        "type": "string",
        "enum": [
          "DISABLE",
          "SIMPLE",
          "MUTUAL",
          "ISTIO_MUTUAL"
        ]
      },
      "k8s.io.api.autoscaling.v2beta1.CrossVersionObjectReference": {
        "description": "scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics should be collected, as well as to actually change the replica count.",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names",
            "type": "string",
            "format": "string"
          },
          "kind": {
            "description": "Kind of the referent; More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds\"",
            "type": "string",
            "format": "string"
          },
          "apiVersion": {
            "description": "API version of the referent +optional",
            "type": "string",
            "format": "string"
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.MetricSpec": {
        "type": "object",
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.ResourceMetricSource"
          },
          "type": {
            "description": "type is the type of metric source. It should be one of \"Object\", \"Pods\" or \"Resource\", each mapping to a matching field in the object.",
            "type": "string",
            "format": "string"
          },
          "object": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.ObjectMetricSource"
          },
          "pods": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.PodsMetricSource"
          },
          "external": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.ExternalMetricSource"
          }
        }
      },
      "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement": {
        "type": "object",
        "properties": {
          "key": {
            "description": "key is the label key that the selector applies to. +patchMergeKey=key +patchStrategy=merge",
            "type": "string",
            "format": "string"
          },
          "operator": {
            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
            "type": "string",
            "format": "string"
          },
          "values": {
            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch. +optional",
            "type": "array",
            "items": {
              "type": "string",
              "format": "string"
            }
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.ExternalMetricSource": {
        "description": "external refers to a global metric that is not associated with any Kubernetes object. It allows autoscaling based on information coming from components running outside of cluster (for example length of queue in cloud messaging service, or QPS from loadbalancer running outside of cluster). +optional",
        "type": "object",
        "properties": {
          "metricName": {
            "description": "metricName is the name of the metric in question.",
            "type": "string",
            "format": "string"
          },
          "metricSelector": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
          },
          "targetValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          },
          "targetAverageValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.ObjectMetricSource": {
        "description": "object refers to a metric describing a single kubernetes object (for example, hits-per-second on an Ingress object). +optional",
        "type": "object",
        "properties": {
          "metricName": {
            "description": "metricName is the name of the metric in question.",
            "type": "string",
            "format": "string"
          },
          "targetValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          },
          "target": {
            "$ref": "#/components/schemas/k8s.io.api.autoscaling.v2beta1.CrossVersionObjectReference"
          },
          "selector": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
          },
          "averageValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.PodsMetricSource": {
        "description": "pods refers to a metric describing each pod in the current scale target (for example, transactions-processed-per-second). The values will be averaged together before being compared to the target value. +optional",
        "type": "object",
        "properties": {
          "metricName": {
            "description": "metricName is the name of the metric in question",
            "type": "string",
            "format": "string"
          },
          "targetAverageValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          },
          "selector": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
          }
        }
      },
      "k8s.io.api.autoscaling.v2beta1.ResourceMetricSource": {
        "description": "resource refers to a resource metric (such as those specified in requests and limits) known to Kubernetes describing each pod in the current scale target (e.g. CPU or memory). Such metrics are built in to Kubernetes, and have special scaling options on top of those available to normal per-pod metrics using the \"pods\" source. +optional",
        "type": "object",
        "properties": {
          "name": {
            "description": "name is the name of the resource in question.",
            "type": "string",
            "format": "string"
          },
          "targetAverageValue": {
            "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.api.resource.Quantity"
          },
          "targetAverageUtilization": {
            "description": "targetAverageUtilization is the target value of the average of the resource metric across all relevant pods, represented as a percentage of the requested value of the resource for the pods. +optional",
            "type": "integer",
            "format": "int32"
          }
        }
      }
    }
  }
}