// Copyright 2017 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/duration.proto";
import "mesh/v1alpha1/proxy.proto";
import "mesh/v1alpha1/data_source.proto";

// $title: Service Mesh
// $description: Configuration affecting the service mesh as a whole.
// $location: https://istio.io/docs/reference/config/istio.mesh.v1alpha1.html
// $aliases:
// $  - /docs/reference/config/service-mesh.html

package istio.mesh.v1alpha1;

option go_package="istio.io/api/mesh/v1alpha1";

// MeshConfig defines mesh-wide variables shared by all Envoy instances in the
// Istio service mesh.
//
// NOTE: This configuration type should be used for the low-level global
// configuration, such as component addresses and port numbers. It should not
// be used for the features of the mesh that can be scoped by service or by
// namespace. Some of the fields in the mesh config are going to be deprecated
// and replaced with several individual configuration types (for example,
// tracing configuration).
message MeshConfig {
  // Address of the server that will be used by the proxies for policy
  // check calls. By using different names for mixerCheckServer and
  // mixerReportServer, it is possible to have one set of mixer servers handle
  // policy check calls while another set of mixer servers handle telemetry
  // calls.
  //
  // NOTE: Omitting mixerCheckServer while specifying mixerReportServer is
  // equivalent to setting disablePolicyChecks to true.
  string mixer_check_server = 1;

  // Address of the server that will be used by the proxies for policy report
  // calls.
  string mixer_report_server = 2;

  // Disable policy checks by the mixer service. Default
  // is false, i.e. mixer policy check is enabled by default.
  bool disable_policy_checks = 3;

  // Port on which Envoy should listen for incoming connections from
  // other services.
  int32 proxy_listen_port = 4;

  // Port on which Envoy should listen for HTTP PROXY requests if set.
  int32 proxy_http_port = 5;

  // Connection timeout used by Envoy. (MUST BE >=1ms)
  google.protobuf.Duration connect_timeout = 6;

  // Class of ingress resources to be processed by Istio ingress
  // controller.  This corresponds to the value of
  // "kubernetes.io/ingress.class" annotation.
  string ingress_class = 7;

  // Name of the kubernetes service used for the istio ingress controller.
  string ingress_service = 8;

  enum IngressControllerMode {
    // Disables Istio ingress controller.
    OFF = 0;

    // Istio ingress controller will act on ingress resources that do not
    // contain any annotation or whose annotations match the value
    // specified in the ingress_class parameter described earlier. Use this
    // mode if Istio ingress controller will be the default ingress
    // controller for the entire kubernetes cluster.
    DEFAULT = 1;

    // Istio ingress controller will only act on ingress resources whose
    // annotations match the value specified in the ingress_class parameter
    // described earlier. Use this mode if Istio ingress controller will be
    // a secondary ingress controller (e.g., in addition to a
    // cloud-provided ingress controller).
    STRICT = 2;
  }

  // Defines whether to use Istio ingress controller for annotated or all ingress resources.
  IngressControllerMode ingress_controller_mode = 9;

  reserved 10;
  reserved 11;

  // Flag to control generation of trace spans and request IDs.
  // Requires a trace span collector defined in the proxy configuration.
  bool enable_tracing = 12;

  // File address for the proxy access log (e.g. /dev/stdout).
  // Empty value disables access logging.
  string access_log_file = 13;

  // Default proxy config used by the proxy injection mechanism operating in the mesh
  // (e.g. Kubernetes admission controller)
  // In case of Kubernetes, the proxy config is applied once during the injection process,
  // and remain constant for the duration of the pod. The rest of the mesh config can be changed
  // at runtime and config gets distributed dynamically.
  ProxyConfig default_config = 14;

  reserved 15;
  reserved 16;
  reserved 17;
  reserved 18;

  // Enables clide side policy checks.
  bool enable_client_side_policy_check = 19;

  // Unix Domain Socket through which envoy communicates with NodeAgent SDS to get key/cert for mTLS.
  // Use secret-mount files instead of SDS if set to empty.
  string sds_uds_path = 20;
  
  reserved 21;

  // Address of the galley service exposing the Mesh Control Protocol (MCP).
  // TODO: remove
  string galley_address = 22;

  // Multiple service registries can be configured for a single control
  // plane.  For example, lets say there are three kubernetes clusters in
  // two networks with no direct endpoint connectivity across the
  // networks. Clusters us-east-c1 and us-east-c2 are in US-east region and
  // cluster us-west-c1 is in US-west region. Assume that all clusters in
  // US-east region are in the same network, i.e. endpoints in us-east-c1
  // have direct L3 connectivity to endpoints in us-east-c2
  // cluster. Assuming that Pilot running on any of these clusters has
  // access to the mater nodes of each cluster (to talk to the API
  // servers), the following configuration describes a mesh spanning all
  // the clusters and using cluster-local istio-ingressgateway to route
  // traffic to endpoints within the cluster.
  //
  // serviceRegistries:
  // - name: us-east-c1
  //   type: KUBERNETES
  //   credentials:
  //     kubernetesSecret: us-east-c1-secret
  // - name: us-east-c2
  //   type: KUBERNETES
  //   credentials:
  //     kubernetesSecret: us-east-c2-secret
  // - name: us-west-c1
  //   type: KUBERNETES
  //   credentials:
  //     kubernetesSecret: us-west-c1-secret
  // configStores: #all configuration from us-east-c1
  // - name: us-east-c1
  //   type: KUBERNETES
  //   credentials:
  //     kubernetesSecret: us-east-c1-secret
  // networks:
  // - name: us-east # some arbitrary name to group endpoints
  //   registries:
  //   - us-east-c1
  //   - us-east-c2
  //   gateways:
  //   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
  //     port: 15443
  // - name: us-west
  //   registries:
  //   - us-west-c1
  //   gateways:
  //   - registryServiceName: istio-ingressgateway.istio-system.svc.cluster.local
  //     port: 15443
  //
  // service_registries describe the registries from which Istio should
  // construct the composite service registry for the service mesh. If
  // omitted, Pilot will try to connect to the ambient service registry
  // (when running on kubernetes).
  repeated DataSource service_registries = 23;

  // One or more configuration stores that contain Istio configuration data
  // such as networking rules, auth/RBAC policies, etc.  If omitted, Pilot
  // will try to connect to the ambient service registry (when running on
  // kubernetes).
  repeated DataSource config_stores = 24;

  // One or more L3 networks where the endpoints from various service
  // registries are present. This is used to determine routing across
  // endpoints in different L3 networks.
  repeated Network networks = 25;
}

// Network provides information about the endpoints in a routable L3
// network. A single routable L3 network can have one or more service
// registries. When Pilot ingests service registry information from various
// registries, it maps the endpoints to the networks defined here based on
// the CIDR range that matches the endpoint IP. Note that the network has no
// relation to the locality of the endpoint. The endpoint locality will be
// obtained from the service registry.
message Network {
  // A unique name assigned to the network.
  string name = 1;

  // One or more service registries that are in this network. Endpoints
  // from these registries will be directly reachable to one another.
  // The names of the registries should correspond to the data sources.
  repeated string registries = 2;

  // The gateway associated with this network. Traffic from remote networks
  // will arrive at the specified gateway:port. All incoming traffic must
  // use mTLS.
  message IstioNetworkGateway {
    oneof gw {
      // A fully qualified domain name of the gateway service.  Pilot will
      // lookup the service from the service registries in the network and
      // obtain the endpoint IPs of the gateway from the service
      // registry. Note that while the service name is a fully qualified
      // domain name, it need not be resolvable outside the orchestration
      // platform for the registry. e.g., this could be
      // istio-ingressgateway.istio-system.svc.cluster.local.
      string registry_service_name = 1;

      // IP associated with the gateway.
      string ip = 2;
    }

    // The port associated with the gateway.
    uint32 port = 3;

    // The locality associated with an explicitly specified gateway (i.e. ip)
    string locality = 4;
  }

  repeated IstioNetworkGateway gateways = 3;
}
