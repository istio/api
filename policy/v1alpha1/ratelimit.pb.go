// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: policy/v1alpha1/ratelimit.proto

package v1alpha1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	v1beta1 "istio.io/api/type/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// $schema: istio.policy.v1alpha1.RateLimit
// $title: Rate limiting
// $description: Rate limiting configuration
// $location: https://istio.io/docs/reference/config/policy/ratelimit.html
// $aliases: [/docs/reference/config/policy/v1alpha1/ratelimit]
//
// <!-- crd generation tags
// +cue-gen:Policy:groupName:policy.istio.io
// +cue-gen:Policy:version:v1alpha1
// +cue-gen:Policy:storageVersion
// +cue-gen:Policy:annotations:helm.sh/resource-policy=keep
// +cue-gen:Policy:labels:app=istio-pilot,chart=istio,istio=policy,heritage=Tiller,release=istio
// +cue-gen:Policy:subresource:status
// +cue-gen:Policy:scope:Namespaced
// +cue-gen:Policy:resource:categories=istio-io,policy-istio-io,shortNames=policy,plural=telemetries
// +cue-gen:Policy:preserveUnknownFields:false
// +cue-gen:Policy:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
// representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
// Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=policy.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type RateLimit struct {
	// Types that are valid to be assigned to Binding:
	//	*RateLimit_Workload
	//	*RateLimit_Route
	Binding isRateLimit_Binding `protobuf_oneof:"binding"`
	// Oiotonal. Specifies a set of descriptors that are evaluated against the
	// rate limit policy.  The rate limit applies if any of the generated
	// descriptors trigger a limit.
	Descriptors []*RateLimitDescriptor `protobuf:"bytes,3,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	// Types that are valid to be assigned to Policy:
	//	*RateLimit_Global
	//	*RateLimit_Local
	Policy               isRateLimit_Policy `protobuf_oneof:"policy"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RateLimit) Reset()         { *m = RateLimit{} }
func (m *RateLimit) String() string { return proto.CompactTextString(m) }
func (*RateLimit) ProtoMessage()    {}
func (*RateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{0}
}
func (m *RateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimit.Merge(m, src)
}
func (m *RateLimit) XXX_Size() int {
	return m.Size()
}
func (m *RateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimit proto.InternalMessageInfo

type isRateLimit_Binding interface {
	isRateLimit_Binding()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isRateLimit_Policy interface {
	isRateLimit_Policy()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimit_Workload struct {
	Workload *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=workload,proto3,oneof" json:"workload,omitempty"`
}
type RateLimit_Route struct {
	Route *RouteSelector `protobuf:"bytes,2,opt,name=route,proto3,oneof" json:"route,omitempty"`
}
type RateLimit_Global struct {
	Global *ProviderRef `protobuf:"bytes,4,opt,name=global,proto3,oneof" json:"global,omitempty"`
}
type RateLimit_Local struct {
	Local *LocalRateLimit `protobuf:"bytes,5,opt,name=local,proto3,oneof" json:"local,omitempty"`
}

func (*RateLimit_Workload) isRateLimit_Binding() {}
func (*RateLimit_Route) isRateLimit_Binding()    {}
func (*RateLimit_Global) isRateLimit_Policy()    {}
func (*RateLimit_Local) isRateLimit_Policy()     {}

func (m *RateLimit) GetBinding() isRateLimit_Binding {
	if m != nil {
		return m.Binding
	}
	return nil
}
func (m *RateLimit) GetPolicy() isRateLimit_Policy {
	if m != nil {
		return m.Policy
	}
	return nil
}

func (m *RateLimit) GetWorkload() *v1beta1.WorkloadSelector {
	if x, ok := m.GetBinding().(*RateLimit_Workload); ok {
		return x.Workload
	}
	return nil
}

func (m *RateLimit) GetRoute() *RouteSelector {
	if x, ok := m.GetBinding().(*RateLimit_Route); ok {
		return x.Route
	}
	return nil
}

func (m *RateLimit) GetDescriptors() []*RateLimitDescriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

func (m *RateLimit) GetGlobal() *ProviderRef {
	if x, ok := m.GetPolicy().(*RateLimit_Global); ok {
		return x.Global
	}
	return nil
}

func (m *RateLimit) GetLocal() *LocalRateLimit {
	if x, ok := m.GetPolicy().(*RateLimit_Local); ok {
		return x.Local
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimit) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimit_Workload)(nil),
		(*RateLimit_Route)(nil),
		(*RateLimit_Global)(nil),
		(*RateLimit_Local)(nil),
	}
}

// Route selector references a client networking resource to overlay the rate
// limit filter application.  This can be a service, a virtual service, or a
// gateway resource. Route name designation is optional.
// If no route name is provided, the rate limit applies to all routes. However,
// the rate limit for a named route takes priority over the rate limit for the
// entire resource.
//
// For example, a selector addressing a Kubernetes service:
// ```yaml
// name: foo
// group: core
// kind: Service
// ```
//
// This selector references an HTTPRoute from a Kubernetes gateway:
// ```yaml
// name: foo
// group: networking.x-k8s.io
// kind: HTTPRoute
// ```
//
// This selector references an individual route from a VirtualService:
// ```yaml
// name: foo
// group: networking.istio.io
// kind: VirtualService
// route: blah
// ```
type RouteSelector struct {
	// Resource name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Resource API group.
	Group string `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	// Resource kind.
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Optional. Individual route rule name within the resource.
	Route                string   `protobuf:"bytes,4,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RouteSelector) Reset()         { *m = RouteSelector{} }
func (m *RouteSelector) String() string { return proto.CompactTextString(m) }
func (*RouteSelector) ProtoMessage()    {}
func (*RouteSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{1}
}
func (m *RouteSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RouteSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RouteSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RouteSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RouteSelector.Merge(m, src)
}
func (m *RouteSelector) XXX_Size() int {
	return m.Size()
}
func (m *RouteSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_RouteSelector.DiscardUnknown(m)
}

var xxx_messageInfo_RouteSelector proto.InternalMessageInfo

func (m *RouteSelector) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RouteSelector) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *RouteSelector) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *RouteSelector) GetRoute() string {
	if m != nil {
		return m.Route
	}
	return ""
}

// RateLimitDescriptor is an ordered sequence of entries used for classification of requests.
//
// The following descriptor produces the sequence `[(path, /), (uid, john)]` for a request to `/`
// with a header `user-id` set to `john`:
// ```yaml
// entries:
// - header:
//     key: path
//     name: :path
// - header:
//     key: uid
//     name: user-id
// ```
//
// The following descriptor produces the client SPIFFE service account URI:
// ```yaml
// entries:
// - expression:
//     key: client-id
//     text: connection.uri_san_peer_certificate
// ```
type RateLimitDescriptor struct {
	Entries              []*RateLimitEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RateLimitDescriptor) Reset()         { *m = RateLimitDescriptor{} }
func (m *RateLimitDescriptor) String() string { return proto.CompactTextString(m) }
func (*RateLimitDescriptor) ProtoMessage()    {}
func (*RateLimitDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{2}
}
func (m *RateLimitDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitDescriptor.Merge(m, src)
}
func (m *RateLimitDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitDescriptor proto.InternalMessageInfo

func (m *RateLimitDescriptor) GetEntries() []*RateLimitEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// RateLimitEntry is a property of the request used for classification of requests.
type RateLimitEntry struct {
	// Types that are valid to be assigned to EntryType:
	//	*RateLimitEntry_Header
	//	*RateLimitEntry_HeaderMatch
	//	*RateLimitEntry_Generic
	//	*RateLimitEntry_Expression_
	EntryType            isRateLimitEntry_EntryType `protobuf_oneof:"entry_type"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *RateLimitEntry) Reset()         { *m = RateLimitEntry{} }
func (m *RateLimitEntry) String() string { return proto.CompactTextString(m) }
func (*RateLimitEntry) ProtoMessage()    {}
func (*RateLimitEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3}
}
func (m *RateLimitEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry.Merge(m, src)
}
func (m *RateLimitEntry) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry proto.InternalMessageInfo

type isRateLimitEntry_EntryType interface {
	isRateLimitEntry_EntryType()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimitEntry_Header struct {
	Header *RateLimitEntry_RequestHeader `protobuf:"bytes,1,opt,name=header,proto3,oneof" json:"header,omitempty"`
}
type RateLimitEntry_HeaderMatch struct {
	HeaderMatch *RateLimitEntry_RequestHeaderMatch `protobuf:"bytes,2,opt,name=header_match,json=headerMatch,proto3,oneof" json:"header_match,omitempty"`
}
type RateLimitEntry_Generic struct {
	Generic *RateLimitEntry_GenericEntry `protobuf:"bytes,3,opt,name=generic,proto3,oneof" json:"generic,omitempty"`
}
type RateLimitEntry_Expression_ struct {
	Expression *RateLimitEntry_Expression `protobuf:"bytes,4,opt,name=expression,proto3,oneof" json:"expression,omitempty"`
}

func (*RateLimitEntry_Header) isRateLimitEntry_EntryType()      {}
func (*RateLimitEntry_HeaderMatch) isRateLimitEntry_EntryType() {}
func (*RateLimitEntry_Generic) isRateLimitEntry_EntryType()     {}
func (*RateLimitEntry_Expression_) isRateLimitEntry_EntryType() {}

func (m *RateLimitEntry) GetEntryType() isRateLimitEntry_EntryType {
	if m != nil {
		return m.EntryType
	}
	return nil
}

func (m *RateLimitEntry) GetHeader() *RateLimitEntry_RequestHeader {
	if x, ok := m.GetEntryType().(*RateLimitEntry_Header); ok {
		return x.Header
	}
	return nil
}

func (m *RateLimitEntry) GetHeaderMatch() *RateLimitEntry_RequestHeaderMatch {
	if x, ok := m.GetEntryType().(*RateLimitEntry_HeaderMatch); ok {
		return x.HeaderMatch
	}
	return nil
}

func (m *RateLimitEntry) GetGeneric() *RateLimitEntry_GenericEntry {
	if x, ok := m.GetEntryType().(*RateLimitEntry_Generic); ok {
		return x.Generic
	}
	return nil
}

func (m *RateLimitEntry) GetExpression() *RateLimitEntry_Expression {
	if x, ok := m.GetEntryType().(*RateLimitEntry_Expression_); ok {
		return x.Expression
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimitEntry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimitEntry_Header)(nil),
		(*RateLimitEntry_HeaderMatch)(nil),
		(*RateLimitEntry_Generic)(nil),
		(*RateLimitEntry_Expression_)(nil),
	}
}

// Entry obtained a request header value.
type RateLimitEntry_RequestHeader struct {
	// Descriptor entry key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Request header name. The value of the header is used as the entry value.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// When true, the descriptor entry is omitted from the descriptor if the header is absent.
	// By default, the entire descriptor is skipped and the rate limit is not applied.
	SkipIfAbsent         bool     `protobuf:"varint,3,opt,name=skip_if_absent,json=skipIfAbsent,proto3" json:"skip_if_absent,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimitEntry_RequestHeader) Reset()         { *m = RateLimitEntry_RequestHeader{} }
func (m *RateLimitEntry_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RateLimitEntry_RequestHeader) ProtoMessage()    {}
func (*RateLimitEntry_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3, 0}
}
func (m *RateLimitEntry_RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry_RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry_RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry_RequestHeader.Merge(m, src)
}
func (m *RateLimitEntry_RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry_RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry_RequestHeader proto.InternalMessageInfo

func (m *RateLimitEntry_RequestHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RateLimitEntry_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RateLimitEntry_RequestHeader) GetSkipIfAbsent() bool {
	if m != nil {
		return m.SkipIfAbsent
	}
	return false
}

// Entry obtained by testing a request header value.
type RateLimitEntry_RequestHeaderMatch struct {
	// Descriptor entry value. The key is always `header_match`.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// If set to true, the entry is appended when the request does not match.
	// By default, the entry is appended if and only if the request matches.
	ExpectFalse bool `protobuf:"varint,2,opt,name=expect_false,json=expectFalse,proto3" json:"expect_false,omitempty"`
	// The request matches when it matches all conditions.
	Conditions           []*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition `protobuf:"bytes,3,rep,name=conditions,proto3" json:"conditions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                  `json:"-"`
	XXX_unrecognized     []byte                                                    `json:"-"`
	XXX_sizecache        int32                                                     `json:"-"`
}

func (m *RateLimitEntry_RequestHeaderMatch) Reset()         { *m = RateLimitEntry_RequestHeaderMatch{} }
func (m *RateLimitEntry_RequestHeaderMatch) String() string { return proto.CompactTextString(m) }
func (*RateLimitEntry_RequestHeaderMatch) ProtoMessage()    {}
func (*RateLimitEntry_RequestHeaderMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3, 1}
}
func (m *RateLimitEntry_RequestHeaderMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry_RequestHeaderMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry_RequestHeaderMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry_RequestHeaderMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry_RequestHeaderMatch.Merge(m, src)
}
func (m *RateLimitEntry_RequestHeaderMatch) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry_RequestHeaderMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry_RequestHeaderMatch.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry_RequestHeaderMatch proto.InternalMessageInfo

func (m *RateLimitEntry_RequestHeaderMatch) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *RateLimitEntry_RequestHeaderMatch) GetExpectFalse() bool {
	if m != nil {
		return m.ExpectFalse
	}
	return false
}

func (m *RateLimitEntry_RequestHeaderMatch) GetConditions() []*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// Header match condition evaluates a request header against one of the patterns.
// Use `:authority` header to refer to HTTP/1.1 Host header and `:method`
// header to refer to HTTP method.
type RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition struct {
	// Header name.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Condition:
	//	*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact
	//	*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix
	//	*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains
	//	*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present
	Condition            isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition `protobuf_oneof:"condition"`
	XXX_NoUnkeyedLiteral struct{}                                                           `json:"-"`
	XXX_unrecognized     []byte                                                             `json:"-"`
	XXX_sizecache        int32                                                              `json:"-"`
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) Reset() {
	*m = RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition{}
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) String() string {
	return proto.CompactTextString(m)
}
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) ProtoMessage() {}
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3, 1, 0}
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition.Merge(m, src)
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition proto.InternalMessageInfo

type isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition interface {
	isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof" json:"exact,omitempty"`
}
type RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix struct {
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
}
type RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains struct {
	Contains string `protobuf:"bytes,4,opt,name=contains,proto3,oneof" json:"contains,omitempty"`
}
type RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present struct {
	Present bool `protobuf:"varint,5,opt,name=present,proto3,oneof" json:"present,omitempty"`
}

func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact) isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition() {
}
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix) isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition() {
}
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains) isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition() {
}
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present) isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition() {
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetCondition() isRateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Condition {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetExact() string {
	if x, ok := m.GetCondition().(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetPrefix() string {
	if x, ok := m.GetCondition().(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetContains() string {
	if x, ok := m.GetCondition().(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains); ok {
		return x.Contains
	}
	return ""
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) GetPresent() bool {
	if x, ok := m.GetCondition().(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present); ok {
		return x.Present
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact)(nil),
		(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix)(nil),
		(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains)(nil),
		(*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present)(nil),
	}
}

// Generic entry.
type RateLimitEntry_GenericEntry struct {
	// Descriptor entry key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Descriptor entry value.
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimitEntry_GenericEntry) Reset()         { *m = RateLimitEntry_GenericEntry{} }
func (m *RateLimitEntry_GenericEntry) String() string { return proto.CompactTextString(m) }
func (*RateLimitEntry_GenericEntry) ProtoMessage()    {}
func (*RateLimitEntry_GenericEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3, 2}
}
func (m *RateLimitEntry_GenericEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry_GenericEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry_GenericEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry_GenericEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry_GenericEntry.Merge(m, src)
}
func (m *RateLimitEntry_GenericEntry) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry_GenericEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry_GenericEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry_GenericEntry proto.InternalMessageInfo

func (m *RateLimitEntry_GenericEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RateLimitEntry_GenericEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Generic CEL expression.
// For example, the expression `filter_state['wasm.downstream_peer'].labels['app'].value`
// produces the `app` label value for the downstream peer.
type RateLimitEntry_Expression struct {
	// Descriptor entry key.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// If set to true, the descriptor entry is ommitted if the expression evaluates to an error.
	// By default, the rate limit is not applied for this descriptor when an expression produces an error.
	SkipIfError bool `protobuf:"varint,2,opt,name=skip_if_error,json=skipIfError,proto3" json:"skip_if_error,omitempty"`
	// Descriptor expression.
	Text                 string   `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RateLimitEntry_Expression) Reset()         { *m = RateLimitEntry_Expression{} }
func (m *RateLimitEntry_Expression) String() string { return proto.CompactTextString(m) }
func (*RateLimitEntry_Expression) ProtoMessage()    {}
func (*RateLimitEntry_Expression) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{3, 3}
}
func (m *RateLimitEntry_Expression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RateLimitEntry_Expression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RateLimitEntry_Expression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RateLimitEntry_Expression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RateLimitEntry_Expression.Merge(m, src)
}
func (m *RateLimitEntry_Expression) XXX_Size() int {
	return m.Size()
}
func (m *RateLimitEntry_Expression) XXX_DiscardUnknown() {
	xxx_messageInfo_RateLimitEntry_Expression.DiscardUnknown(m)
}

var xxx_messageInfo_RateLimitEntry_Expression proto.InternalMessageInfo

func (m *RateLimitEntry_Expression) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RateLimitEntry_Expression) GetSkipIfError() bool {
	if m != nil {
		return m.SkipIfError
	}
	return false
}

func (m *RateLimitEntry_Expression) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// References a rate limit extension provider from the mesh configuration.
type ProviderRef struct {
	// Provider name.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProviderRef) Reset()         { *m = ProviderRef{} }
func (m *ProviderRef) String() string { return proto.CompactTextString(m) }
func (*ProviderRef) ProtoMessage()    {}
func (*ProviderRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{4}
}
func (m *ProviderRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderRef.Merge(m, src)
}
func (m *ProviderRef) XXX_Size() int {
	return m.Size()
}
func (m *ProviderRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderRef.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderRef proto.InternalMessageInfo

func (m *ProviderRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Local rate limiting policy using a token bucket algorithm.
type LocalRateLimit struct {
	// The token bucket configuration to use for rate limiting requests that are
	// processed by this filter. Each request processed by the filter consumes a
	// single token. If the token is available, the request will be allowed. If
	// no tokens are available, the proxy responds with 429.
	TokenBucket *LocalRateLimit_TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
	// Descriptor overrides. The rate limit descriptor list to use in the local
	// rate limit to override on. The rate limit descriptor is selected by the
	// first full match from the request descriptors. Each descriptor token bucket
	// fill interval must be a multiple of the global token bucket's interval.
	// The descriptors match verbatim. If a descriptor match is detected, then the
	// descriptor bucket is used to decide whether to rate limit the request instead of
	// the global token bucket.
	Descriptors          []*LocalRateLimit_LocalRateLimitDescriptor `protobuf:"bytes,2,rep,name=descriptors,proto3" json:"descriptors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *LocalRateLimit) Reset()         { *m = LocalRateLimit{} }
func (m *LocalRateLimit) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit) ProtoMessage()    {}
func (*LocalRateLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{5}
}
func (m *LocalRateLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit.Merge(m, src)
}
func (m *LocalRateLimit) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit proto.InternalMessageInfo

func (m *LocalRateLimit) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if m != nil {
		return m.TokenBucket
	}
	return nil
}

func (m *LocalRateLimit) GetDescriptors() []*LocalRateLimit_LocalRateLimitDescriptor {
	if m != nil {
		return m.Descriptors
	}
	return nil
}

// Configures a token bucket.
type LocalRateLimit_TokenBucket struct {
	// The maximum tokens that the bucket can hold. This is also the number of tokens that the bucket
	// initially contains.
	MaxTokens uint32 `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
	// The number of tokens added to the bucket during each fill interval. If not specified, defaults
	// to a single token.
	TokensPerFill *types.UInt32Value `protobuf:"bytes,2,opt,name=tokens_per_fill,json=tokensPerFill,proto3" json:"tokens_per_fill,omitempty"`
	// The fill interval that tokens are added to the bucket. During each fill interval
	// `tokens_per_fill` are added to the bucket. The bucket will never contain more than
	// `max_tokens` tokens. The interval must be >=50ms.
	FillInterval         *types.Duration `protobuf:"bytes,3,opt,name=fill_interval,json=fillInterval,proto3" json:"fill_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *LocalRateLimit_TokenBucket) Reset()         { *m = LocalRateLimit_TokenBucket{} }
func (m *LocalRateLimit_TokenBucket) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit_TokenBucket) ProtoMessage()    {}
func (*LocalRateLimit_TokenBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{5, 0}
}
func (m *LocalRateLimit_TokenBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit_TokenBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit_TokenBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit_TokenBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit_TokenBucket.Merge(m, src)
}
func (m *LocalRateLimit_TokenBucket) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit_TokenBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit_TokenBucket.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit_TokenBucket proto.InternalMessageInfo

func (m *LocalRateLimit_TokenBucket) GetMaxTokens() uint32 {
	if m != nil {
		return m.MaxTokens
	}
	return 0
}

func (m *LocalRateLimit_TokenBucket) GetTokensPerFill() *types.UInt32Value {
	if m != nil {
		return m.TokensPerFill
	}
	return nil
}

func (m *LocalRateLimit_TokenBucket) GetFillInterval() *types.Duration {
	if m != nil {
		return m.FillInterval
	}
	return nil
}

// Per-descriptor local rate limit override.
type LocalRateLimit_LocalRateLimitDescriptor struct {
	// Override token bucket. The fill interval must be a multiple of the global
	// token bucket.
	TokenBucket *LocalRateLimit_TokenBucket `protobuf:"bytes,1,opt,name=token_bucket,json=tokenBucket,proto3" json:"token_bucket,omitempty"`
	// Descriptor entries to be matched exactly.
	Entries              []*LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                   `json:"-"`
	XXX_unrecognized     []byte                                                     `json:"-"`
	XXX_sizecache        int32                                                      `json:"-"`
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) Reset() {
	*m = LocalRateLimit_LocalRateLimitDescriptor{}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) String() string { return proto.CompactTextString(m) }
func (*LocalRateLimit_LocalRateLimitDescriptor) ProtoMessage()    {}
func (*LocalRateLimit_LocalRateLimitDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{5, 1}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor.Merge(m, src)
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor proto.InternalMessageInfo

func (m *LocalRateLimit_LocalRateLimitDescriptor) GetTokenBucket() *LocalRateLimit_TokenBucket {
	if m != nil {
		return m.TokenBucket
	}
	return nil
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) GetEntries() []*LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// A descriptor entry.
type LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) Reset() {
	*m = LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry{}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) String() string {
	return proto.CompactTextString(m)
}
func (*LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) ProtoMessage() {}
func (*LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b829187ad6375d0, []int{5, 1, 0}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry.Merge(m, src)
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) XXX_Size() int {
	return m.Size()
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry proto.InternalMessageInfo

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*RateLimit)(nil), "istio.policy.v1alpha1.RateLimit")
	proto.RegisterType((*RouteSelector)(nil), "istio.policy.v1alpha1.RouteSelector")
	proto.RegisterType((*RateLimitDescriptor)(nil), "istio.policy.v1alpha1.RateLimitDescriptor")
	proto.RegisterType((*RateLimitEntry)(nil), "istio.policy.v1alpha1.RateLimitEntry")
	proto.RegisterType((*RateLimitEntry_RequestHeader)(nil), "istio.policy.v1alpha1.RateLimitEntry.RequestHeader")
	proto.RegisterType((*RateLimitEntry_RequestHeaderMatch)(nil), "istio.policy.v1alpha1.RateLimitEntry.RequestHeaderMatch")
	proto.RegisterType((*RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition)(nil), "istio.policy.v1alpha1.RateLimitEntry.RequestHeaderMatch.HeaderMatchCondition")
	proto.RegisterType((*RateLimitEntry_GenericEntry)(nil), "istio.policy.v1alpha1.RateLimitEntry.GenericEntry")
	proto.RegisterType((*RateLimitEntry_Expression)(nil), "istio.policy.v1alpha1.RateLimitEntry.Expression")
	proto.RegisterType((*ProviderRef)(nil), "istio.policy.v1alpha1.ProviderRef")
	proto.RegisterType((*LocalRateLimit)(nil), "istio.policy.v1alpha1.LocalRateLimit")
	proto.RegisterType((*LocalRateLimit_TokenBucket)(nil), "istio.policy.v1alpha1.LocalRateLimit.TokenBucket")
	proto.RegisterType((*LocalRateLimit_LocalRateLimitDescriptor)(nil), "istio.policy.v1alpha1.LocalRateLimit.LocalRateLimitDescriptor")
	proto.RegisterType((*LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry)(nil), "istio.policy.v1alpha1.LocalRateLimit.LocalRateLimitDescriptor.DescriptorEntry")
}

func init() { proto.RegisterFile("policy/v1alpha1/ratelimit.proto", fileDescriptor_7b829187ad6375d0) }

var fileDescriptor_7b829187ad6375d0 = []byte{
	// 946 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x8e, 0xdb, 0x44,
	0x14, 0x8e, 0xb3, 0x9b, 0xbf, 0xe3, 0x64, 0x8b, 0x86, 0x82, 0x8c, 0x59, 0x96, 0x36, 0x6a, 0xa5,
	0xaa, 0x17, 0x0e, 0xc9, 0x4a, 0x08, 0xa4, 0x52, 0x44, 0xd8, 0x2d, 0x59, 0x69, 0xb7, 0xaa, 0x86,
	0xb2, 0x48, 0x20, 0x64, 0x26, 0xce, 0x24, 0x19, 0xc5, 0xf1, 0x98, 0xf1, 0x24, 0x4d, 0x1e, 0xa4,
	0x4f, 0xc0, 0x1b, 0xf0, 0x08, 0x5c, 0x71, 0xc9, 0x23, 0xa0, 0xbd, 0xe7, 0x1d, 0xd0, 0xcc, 0xd8,
	0x89, 0xb3, 0x4d, 0x44, 0x54, 0xc4, 0xdd, 0x9c, 0x99, 0xf3, 0x7d, 0x3e, 0xf3, 0x9d, 0x9f, 0x31,
	0x7c, 0x1c, 0xf3, 0x90, 0x05, 0xcb, 0xd6, 0xbc, 0x4d, 0xc2, 0x78, 0x4c, 0xda, 0x2d, 0x41, 0x24,
	0x0d, 0xd9, 0x94, 0x49, 0x2f, 0x16, 0x5c, 0x72, 0xf4, 0x1e, 0x4b, 0x24, 0xe3, 0x9e, 0x71, 0xf3,
	0x32, 0x37, 0xf7, 0x43, 0xb9, 0x8c, 0x69, 0x6b, 0xde, 0xee, 0x53, 0x49, 0xda, 0xad, 0x84, 0x86,
	0x34, 0x90, 0x5c, 0x18, 0x8c, 0x7b, 0x32, 0xe2, 0x7c, 0x14, 0xd2, 0x96, 0xb6, 0xfa, 0xb3, 0x61,
	0xeb, 0x95, 0x20, 0x71, 0x4c, 0x45, 0xb2, 0xeb, 0x7c, 0x30, 0x13, 0x44, 0x32, 0x1e, 0x99, 0xf3,
	0xe6, 0xdf, 0x45, 0xa8, 0x61, 0x22, 0xe9, 0xa5, 0x8a, 0x03, 0x75, 0xa1, 0xfa, 0x8a, 0x8b, 0x49,
	0xc8, 0xc9, 0xc0, 0xb1, 0xee, 0x59, 0x8f, 0xec, 0xce, 0x03, 0xcf, 0x04, 0xa5, 0x62, 0xf0, 0xd2,
	0x18, 0xbc, 0xef, 0x53, 0x9f, 0x6f, 0xd3, 0x58, 0x7a, 0x05, 0xbc, 0xc2, 0xa1, 0x27, 0x50, 0x12,
	0x7c, 0x26, 0xa9, 0x53, 0xdc, 0x20, 0xb8, 0x75, 0x2b, 0x0f, 0x2b, 0x9f, 0x1c, 0x81, 0x01, 0xa1,
	0x4b, 0xb0, 0x07, 0x34, 0x09, 0x04, 0x8b, 0x25, 0x17, 0x89, 0x73, 0x70, 0xef, 0xe0, 0x91, 0xdd,
	0x79, 0xbc, 0x8b, 0x23, 0x0b, 0xfc, 0x6c, 0x05, 0xc1, 0x79, 0x38, 0x7a, 0x02, 0xe5, 0x51, 0xc8,
	0xfb, 0x24, 0x74, 0x0e, 0x75, 0x30, 0xcd, 0x1d, 0x44, 0x2f, 0x04, 0x9f, 0xb3, 0x01, 0x15, 0x98,
	0x0e, 0x7b, 0x16, 0x4e, 0x31, 0xe8, 0x0b, 0x28, 0x85, 0x3c, 0x20, 0xa1, 0x53, 0xd2, 0xe0, 0x87,
	0x3b, 0xc0, 0x97, 0xca, 0x67, 0x15, 0x4a, 0xcf, 0xc2, 0x06, 0xd5, 0xad, 0x41, 0xa5, 0xcf, 0xa2,
	0x01, 0x8b, 0x46, 0xdd, 0x2a, 0x94, 0x0d, 0xaa, 0x19, 0x40, 0x63, 0xe3, 0xe6, 0x08, 0xc1, 0x61,
	0x44, 0xa6, 0x54, 0xcb, 0x5d, 0xc3, 0x7a, 0x8d, 0xee, 0x42, 0x69, 0x24, 0xf8, 0x2c, 0xd6, 0x12,
	0xd6, 0xb0, 0x31, 0x94, 0xe7, 0x84, 0x45, 0x03, 0xe7, 0xc0, 0x78, 0xaa, 0xb5, 0xf2, 0x34, 0x62,
	0x1f, 0x1a, 0x4f, 0x6d, 0x34, 0xaf, 0xe1, 0xdd, 0x2d, 0xd2, 0xa0, 0x2f, 0xa1, 0x42, 0x23, 0x29,
	0x18, 0x4d, 0x1c, 0x4b, 0xeb, 0xfa, 0xf0, 0xdf, 0x74, 0x3d, 0x8f, 0xa4, 0x58, 0xe2, 0x0c, 0xd5,
	0xfc, 0xbd, 0x02, 0x47, 0x9b, 0x67, 0xe8, 0x0a, 0xca, 0x63, 0x4a, 0x06, 0x54, 0xa4, 0xf5, 0x72,
	0xba, 0x17, 0xa5, 0x87, 0xe9, 0x2f, 0x33, 0x9a, 0xc8, 0x9e, 0x86, 0xf6, 0x0a, 0x38, 0x25, 0x41,
	0x3f, 0x41, 0xdd, 0xac, 0xfc, 0x29, 0x91, 0xc1, 0x38, 0xad, 0xa1, 0xcf, 0xde, 0x82, 0xf4, 0x4a,
	0xe1, 0x7b, 0x05, 0x6c, 0x8f, 0xd7, 0x26, 0x7a, 0x0e, 0x95, 0x11, 0x8d, 0xa8, 0x60, 0x81, 0x56,
	0xd1, 0xee, 0x74, 0xf6, 0x63, 0xfe, 0xc6, 0x80, 0xb4, 0xd1, 0x2b, 0xe0, 0x8c, 0x04, 0x61, 0x00,
	0xba, 0x88, 0x05, 0x4d, 0x12, 0xc6, 0xa3, 0xb4, 0xc6, 0x3e, 0xd9, 0x8f, 0xf2, 0x7c, 0x85, 0xeb,
	0x15, 0x70, 0x8e, 0xc5, 0xfd, 0x11, 0x1a, 0x1b, 0x17, 0x41, 0xef, 0xc0, 0xc1, 0x84, 0x2e, 0xd3,
	0x02, 0x51, 0xcb, 0x55, 0xcd, 0x14, 0x73, 0x35, 0xf3, 0x00, 0x8e, 0x92, 0x09, 0x8b, 0x7d, 0x36,
	0xf4, 0x49, 0x3f, 0xa1, 0x91, 0xd4, 0x37, 0xac, 0xe2, 0xba, 0xda, 0xbd, 0x18, 0x7e, 0xa5, 0xf7,
	0xdc, 0x9b, 0x22, 0xa0, 0x37, 0x65, 0x52, 0x65, 0x34, 0x27, 0xe1, 0x2c, 0xab, 0x42, 0x63, 0xa0,
	0xfb, 0x50, 0xa7, 0x8b, 0x98, 0x06, 0xd2, 0x1f, 0x92, 0x30, 0x31, 0x9f, 0xab, 0x62, 0xdb, 0xec,
	0x3d, 0x53, 0x5b, 0x68, 0x0a, 0x10, 0xf0, 0x68, 0xc0, 0xd4, 0x44, 0xc9, 0xba, 0xf5, 0xea, 0x6d,
	0xb3, 0xe5, 0xe5, 0xd6, 0x5f, 0x67, 0xac, 0x38, 0xf7, 0x01, 0xf7, 0x57, 0x0b, 0xee, 0x6e, 0x73,
	0xda, 0xda, 0x45, 0xef, 0x43, 0x89, 0x2e, 0x48, 0x20, 0x8d, 0x4c, 0x6a, 0xc4, 0x68, 0x13, 0x39,
	0x50, 0x8e, 0x05, 0x1d, 0xb2, 0x85, 0xe9, 0x24, 0x55, 0x7d, 0xc6, 0x46, 0xc7, 0x50, 0x0d, 0x78,
	0x24, 0x09, 0x8b, 0x12, 0xd3, 0x50, 0x6a, 0xb0, 0x65, 0x3b, 0xc8, 0x85, 0x8a, 0x4a, 0x92, 0x92,
	0x56, 0x0d, 0x84, 0xaa, 0x2a, 0x84, 0x74, 0xa3, 0x6b, 0x43, 0x6d, 0x15, 0xa6, 0xfb, 0x29, 0xd4,
	0xf3, 0x05, 0xb3, 0x25, 0x81, 0x2b, 0xbd, 0x8b, 0x39, 0xbd, 0xdd, 0x6b, 0x80, 0x75, 0x55, 0x6c,
	0x41, 0x35, 0xa1, 0x91, 0xa5, 0x98, 0x0a, 0xc1, 0x45, 0x96, 0x10, 0x93, 0xe1, 0x73, 0xb5, 0xa5,
	0x84, 0x90, 0x74, 0x21, 0xb3, 0x21, 0xa1, 0xd6, 0xdd, 0x3a, 0x80, 0xea, 0xe0, 0xa5, 0xaf, 0x86,
	0x78, 0xf3, 0x3e, 0xd8, 0xb9, 0x71, 0xb7, 0x4d, 0xb9, 0xe6, 0xeb, 0x12, 0x1c, 0x6d, 0x4e, 0x35,
	0xf4, 0x12, 0xea, 0x92, 0x4f, 0x68, 0xe4, 0xf7, 0x67, 0xc1, 0x84, 0xca, 0xb4, 0xdb, 0xdb, 0x7b,
	0x8d, 0x44, 0xef, 0xa5, 0x42, 0x76, 0x35, 0x10, 0xdb, 0x72, 0x6d, 0xa0, 0x9f, 0x37, 0xa7, 0x7d,
	0x51, 0xd7, 0xcf, 0xd3, 0xfd, 0x48, 0x37, 0xcd, 0x1d, 0x2f, 0x80, 0xfb, 0x9b, 0x05, 0x76, 0xee,
	0xf3, 0xe8, 0x23, 0x80, 0x29, 0x59, 0xf8, 0x3a, 0x88, 0x44, 0xdf, 0xa2, 0x81, 0x6b, 0x53, 0xb2,
	0xd0, 0x3e, 0x09, 0x3a, 0x83, 0x3b, 0xe6, 0xc8, 0x8f, 0xa9, 0xf0, 0x87, 0x2c, 0x0c, 0xd3, 0x11,
	0x74, 0xec, 0x99, 0x87, 0xd4, 0xcb, 0x1e, 0x52, 0xef, 0xbb, 0x8b, 0x48, 0x9e, 0x76, 0xae, 0x55,
	0xe6, 0x70, 0xc3, 0x80, 0x5e, 0x50, 0xf1, 0x8c, 0x85, 0x21, 0x7a, 0x0a, 0x0d, 0x05, 0xf5, 0x59,
	0x24, 0xa9, 0x98, 0x93, 0x30, 0x1d, 0x36, 0x1f, 0xbc, 0xc1, 0x71, 0x96, 0x3e, 0xc6, 0xb8, 0xae,
	0xfc, 0x2f, 0x52, 0x77, 0xf7, 0x75, 0x11, 0x9c, 0x5d, 0xd7, 0xfb, 0x9f, 0x32, 0x31, 0x5e, 0xbf,
	0x0d, 0x26, 0x0b, 0xcf, 0xff, 0x5b, 0x16, 0xbc, 0xf5, 0x72, 0xf3, 0x11, 0x71, 0x3f, 0x87, 0x3b,
	0xb7, 0xce, 0xf6, 0x6d, 0x90, 0xee, 0xe3, 0x3f, 0x6e, 0x4e, 0xac, 0x3f, 0x6f, 0x4e, 0xac, 0xbf,
	0x6e, 0x4e, 0xac, 0x1f, 0x8e, 0x4d, 0x80, 0x8c, 0xb7, 0x48, 0xcc, 0x5a, 0xb7, 0x7e, 0xae, 0xfa,
	0x65, 0x2d, 0xf2, 0xe9, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x7a, 0x9d, 0x7f, 0x58, 0x76, 0x09,
	0x00, 0x00,
}

func (m *RateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policy != nil {
		{
			size := m.Policy.Size()
			i -= size
			if _, err := m.Policy.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRatelimit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Binding != nil {
		{
			size := m.Binding.Size()
			i -= size
			if _, err := m.Binding.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimit_Workload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Workload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Workload != nil {
		{
			size, err := m.Workload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Route) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Route) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Route != nil {
		{
			size, err := m.Route.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RateLimit_Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimit_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RouteSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RouteSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RouteSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Route) > 0 {
		i -= len(m.Route)
		copy(dAtA[i:], m.Route)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Route)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRatelimit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EntryType != nil {
		{
			size := m.EntryType.Size()
			i -= size
			if _, err := m.EntryType.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_HeaderMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_HeaderMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HeaderMatch != nil {
		{
			size, err := m.HeaderMatch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_Generic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_Generic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Generic != nil {
		{
			size, err := m.Generic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_Expression_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_Expression_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Expression != nil {
		{
			size, err := m.Expression.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SkipIfAbsent {
		i--
		if m.SkipIfAbsent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry_RequestHeaderMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry_RequestHeaderMatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRatelimit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ExpectFalse {
		i--
		if m.ExpectFalse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Condition != nil {
		{
			size := m.Condition.Size()
			i -= size
			if _, err := m.Condition.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Exact)
	copy(dAtA[i:], m.Exact)
	i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Exact)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Prefix)
	copy(dAtA[i:], m.Prefix)
	i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Prefix)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Contains)
	copy(dAtA[i:], m.Contains)
	i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Contains)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.Present {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x28
	return len(dAtA) - i, nil
}
func (m *RateLimitEntry_GenericEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry_GenericEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_GenericEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RateLimitEntry_Expression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RateLimitEntry_Expression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RateLimitEntry_Expression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SkipIfError {
		i--
		if m.SkipIfError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Descriptors) > 0 {
		for iNdEx := len(m.Descriptors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Descriptors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRatelimit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TokenBucket != nil {
		{
			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit_TokenBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit_TokenBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit_TokenBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FillInterval != nil {
		{
			size, err := m.FillInterval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TokensPerFill != nil {
		{
			size, err := m.TokensPerFill.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MaxTokens != 0 {
		i = encodeVarintRatelimit(dAtA, i, uint64(m.MaxTokens))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRatelimit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TokenBucket != nil {
		{
			size, err := m.TokenBucket.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRatelimit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRatelimit(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRatelimit(dAtA []byte, offset int, v uint64) int {
	offset -= sovRatelimit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Binding != nil {
		n += m.Binding.Size()
	}
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovRatelimit(uint64(l))
		}
	}
	if m.Policy != nil {
		n += m.Policy.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimit_Workload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Workload != nil {
		l = m.Workload.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimit_Route) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Route != nil {
		l = m.Route.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimit_Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimit_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RouteSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Route)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRatelimit(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EntryType != nil {
		n += m.EntryType.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimitEntry_HeaderMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderMatch != nil {
		l = m.HeaderMatch.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimitEntry_Generic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Generic != nil {
		l = m.Generic.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimitEntry_Expression_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Expression != nil {
		l = m.Expression.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	return n
}
func (m *RateLimitEntry_RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.SkipIfAbsent {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry_RequestHeaderMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.ExpectFalse {
		n += 2
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovRatelimit(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.Condition != nil {
		n += m.Condition.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Exact)
	n += 1 + l + sovRatelimit(uint64(l))
	return n
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Prefix)
	n += 1 + l + sovRatelimit(uint64(l))
	return n
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contains)
	n += 1 + l + sovRatelimit(uint64(l))
	return n
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *RateLimitEntry_GenericEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RateLimitEntry_Expression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.SkipIfError {
		n += 2
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenBucket != nil {
		l = m.TokenBucket.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if len(m.Descriptors) > 0 {
		for _, e := range m.Descriptors {
			l = e.Size()
			n += 1 + l + sovRatelimit(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit_TokenBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTokens != 0 {
		n += 1 + sovRatelimit(uint64(m.MaxTokens))
	}
	if m.TokensPerFill != nil {
		l = m.TokensPerFill.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.FillInterval != nil {
		l = m.FillInterval.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit_LocalRateLimitDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenBucket != nil {
		l = m.TokenBucket.Size()
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRatelimit(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRatelimit(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRatelimit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRatelimit(x uint64) (n int) {
	return sovRatelimit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &v1beta1.WorkloadSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Binding = &RateLimit_Workload{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RouteSelector{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Binding = &RateLimit_Route{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, &RateLimitDescriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProviderRef{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Policy = &RateLimit_Global{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LocalRateLimit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Policy = &RateLimit_Local{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Route", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Route = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &RateLimitEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RateLimitEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RateLimitEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimitEntry_RequestHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EntryType = &RateLimitEntry_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimitEntry_RequestHeaderMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EntryType = &RateLimitEntry_HeaderMatch{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimitEntry_GenericEntry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EntryType = &RateLimitEntry_Generic{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RateLimitEntry_Expression{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.EntryType = &RateLimitEntry_Expression_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipIfAbsent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipIfAbsent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry_RequestHeaderMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeaderMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeaderMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectFalse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpectFalse = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeaderMatchCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeaderMatchCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = &RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Exact{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = &RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Prefix{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Condition = &RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Contains{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Condition = &RateLimitEntry_RequestHeaderMatch_HeaderMatchCondition_Present{b}
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry_GenericEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RateLimitEntry_Expression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipIfError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipIfError = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalRateLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalRateLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenBucket == nil {
				m.TokenBucket = &LocalRateLimit_TokenBucket{}
			}
			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Descriptors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Descriptors = append(m.Descriptors, &LocalRateLimit_LocalRateLimitDescriptor{})
			if err := m.Descriptors[len(m.Descriptors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit_TokenBucket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTokens", wireType)
			}
			m.MaxTokens = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTokens |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensPerFill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokensPerFill == nil {
				m.TokensPerFill = &types.UInt32Value{}
			}
			if err := m.TokensPerFill.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FillInterval == nil {
				m.FillInterval = &types.Duration{}
			}
			if err := m.FillInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit_LocalRateLimitDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocalRateLimitDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocalRateLimitDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenBucket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenBucket == nil {
				m.TokenBucket = &LocalRateLimit_TokenBucket{}
			}
			if err := m.TokenBucket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocalRateLimit_LocalRateLimitDescriptor_DescriptorEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescriptorEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescriptorEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRatelimit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRatelimit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRatelimit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRatelimit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRatelimit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRatelimit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRatelimit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRatelimit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRatelimit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRatelimit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRatelimit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRatelimit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRatelimit = fmt.Errorf("proto: unexpected end of group")
)
