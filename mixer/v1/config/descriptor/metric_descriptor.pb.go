// Code generated by protoc-gen-go.
// source: mixer/v1/config/descriptor/metric_descriptor.proto
// DO NOT EDIT!

package istio_mixer_v1_config_descriptor

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// The kind of measurement. It describes how the data is recorded.
type MetricDescriptor_MetricKind int32

const (
	// Do not use this default value.
	MetricDescriptor_METRIC_KIND_UNSPECIFIED MetricDescriptor_MetricKind = 0
	// An instantaneous measurement of a value. For example, the number of VMs.
	MetricDescriptor_GAUGE MetricDescriptor_MetricKind = 1
	// A count of occurrences over an interval, always a positive integer.
	// For example, the number of API requests.
	MetricDescriptor_COUNTER MetricDescriptor_MetricKind = 2
)

var MetricDescriptor_MetricKind_name = map[int32]string{
	0: "METRIC_KIND_UNSPECIFIED",
	1: "GAUGE",
	2: "COUNTER",
}
var MetricDescriptor_MetricKind_value = map[string]int32{
	"METRIC_KIND_UNSPECIFIED": 0,
	"GAUGE":                   1,
	"COUNTER":                 2,
}

func (x MetricDescriptor_MetricKind) String() string {
	return proto.EnumName(MetricDescriptor_MetricKind_name, int32(x))
}
func (MetricDescriptor_MetricKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor3, []int{0, 0}
}

// Defines a metric type and its schema.
//
// A metric is dimensioned by a set of labels whose values are derived at runtime from attributes.
// A given metric holds a unique value for potentially any combination of these dimensions.
//
// The following is an example descriptor for a metric capturing the number of RPCs served, dimensioned
// by the method being called and response code returned by the server:
//
//    metric_descriptor:
//      name: "response_code"
//      kind: COUNTER
//      value: I64
//      labels:
//        name: api_method
//        value_type: STRING
//      labels:
//        name: response_code
//        value_type: INT64
//
// To actually report metrics at run time a mapping from attributes to a metric's labels must be provided.
// This is provided in the service's config; using our above descriptor we might describe the metric as:
//
//    metric:
//      descriptor: "response_code" # must match metric_descriptor.name
//      value: $requestCount        # Istio expression syntax for the attribute named "request_count"
//      labels:
//        # either the attribute named 'apiMethod' or the literal string 'unknown'; must eval to a string
//        api_method: $apiMethod | "unknown"
//        # either the attribute named 'responseCode' or the literal int64 500; must eval to an int64
//        response_code: $responseCode | 500
//
type MetricDescriptor struct {
	// The name of this descriptor.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An optional concise name for the metric, which can be displayed in user interfaces.
	// Use sentence case without an ending period, for example "Request count".
	DisplayName string `protobuf:"bytes,2,opt,name=display_name,json=displayName" json:"display_name,omitempty"`
	// An optional description of the metric, which should be used as the documentation for the metric.
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// Whether the metric records instantaneous values, changes to a value, etc.
	Kind MetricDescriptor_MetricKind `protobuf:"varint,4,opt,name=kind,enum=istio.mixer.v1.config.descriptor.MetricDescriptor_MetricKind" json:"kind,omitempty"`
	// The type of data this metric records.
	Value ValueType `protobuf:"varint,5,opt,name=value,enum=istio.mixer.v1.config.descriptor.ValueType" json:"value,omitempty"`
	// Labels that dimension the data recorded by this metric. The metric definition allows the user to
	// map attribute expressions to actual values for these labels at run time; the result of the evaluation
	// must be of the type described by the kind for each label.
	Labels []*LabelDescriptor `protobuf:"bytes,6,rep,name=labels" json:"labels,omitempty"`
}

func (m *MetricDescriptor) Reset()                    { *m = MetricDescriptor{} }
func (m *MetricDescriptor) String() string            { return proto.CompactTextString(m) }
func (*MetricDescriptor) ProtoMessage()               {}
func (*MetricDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor3, []int{0} }

func (m *MetricDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetricDescriptor) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *MetricDescriptor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MetricDescriptor) GetKind() MetricDescriptor_MetricKind {
	if m != nil {
		return m.Kind
	}
	return MetricDescriptor_METRIC_KIND_UNSPECIFIED
}

func (m *MetricDescriptor) GetValue() ValueType {
	if m != nil {
		return m.Value
	}
	return ValueType_VALUE_TYPE_UNSPECIFIED
}

func (m *MetricDescriptor) GetLabels() []*LabelDescriptor {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterType((*MetricDescriptor)(nil), "istio.mixer.v1.config.descriptor.MetricDescriptor")
	proto.RegisterEnum("istio.mixer.v1.config.descriptor.MetricDescriptor_MetricKind", MetricDescriptor_MetricKind_name, MetricDescriptor_MetricKind_value)
}

func init() { proto.RegisterFile("mixer/v1/config/descriptor/metric_descriptor.proto", fileDescriptor3) }

var fileDescriptor3 = []byte{
	// 318 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x91, 0xcf, 0x4e, 0xb3, 0x40,
	0x14, 0xc5, 0x3f, 0xfa, 0xef, 0x4b, 0x2f, 0xc6, 0x90, 0xd9, 0x48, 0xea, 0x06, 0xbb, 0x6a, 0xa2,
	0x19, 0x42, 0x5d, 0xbb, 0x68, 0x5a, 0x6c, 0x48, 0x2d, 0xea, 0x08, 0x6e, 0x09, 0x85, 0xd1, 0x4c,
	0x04, 0x86, 0x00, 0x12, 0x79, 0x0a, 0x5f, 0xd9, 0x30, 0xa0, 0x24, 0x9a, 0x94, 0xdd, 0xe4, 0xdc,
	0x73, 0x7e, 0x73, 0xee, 0x0c, 0x2c, 0x63, 0xf6, 0x41, 0x33, 0xbd, 0x34, 0xf4, 0x80, 0x27, 0x2f,
	0xec, 0x55, 0x0f, 0x69, 0x1e, 0x64, 0x2c, 0x2d, 0x78, 0xa6, 0xc7, 0xb4, 0xc8, 0x58, 0xe0, 0x75,
	0x0a, 0x4e, 0x33, 0x5e, 0x70, 0xa4, 0xb1, 0xbc, 0x60, 0x1c, 0x8b, 0x24, 0x2e, 0x0d, 0xdc, 0x24,
	0x71, 0xe7, 0x9b, 0x19, 0x47, 0xa8, 0x91, 0x7f, 0xa0, 0xd1, 0x1f, 0xe8, 0xec, 0xea, 0x48, 0xa4,
	0xf4, 0xa3, 0x77, 0xea, 0x15, 0x55, 0x4a, 0xf3, 0xc6, 0x3d, 0xff, 0x1c, 0x82, 0xb2, 0x17, 0xf5,
	0x36, 0x3f, 0x36, 0x84, 0x60, 0x94, 0xf8, 0x31, 0x55, 0x25, 0x4d, 0x5a, 0x4c, 0x89, 0x38, 0xa3,
	0x0b, 0x38, 0x09, 0x59, 0x9e, 0x46, 0x7e, 0xe5, 0x89, 0xd9, 0x40, 0xcc, 0xe4, 0x56, 0xb3, 0x6b,
	0x8b, 0x06, 0xf2, 0xf7, 0x5d, 0x8c, 0x27, 0xea, 0xb0, 0x75, 0x74, 0x12, 0x7a, 0x84, 0xd1, 0x1b,
	0x4b, 0x42, 0x75, 0xa4, 0x49, 0x8b, 0xd3, 0xe5, 0x0d, 0xee, 0xdb, 0x1f, 0xff, 0xae, 0xd6, 0x0a,
	0x3b, 0x96, 0x84, 0x44, 0xa0, 0xd0, 0x0a, 0xc6, 0x62, 0x2b, 0x75, 0x2c, 0x98, 0x97, 0xfd, 0xcc,
	0xe7, 0xda, 0xee, 0x54, 0x29, 0x25, 0x4d, 0x12, 0x59, 0x30, 0x11, 0x6f, 0x99, 0xab, 0x13, 0x6d,
	0xb8, 0x90, 0x97, 0x46, 0x3f, 0xe3, 0xae, 0xf6, 0x77, 0xb5, 0x48, 0x0b, 0x98, 0xaf, 0x00, 0xba,
	0x86, 0xe8, 0x1c, 0xce, 0xf6, 0xa6, 0x43, 0xac, 0xb5, 0xb7, 0xb3, 0xec, 0x8d, 0xe7, 0xda, 0x4f,
	0x0f, 0xe6, 0xda, 0xba, 0xb5, 0xcc, 0x8d, 0xf2, 0x0f, 0x4d, 0x61, 0xbc, 0x5d, 0xb9, 0x5b, 0x53,
	0x91, 0x90, 0x0c, 0xff, 0xd7, 0xf7, 0xae, 0xed, 0x98, 0x44, 0x19, 0x1c, 0x26, 0xe2, 0x63, 0xae,
	0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0xb5, 0xdf, 0x92, 0xae, 0x51, 0x02, 0x00, 0x00,
}
