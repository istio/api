// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mixer/v1/config/client/client_config.proto

package client

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"
import istio_mixer_v1 "istio.io/api/mixer/v1"

import strconv "strconv"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Describes the policy when failed to connect to Mixer server.
type NetworkFailPolicy int32

const (
	// If network connection fails, request is passed to the backend.
	FAIL_OPEN NetworkFailPolicy = 0
	// If network connection fails, request is rejected.
	FAIL_CLOSE NetworkFailPolicy = 1
)

var NetworkFailPolicy_name = map[int32]string{
	0: "FAIL_OPEN",
	1: "FAIL_CLOSE",
}
var NetworkFailPolicy_value = map[string]int32{
	"FAIL_OPEN":  0,
	"FAIL_CLOSE": 1,
}

func (NetworkFailPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorClientConfig, []int{0} }

// Defines the per-service client configuration.
type ServiceConfig struct {
	// If true, do not call Mixer Check.
	DisableCheckCalls bool `protobuf:"varint,1,opt,name=disable_check_calls,json=disableCheckCalls,proto3" json:"disable_check_calls,omitempty"`
	// If true, do not call Mixer Report.
	DisableReportCalls bool `protobuf:"varint,2,opt,name=disable_report_calls,json=disableReportCalls,proto3" json:"disable_report_calls,omitempty"`
	// Send these attributes to Mixer in both Check and Report. This
	// typically includes the "destination.service" attribute.
	MixerAttributes *istio_mixer_v1.Attributes `protobuf:"bytes,3,opt,name=mixer_attributes,json=mixerAttributes" json:"mixer_attributes,omitempty"`
	// HTTP API specifications to generate API attributes.
	HttpApiSpec []*HTTPAPISpec `protobuf:"bytes,4,rep,name=http_api_spec,json=httpApiSpec" json:"http_api_spec,omitempty"`
	// Quota specifications to generate quota requirements.
	QuotaSpec []*QuotaSpec `protobuf:"bytes,5,rep,name=quota_spec,json=quotaSpec" json:"quota_spec,omitempty"`
	// End user authentication policy.
	EndUserAuthnSpec *EndUserAuthenticationPolicySpec `protobuf:"bytes,6,opt,name=end_user_authn_spec,json=endUserAuthnSpec" json:"end_user_authn_spec,omitempty"`
	// Specifies the policy when failed to connect to Mixer server.
	// This is the service-level policy. It overrides mesh-level policy (defined
	// in TransportConfig#network_fail_policy).
	NetworkFailPolicy NetworkFailPolicy `protobuf:"varint,7,opt,name=network_fail_policy,json=networkFailPolicy,proto3,enum=istio.mixer.v1.config.client.NetworkFailPolicy" json:"network_fail_policy,omitempty"`
}

func (m *ServiceConfig) Reset()                    { *m = ServiceConfig{} }
func (*ServiceConfig) ProtoMessage()               {}
func (*ServiceConfig) Descriptor() ([]byte, []int) { return fileDescriptorClientConfig, []int{0} }

// Defines the transport config on how to call Mixer.
type TransportConfig struct {
	// The flag to disable check cache.
	DisableCheckCache bool `protobuf:"varint,1,opt,name=disable_check_cache,json=disableCheckCache,proto3" json:"disable_check_cache,omitempty"`
	// The flag to disable quota cache.
	DisableQuotaCache bool `protobuf:"varint,2,opt,name=disable_quota_cache,json=disableQuotaCache,proto3" json:"disable_quota_cache,omitempty"`
	// The flag to disable report batch.
	DisableReportBatch bool `protobuf:"varint,3,opt,name=disable_report_batch,json=disableReportBatch,proto3" json:"disable_report_batch,omitempty"`
	// Specifies the policy when failed to connect to Mixer server.
	// This is the mesh level policy.
	NetworkFailPolicy NetworkFailPolicy `protobuf:"varint,4,opt,name=network_fail_policy,json=networkFailPolicy,proto3,enum=istio.mixer.v1.config.client.NetworkFailPolicy" json:"network_fail_policy,omitempty"`
	// Specify refresh interval to write mixer client statistics to Envoy share
	// memory. If not specified, the interval is 10 seconds.
	StatsUpdateInterval *google_protobuf1.Duration `protobuf:"bytes,5,opt,name=stats_update_interval,json=statsUpdateInterval" json:"stats_update_interval,omitempty"`
	// Name of the cluster that will forward check calls to a pool of mixer
	// servers. Defaults to "mixer_server". By using different names for
	// checkCluster and reportCluster, it is possible to have one set of
	// mixer servers handle check calls, while another set of mixer servers
	// handle report calls.
	//
	// NOTE: Any value other than the default "mixer_server" will require the
	// Istio Grafana dashboards to be reconfigured to use the new name.
	CheckCluster string `protobuf:"bytes,6,opt,name=check_cluster,json=checkCluster,proto3" json:"check_cluster,omitempty"`
	// Name of the cluster that will forward report calls to a pool of mixer
	// servers. Defaults to "mixer_server". By using different names for
	// checkCluster and reportCluster, it is possible to have one set of
	// mixer servers handle check calls, while another set of mixer servers
	// handle report calls.
	//
	// NOTE: Any value other than the default "mixer_server" will require the
	// Istio Grafana dashboards to be reconfigured to use the new name.
	ReportCluster string `protobuf:"bytes,7,opt,name=report_cluster,json=reportCluster,proto3" json:"report_cluster,omitempty"`
}

func (m *TransportConfig) Reset()                    { *m = TransportConfig{} }
func (*TransportConfig) ProtoMessage()               {}
func (*TransportConfig) Descriptor() ([]byte, []int) { return fileDescriptorClientConfig, []int{1} }

// Defines the client config for HTTP.
type HttpClientConfig struct {
	// The transport config.
	Transport *TransportConfig `protobuf:"bytes,1,opt,name=transport" json:"transport,omitempty"`
	// Map of control configuration indexed by destination.service. This
	// is used to support per-service configuration for cases where a
	// mixerclient serves multiple services.
	ServiceConfigs map[string]*ServiceConfig `protobuf:"bytes,2,rep,name=service_configs,json=serviceConfigs" json:"service_configs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Default destination service name if none was specified in the
	// client request.
	DefaultDestinationService string `protobuf:"bytes,3,opt,name=default_destination_service,json=defaultDestinationService,proto3" json:"default_destination_service,omitempty"`
	// Default attributes to send to Mixer in both Check and
	// Report. This typically includes "destination.ip" and
	// "destination.uid" attributes.
	MixerAttributes *istio_mixer_v1.Attributes `protobuf:"bytes,4,opt,name=mixer_attributes,json=mixerAttributes" json:"mixer_attributes,omitempty"`
	// Default attributes to forward to upstream. This typically
	// includes the "source.ip" and "source.uid" attributes.
	ForwardAttributes *istio_mixer_v1.Attributes `protobuf:"bytes,5,opt,name=forward_attributes,json=forwardAttributes" json:"forward_attributes,omitempty"`
}

func (m *HttpClientConfig) Reset()                    { *m = HttpClientConfig{} }
func (*HttpClientConfig) ProtoMessage()               {}
func (*HttpClientConfig) Descriptor() ([]byte, []int) { return fileDescriptorClientConfig, []int{2} }

// Defines the client config for TCP.
type TcpClientConfig struct {
	// The transport config.
	Transport *TransportConfig `protobuf:"bytes,1,opt,name=transport" json:"transport,omitempty"`
	// Default attributes to send to Mixer in both Check and
	// Report. This typically includes "destination.ip" and
	// "destination.uid" attributes.
	MixerAttributes *istio_mixer_v1.Attributes `protobuf:"bytes,2,opt,name=mixer_attributes,json=mixerAttributes" json:"mixer_attributes,omitempty"`
	// If set to true, disables mixer check calls.
	DisableCheckCalls bool `protobuf:"varint,3,opt,name=disable_check_calls,json=disableCheckCalls,proto3" json:"disable_check_calls,omitempty"`
	// If set to true, disables mixer check calls.
	DisableReportCalls bool `protobuf:"varint,4,opt,name=disable_report_calls,json=disableReportCalls,proto3" json:"disable_report_calls,omitempty"`
	// Quota specifications to generate quota requirements.
	// It applies on the new TCP connections.
	ConnectionQuotaSpec *QuotaSpec `protobuf:"bytes,5,opt,name=connection_quota_spec,json=connectionQuotaSpec" json:"connection_quota_spec,omitempty"`
	// Specify report interval to send periodical reports for long TCP
	// connections. If not specified, the interval is 10 seconds. This interval
	// should not be less than 1 second, otherwise it will be reset to 1 second.
	ReportInterval *google_protobuf1.Duration `protobuf:"bytes,6,opt,name=report_interval,json=reportInterval" json:"report_interval,omitempty"`
}

func (m *TcpClientConfig) Reset()                    { *m = TcpClientConfig{} }
func (*TcpClientConfig) ProtoMessage()               {}
func (*TcpClientConfig) Descriptor() ([]byte, []int) { return fileDescriptorClientConfig, []int{3} }

func init() {
	proto.RegisterType((*ServiceConfig)(nil), "istio.mixer.v1.config.client.ServiceConfig")
	proto.RegisterType((*TransportConfig)(nil), "istio.mixer.v1.config.client.TransportConfig")
	proto.RegisterType((*HttpClientConfig)(nil), "istio.mixer.v1.config.client.HttpClientConfig")
	proto.RegisterType((*TcpClientConfig)(nil), "istio.mixer.v1.config.client.TcpClientConfig")
	proto.RegisterEnum("istio.mixer.v1.config.client.NetworkFailPolicy", NetworkFailPolicy_name, NetworkFailPolicy_value)
}
func (x NetworkFailPolicy) String() string {
	s, ok := NetworkFailPolicy_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (m *ServiceConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisableCheckCalls {
		dAtA[i] = 0x8
		i++
		if m.DisableCheckCalls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableReportCalls {
		dAtA[i] = 0x10
		i++
		if m.DisableReportCalls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MixerAttributes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.MixerAttributes.Size()))
		n1, err := m.MixerAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.HttpApiSpec) > 0 {
		for _, msg := range m.HttpApiSpec {
			dAtA[i] = 0x22
			i++
			i = encodeVarintClientConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QuotaSpec) > 0 {
		for _, msg := range m.QuotaSpec {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintClientConfig(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.EndUserAuthnSpec != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.EndUserAuthnSpec.Size()))
		n2, err := m.EndUserAuthnSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.NetworkFailPolicy != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.NetworkFailPolicy))
	}
	return i, nil
}

func (m *TransportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransportConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DisableCheckCache {
		dAtA[i] = 0x8
		i++
		if m.DisableCheckCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableQuotaCache {
		dAtA[i] = 0x10
		i++
		if m.DisableQuotaCache {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableReportBatch {
		dAtA[i] = 0x18
		i++
		if m.DisableReportBatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NetworkFailPolicy != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.NetworkFailPolicy))
	}
	if m.StatsUpdateInterval != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.StatsUpdateInterval.Size()))
		n3, err := m.StatsUpdateInterval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.CheckCluster) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(len(m.CheckCluster)))
		i += copy(dAtA[i:], m.CheckCluster)
	}
	if len(m.ReportCluster) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(len(m.ReportCluster)))
		i += copy(dAtA[i:], m.ReportCluster)
	}
	return i, nil
}

func (m *HttpClientConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpClientConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transport != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.Transport.Size()))
		n4, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.ServiceConfigs) > 0 {
		for k, _ := range m.ServiceConfigs {
			dAtA[i] = 0x12
			i++
			v := m.ServiceConfigs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovClientConfig(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovClientConfig(uint64(len(k))) + msgSize
			i = encodeVarintClientConfig(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintClientConfig(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintClientConfig(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.DefaultDestinationService) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(len(m.DefaultDestinationService)))
		i += copy(dAtA[i:], m.DefaultDestinationService)
	}
	if m.MixerAttributes != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.MixerAttributes.Size()))
		n6, err := m.MixerAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ForwardAttributes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.ForwardAttributes.Size()))
		n7, err := m.ForwardAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TcpClientConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TcpClientConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transport != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.Transport.Size()))
		n8, err := m.Transport.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MixerAttributes != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.MixerAttributes.Size()))
		n9, err := m.MixerAttributes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DisableCheckCalls {
		dAtA[i] = 0x18
		i++
		if m.DisableCheckCalls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableReportCalls {
		dAtA[i] = 0x20
		i++
		if m.DisableReportCalls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ConnectionQuotaSpec != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.ConnectionQuotaSpec.Size()))
		n10, err := m.ConnectionQuotaSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ReportInterval != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintClientConfig(dAtA, i, uint64(m.ReportInterval.Size()))
		n11, err := m.ReportInterval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintClientConfig(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ServiceConfig) Size() (n int) {
	var l int
	_ = l
	if m.DisableCheckCalls {
		n += 2
	}
	if m.DisableReportCalls {
		n += 2
	}
	if m.MixerAttributes != nil {
		l = m.MixerAttributes.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if len(m.HttpApiSpec) > 0 {
		for _, e := range m.HttpApiSpec {
			l = e.Size()
			n += 1 + l + sovClientConfig(uint64(l))
		}
	}
	if len(m.QuotaSpec) > 0 {
		for _, e := range m.QuotaSpec {
			l = e.Size()
			n += 1 + l + sovClientConfig(uint64(l))
		}
	}
	if m.EndUserAuthnSpec != nil {
		l = m.EndUserAuthnSpec.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.NetworkFailPolicy != 0 {
		n += 1 + sovClientConfig(uint64(m.NetworkFailPolicy))
	}
	return n
}

func (m *TransportConfig) Size() (n int) {
	var l int
	_ = l
	if m.DisableCheckCache {
		n += 2
	}
	if m.DisableQuotaCache {
		n += 2
	}
	if m.DisableReportBatch {
		n += 2
	}
	if m.NetworkFailPolicy != 0 {
		n += 1 + sovClientConfig(uint64(m.NetworkFailPolicy))
	}
	if m.StatsUpdateInterval != nil {
		l = m.StatsUpdateInterval.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	l = len(m.CheckCluster)
	if l > 0 {
		n += 1 + l + sovClientConfig(uint64(l))
	}
	l = len(m.ReportCluster)
	if l > 0 {
		n += 1 + l + sovClientConfig(uint64(l))
	}
	return n
}

func (m *HttpClientConfig) Size() (n int) {
	var l int
	_ = l
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if len(m.ServiceConfigs) > 0 {
		for k, v := range m.ServiceConfigs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovClientConfig(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovClientConfig(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovClientConfig(uint64(mapEntrySize))
		}
	}
	l = len(m.DefaultDestinationService)
	if l > 0 {
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.MixerAttributes != nil {
		l = m.MixerAttributes.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.ForwardAttributes != nil {
		l = m.ForwardAttributes.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	return n
}

func (m *TcpClientConfig) Size() (n int) {
	var l int
	_ = l
	if m.Transport != nil {
		l = m.Transport.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.MixerAttributes != nil {
		l = m.MixerAttributes.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.DisableCheckCalls {
		n += 2
	}
	if m.DisableReportCalls {
		n += 2
	}
	if m.ConnectionQuotaSpec != nil {
		l = m.ConnectionQuotaSpec.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	if m.ReportInterval != nil {
		l = m.ReportInterval.Size()
		n += 1 + l + sovClientConfig(uint64(l))
	}
	return n
}

func sovClientConfig(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozClientConfig(x uint64) (n int) {
	return sovClientConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ServiceConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ServiceConfig{`,
		`DisableCheckCalls:` + fmt.Sprintf("%v", this.DisableCheckCalls) + `,`,
		`DisableReportCalls:` + fmt.Sprintf("%v", this.DisableReportCalls) + `,`,
		`MixerAttributes:` + strings.Replace(fmt.Sprintf("%v", this.MixerAttributes), "Attributes", "istio_mixer_v1.Attributes", 1) + `,`,
		`HttpApiSpec:` + strings.Replace(fmt.Sprintf("%v", this.HttpApiSpec), "HTTPAPISpec", "HTTPAPISpec", 1) + `,`,
		`QuotaSpec:` + strings.Replace(fmt.Sprintf("%v", this.QuotaSpec), "QuotaSpec", "QuotaSpec", 1) + `,`,
		`EndUserAuthnSpec:` + strings.Replace(fmt.Sprintf("%v", this.EndUserAuthnSpec), "EndUserAuthenticationPolicySpec", "EndUserAuthenticationPolicySpec", 1) + `,`,
		`NetworkFailPolicy:` + fmt.Sprintf("%v", this.NetworkFailPolicy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TransportConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TransportConfig{`,
		`DisableCheckCache:` + fmt.Sprintf("%v", this.DisableCheckCache) + `,`,
		`DisableQuotaCache:` + fmt.Sprintf("%v", this.DisableQuotaCache) + `,`,
		`DisableReportBatch:` + fmt.Sprintf("%v", this.DisableReportBatch) + `,`,
		`NetworkFailPolicy:` + fmt.Sprintf("%v", this.NetworkFailPolicy) + `,`,
		`StatsUpdateInterval:` + strings.Replace(fmt.Sprintf("%v", this.StatsUpdateInterval), "Duration", "google_protobuf1.Duration", 1) + `,`,
		`CheckCluster:` + fmt.Sprintf("%v", this.CheckCluster) + `,`,
		`ReportCluster:` + fmt.Sprintf("%v", this.ReportCluster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpClientConfig) String() string {
	if this == nil {
		return "nil"
	}
	keysForServiceConfigs := make([]string, 0, len(this.ServiceConfigs))
	for k, _ := range this.ServiceConfigs {
		keysForServiceConfigs = append(keysForServiceConfigs, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForServiceConfigs)
	mapStringForServiceConfigs := "map[string]*ServiceConfig{"
	for _, k := range keysForServiceConfigs {
		mapStringForServiceConfigs += fmt.Sprintf("%v: %v,", k, this.ServiceConfigs[k])
	}
	mapStringForServiceConfigs += "}"
	s := strings.Join([]string{`&HttpClientConfig{`,
		`Transport:` + strings.Replace(fmt.Sprintf("%v", this.Transport), "TransportConfig", "TransportConfig", 1) + `,`,
		`ServiceConfigs:` + mapStringForServiceConfigs + `,`,
		`DefaultDestinationService:` + fmt.Sprintf("%v", this.DefaultDestinationService) + `,`,
		`MixerAttributes:` + strings.Replace(fmt.Sprintf("%v", this.MixerAttributes), "Attributes", "istio_mixer_v1.Attributes", 1) + `,`,
		`ForwardAttributes:` + strings.Replace(fmt.Sprintf("%v", this.ForwardAttributes), "Attributes", "istio_mixer_v1.Attributes", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TcpClientConfig) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TcpClientConfig{`,
		`Transport:` + strings.Replace(fmt.Sprintf("%v", this.Transport), "TransportConfig", "TransportConfig", 1) + `,`,
		`MixerAttributes:` + strings.Replace(fmt.Sprintf("%v", this.MixerAttributes), "Attributes", "istio_mixer_v1.Attributes", 1) + `,`,
		`DisableCheckCalls:` + fmt.Sprintf("%v", this.DisableCheckCalls) + `,`,
		`DisableReportCalls:` + fmt.Sprintf("%v", this.DisableReportCalls) + `,`,
		`ConnectionQuotaSpec:` + strings.Replace(fmt.Sprintf("%v", this.ConnectionQuotaSpec), "QuotaSpec", "QuotaSpec", 1) + `,`,
		`ReportInterval:` + strings.Replace(fmt.Sprintf("%v", this.ReportInterval), "Duration", "google_protobuf1.Duration", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringClientConfig(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ServiceConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCheckCalls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCheckCalls = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableReportCalls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableReportCalls = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixerAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MixerAttributes == nil {
				m.MixerAttributes = &istio_mixer_v1.Attributes{}
			}
			if err := m.MixerAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpApiSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpApiSpec = append(m.HttpApiSpec, &HTTPAPISpec{})
			if err := m.HttpApiSpec[len(m.HttpApiSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuotaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuotaSpec = append(m.QuotaSpec, &QuotaSpec{})
			if err := m.QuotaSpec[len(m.QuotaSpec)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndUserAuthnSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndUserAuthnSpec == nil {
				m.EndUserAuthnSpec = &EndUserAuthenticationPolicySpec{}
			}
			if err := m.EndUserAuthnSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFailPolicy", wireType)
			}
			m.NetworkFailPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkFailPolicy |= (NetworkFailPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipClientConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCheckCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCheckCache = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableQuotaCache", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableQuotaCache = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableReportBatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableReportBatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFailPolicy", wireType)
			}
			m.NetworkFailPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkFailPolicy |= (NetworkFailPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsUpdateInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsUpdateInterval == nil {
				m.StatsUpdateInterval = &google_protobuf1.Duration{}
			}
			if err := m.StatsUpdateInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpClientConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpClientConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpClientConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &TransportConfig{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceConfigs == nil {
				m.ServiceConfigs = make(map[string]*ServiceConfig)
			}
			var mapkey string
			var mapvalue *ServiceConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowClientConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthClientConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowClientConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthClientConfig
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthClientConfig
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ServiceConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipClientConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthClientConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceConfigs[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultDestinationService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultDestinationService = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixerAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MixerAttributes == nil {
				m.MixerAttributes = &istio_mixer_v1.Attributes{}
			}
			if err := m.MixerAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForwardAttributes == nil {
				m.ForwardAttributes = &istio_mixer_v1.Attributes{}
			}
			if err := m.ForwardAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TcpClientConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowClientConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TcpClientConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TcpClientConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transport == nil {
				m.Transport = &TransportConfig{}
			}
			if err := m.Transport.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MixerAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MixerAttributes == nil {
				m.MixerAttributes = &istio_mixer_v1.Attributes{}
			}
			if err := m.MixerAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableCheckCalls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableCheckCalls = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableReportCalls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableReportCalls = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionQuotaSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnectionQuotaSpec == nil {
				m.ConnectionQuotaSpec = &QuotaSpec{}
			}
			if err := m.ConnectionQuotaSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportInterval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthClientConfig
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportInterval == nil {
				m.ReportInterval = &google_protobuf1.Duration{}
			}
			if err := m.ReportInterval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipClientConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthClientConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipClientConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowClientConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowClientConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthClientConfig
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowClientConfig
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipClientConfig(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthClientConfig = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowClientConfig   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("mixer/v1/config/client/client_config.proto", fileDescriptorClientConfig)
}

var fileDescriptorClientConfig = []byte{
	// 877 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x26, 0x2d, 0xd9, 0xa9, 0x56, 0x95, 0x2d, 0xaf, 0x12, 0x40, 0x76, 0x0b, 0xc2, 0x55, 0x10,
	0xd4, 0x4d, 0x51, 0xb2, 0x51, 0x2f, 0x45, 0x81, 0x16, 0x90, 0x15, 0x19, 0x31, 0x9a, 0x1f, 0x97,
	0xb6, 0x2f, 0xed, 0x81, 0x58, 0x2d, 0x57, 0xe2, 0xc2, 0xec, 0x2e, 0x43, 0x2e, 0x95, 0xfa, 0xd6,
	0x27, 0x28, 0xfa, 0x04, 0xed, 0x35, 0x8f, 0x92, 0x63, 0x8e, 0x3d, 0xd6, 0xea, 0xa5, 0xc7, 0x3c,
	0x42, 0xc1, 0xd9, 0x95, 0x15, 0x29, 0x92, 0x0c, 0x03, 0xcd, 0x49, 0xe4, 0xcc, 0xf7, 0xcd, 0xee,
	0x7c, 0xf3, 0x43, 0xa1, 0xfb, 0x3f, 0xf3, 0x5f, 0x58, 0xea, 0x8d, 0x1e, 0x78, 0x54, 0x8a, 0x01,
	0x1f, 0x7a, 0x34, 0xe6, 0x4c, 0x28, 0xf3, 0x13, 0x68, 0xa3, 0x9b, 0xa4, 0x52, 0x49, 0xfc, 0x31,
	0xcf, 0x14, 0x97, 0x2e, 0x30, 0xdc, 0xd1, 0x03, 0xd7, 0x38, 0x35, 0x74, 0xf7, 0xf6, 0x50, 0x0e,
	0x25, 0x00, 0xbd, 0xe2, 0x49, 0x73, 0x76, 0x9d, 0xa1, 0x94, 0xc3, 0x98, 0x79, 0xf0, 0xd6, 0xcf,
	0x07, 0x5e, 0x98, 0xa7, 0x44, 0x71, 0x29, 0x8c, 0x7f, 0xe7, 0xea, 0x7c, 0xa2, 0x54, 0xca, 0xfb,
	0xb9, 0x62, 0x99, 0x71, 0xdd, 0x5b, 0x72, 0x35, 0x92, 0xf0, 0x20, 0x4b, 0x18, 0x35, 0xb0, 0xd6,
	0x12, 0xd8, 0xf3, 0x5c, 0x2a, 0x62, 0x30, 0x9f, 0x2c, 0x0b, 0x95, 0xab, 0x48, 0x43, 0x5a, 0x7f,
	0x94, 0x51, 0xed, 0x84, 0xa5, 0x23, 0x4e, 0x59, 0x17, 0x30, 0xd8, 0x45, 0x8d, 0x90, 0x67, 0xa4,
	0x1f, 0xb3, 0x80, 0x46, 0x8c, 0x9e, 0x07, 0x94, 0xc4, 0x71, 0xd6, 0xb4, 0xf7, 0xec, 0xfd, 0x0f,
	0xfc, 0x6d, 0xe3, 0xea, 0x16, 0x9e, 0x6e, 0xe1, 0xc0, 0x5f, 0xa2, 0xdb, 0x13, 0x7c, 0xca, 0x12,
	0x99, 0x2a, 0x43, 0x58, 0x03, 0x02, 0x36, 0x3e, 0x1f, 0x5c, 0x9a, 0xd1, 0x43, 0x75, 0xb8, 0x58,
	0x30, 0xcd, 0xbd, 0x59, 0xda, 0xb3, 0xf7, 0xab, 0xed, 0x5d, 0x77, 0x4e, 0xeb, 0xce, 0x15, 0xc2,
	0xdf, 0x02, 0xe3, 0xd4, 0x80, 0x9f, 0xa0, 0x5a, 0xa4, 0x54, 0x12, 0x4c, 0x84, 0x69, 0x96, 0xf7,
	0x4a, 0xfb, 0xd5, 0xf6, 0x67, 0xee, 0xaa, 0x7a, 0xb9, 0x8f, 0x4e, 0x4f, 0x8f, 0x3b, 0xc7, 0x47,
	0x27, 0x09, 0xa3, 0x7e, 0xb5, 0xe0, 0x77, 0x12, 0x5e, 0xbc, 0xe0, 0x43, 0x84, 0x40, 0x3b, 0x1d,
	0x6b, 0x1d, 0x62, 0x7d, 0xba, 0x3a, 0xd6, 0x0f, 0x05, 0x1e, 0x22, 0x55, 0x9e, 0x4f, 0x1e, 0x71,
	0x8c, 0x1a, 0x4c, 0x84, 0x41, 0x9e, 0x15, 0x09, 0xe6, 0x2a, 0x12, 0x3a, 0xe0, 0x06, 0x24, 0xf8,
	0xed, 0xea, 0x80, 0x3d, 0x11, 0x9e, 0x65, 0x2c, 0xed, 0xe4, 0x2a, 0x62, 0x42, 0x71, 0x0a, 0x2d,
	0x73, 0x2c, 0x63, 0x4e, 0x2f, 0xe0, 0x98, 0x3a, 0x9b, 0x02, 0x04, 0x9c, 0x16, 0xa0, 0x86, 0x60,
	0xea, 0x85, 0x4c, 0xcf, 0x83, 0x01, 0xe1, 0x71, 0x90, 0x00, 0xb8, 0x79, 0x6b, 0xcf, 0xde, 0xdf,
	0x6c, 0x7b, 0xab, 0x4f, 0x7b, 0xaa, 0x89, 0x87, 0x84, 0xc7, 0xfa, 0x0c, 0x7f, 0x5b, 0xcc, 0x9b,
	0x5a, 0x7f, 0x96, 0xd0, 0xd6, 0x69, 0x4a, 0x44, 0x06, 0xf5, 0x5b, 0xda, 0x22, 0x34, 0x62, 0x8b,
	0x5b, 0x84, 0x46, 0xec, 0x6d, 0xbc, 0x96, 0x58, 0xe3, 0xd7, 0x66, 0xf0, 0x20, 0xa6, 0xc6, 0xbf,
	0xdb, 0x52, 0x7d, 0xa2, 0x68, 0x04, 0x4d, 0x32, 0xdf, 0x52, 0x07, 0x85, 0x67, 0x99, 0x0c, 0xe5,
	0xff, 0x4b, 0x06, 0xfc, 0x04, 0xdd, 0xc9, 0x14, 0x51, 0x59, 0x90, 0x27, 0x21, 0x51, 0x2c, 0xe0,
	0x42, 0xb1, 0x74, 0x44, 0xe2, 0xe6, 0x3a, 0xd4, 0x75, 0xc7, 0xd5, 0x03, 0xef, 0x4e, 0x06, 0xde,
	0x7d, 0x68, 0x06, 0xde, 0x6f, 0x00, 0xef, 0x0c, 0x68, 0x47, 0x86, 0x85, 0xef, 0xa2, 0x9a, 0x51,
	0x2e, 0xce, 0x33, 0xc5, 0x52, 0x68, 0x8f, 0x8a, 0xff, 0x21, 0x18, 0xbb, 0xda, 0x86, 0xef, 0xa1,
	0xcd, 0xc9, 0x44, 0x19, 0xd4, 0x2d, 0x40, 0xd5, 0xb4, 0xd5, 0xc0, 0x5a, 0xbf, 0x95, 0x51, 0xfd,
	0x91, 0x52, 0x49, 0x17, 0xd2, 0x31, 0x25, 0xfa, 0x1e, 0x55, 0xd4, 0xa4, 0x6a, 0x50, 0x98, 0x6a,
	0xfb, 0x8b, 0xd5, 0x32, 0xcc, 0x15, 0xd9, 0x9f, 0xf2, 0xf1, 0x39, 0xda, 0xca, 0xf4, 0x8e, 0x30,
	0x9b, 0xb1, 0x98, 0xee, 0x62, 0x3e, 0x0e, 0xae, 0x99, 0xb5, 0xb9, 0x5b, 0xb9, 0x33, 0x9b, 0x26,
	0xeb, 0x09, 0x95, 0x5e, 0xf8, 0x9b, 0xd9, 0x8c, 0x11, 0x7f, 0x87, 0x3e, 0x0a, 0xd9, 0x80, 0xe4,
	0xb1, 0x0a, 0x42, 0x96, 0x29, 0x2e, 0x40, 0xc6, 0xc0, 0xa0, 0xa0, 0x07, 0x2a, 0xfe, 0x8e, 0x81,
	0x3c, 0x9c, 0x22, 0x4c, 0xec, 0x85, 0xdb, 0xa5, 0x7c, 0xf3, 0xed, 0x72, 0x84, 0xf0, 0x40, 0xa6,
	0x2f, 0x48, 0x1a, 0xbe, 0x1d, 0x68, 0xfd, 0xda, 0x40, 0xdb, 0x86, 0x35, 0x35, 0xed, 0x0a, 0xd4,
	0x58, 0x90, 0x38, 0xae, 0xa3, 0xd2, 0x39, 0xbb, 0x80, 0xe2, 0x54, 0xfc, 0xe2, 0x11, 0x77, 0xd0,
	0xfa, 0x88, 0xc4, 0xb9, 0x9e, 0x8c, 0x6a, 0xfb, 0xf3, 0xd5, 0xea, 0xce, 0xc4, 0xf4, 0x35, 0xf3,
	0x9b, 0xb5, 0xaf, 0xed, 0xd6, 0xcb, 0x62, 0x64, 0xe9, 0x7b, 0xec, 0x87, 0x45, 0x12, 0xaf, 0xdd,
	0x5c, 0xe2, 0x25, 0x5f, 0x9a, 0xd2, 0x4d, 0xbf, 0x34, 0xe5, 0xa5, 0x5f, 0x9a, 0x9f, 0xd0, 0x1d,
	0x2a, 0x85, 0x60, 0x14, 0x5a, 0x68, 0x66, 0xbd, 0xdb, 0x37, 0x59, 0xef, 0x8d, 0x69, 0x94, 0x2b,
	0x23, 0x3e, 0x40, 0x5b, 0xe6, 0x1a, 0x57, 0xcb, 0x60, 0xe3, 0xba, 0x65, 0x60, 0x06, 0x7a, 0xb2,
	0x07, 0xee, 0xb7, 0xd1, 0xf6, 0x3b, 0xeb, 0x07, 0xd7, 0x50, 0xe5, 0xb0, 0x73, 0xf4, 0x38, 0x78,
	0x76, 0xdc, 0x7b, 0x5a, 0xb7, 0xf0, 0x26, 0x42, 0xf0, 0xda, 0x7d, 0xfc, 0xec, 0xa4, 0x57, 0xb7,
	0x0f, 0xce, 0x5e, 0x5d, 0x3a, 0xd6, 0xeb, 0x4b, 0xc7, 0xfa, 0xeb, 0xd2, 0xb1, 0xde, 0x5c, 0x3a,
	0xd6, 0xaf, 0x63, 0xc7, 0x7e, 0x39, 0x76, 0xac, 0x57, 0x63, 0xc7, 0x7e, 0x3d, 0x76, 0xec, 0xbf,
	0xc7, 0x8e, 0xfd, 0xef, 0xd8, 0xb1, 0xde, 0x8c, 0x1d, 0xfb, 0xf7, 0x7f, 0x1c, 0xeb, 0xc7, 0xbb,
	0x3a, 0x4d, 0x2e, 0x8b, 0x3f, 0x11, 0xde, 0xe2, 0x3f, 0x05, 0xfd, 0x0d, 0xb8, 0xed, 0x57, 0xff,
	0x05, 0x00, 0x00, 0xff, 0xff, 0x8a, 0x53, 0x04, 0xed, 0x1b, 0x09, 0x00, 0x00,
}
