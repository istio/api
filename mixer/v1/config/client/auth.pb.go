// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mixer/v1/config/client/auth.proto

package client

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import google_protobuf1 "github.com/gogo/protobuf/types"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// JSON Web Token (JWT) token format for authentication as defined by
// https://tools.ietf.org/html/rfc7519. See [OAuth
// 2.0](https://tools.ietf.org/html/rfc6749) and [OIDC
// 1.0](http://openid.net/connect) for how this is used in the whole
// authentication flow.
//
// Example,
//
//     issuer: https://example.com
//     audiences:
//     - bookstore_android.apps.googleusercontent.com
//       bookstore_web.apps.googleusercontent.com
//     jwks_uri: https://example.com/.well-known/jwks.json
//
type JWT struct {
	// Identifies the principal that issued the JWT. See
	// https://tools.ietf.org/html/rfc7519#section-4.1.1
	// Usually a URL or an email address.
	//
	// Example: https://securetoken.google.com
	// Example: 1234567-compute@developer.gserviceaccount.com
	//
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// The list of JWT
	// [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3).
	// that are allowed to access. A JWT containing any of these
	// audiences will be accepted.
	//
	// The service name will be accepted if audiences is empty.
	//
	// Example:
	//
	//     audiences:
	//     - bookstore_android.apps.googleusercontent.com
	//       bookstore_web.apps.googleusercontent.com
	//
	Audiences []string `protobuf:"bytes,2,rep,name=audiences" json:"audiences,omitempty"`
	// URL of the provider's public key set to validate signature of the
	// JWT. See [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
	//
	// Optional if the key set document can either (a) be retrieved from
	// [OpenID Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)
	// of the issuer or (b) inferred from the email domain of the issuer
	// (e.g. a Google service account).
	//
	// Example: https://www.googleapis.com/oauth2/v1/certs
	JwksUri string `protobuf:"bytes,3,opt,name=jwks_uri,json=jwksUri,proto3" json:"jwks_uri,omitempty"`
	// If true, forward the entire base64 encoded JWT in the HTTP request.
	// If false, remove the JWT from the HTTP request and do not forward to the application.
	ForwardJwt bool `protobuf:"varint,4,opt,name=forward_jwt,json=forwardJwt,proto3" json:"forward_jwt,omitempty"`
	// Duration after which the cached public key should be expired. The
	// system wide default is applied if no duration is explicitly
	// specified.
	PublicKeyCacheDuration *google_protobuf1.Duration `protobuf:"bytes,5,opt,name=public_key_cache_duration,json=publicKeyCacheDuration" json:"public_key_cache_duration,omitempty"`
	Locations              []*JWT_Location            `protobuf:"bytes,6,rep,name=locations" json:"locations,omitempty"`
	// This field is specific for Envoy proxy implementation.
	// It is the cluster name in the Envoy config for the jwks_uri.
	JwksUriEnvoyCluster string `protobuf:"bytes,7,opt,name=jwks_uri_envoy_cluster,json=jwksUriEnvoyCluster,proto3" json:"jwks_uri_envoy_cluster,omitempty"`
}

func (m *JWT) Reset()                    { *m = JWT{} }
func (*JWT) ProtoMessage()               {}
func (*JWT) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{0} }

// Defines where to extract the JWT from an HTTP request.
//
// If no explicit location is specified the following default
// locations are tried in order:
//
//     1) The Authorization header using the Bearer schema,
//        e.g. Authorization: Bearer <token>. (see
//        https://tools.ietf.org/html/rfc6750#section-2.1)
//
//     2) `access_token` query parameter (see
//     https://tools.ietf.org/html/rfc6750#section-2.3)
//
type JWT_Location struct {
	// Types that are valid to be assigned to Scheme:
	//	*JWT_Location_Header
	//	*JWT_Location_Query
	Scheme isJWT_Location_Scheme `protobuf_oneof:"scheme"`
}

func (m *JWT_Location) Reset()                    { *m = JWT_Location{} }
func (*JWT_Location) ProtoMessage()               {}
func (*JWT_Location) Descriptor() ([]byte, []int) { return fileDescriptorAuth, []int{0, 0} }

type isJWT_Location_Scheme interface {
	isJWT_Location_Scheme()
	MarshalTo([]byte) (int, error)
	Size() int
}

type JWT_Location_Header struct {
	Header string `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}
type JWT_Location_Query struct {
	Query string `protobuf:"bytes,2,opt,name=query,proto3,oneof"`
}

func (*JWT_Location_Header) isJWT_Location_Scheme() {}
func (*JWT_Location_Query) isJWT_Location_Scheme()  {}

func (m *JWT_Location) GetScheme() isJWT_Location_Scheme {
	if m != nil {
		return m.Scheme
	}
	return nil
}

func (m *JWT_Location) GetHeader() string {
	if x, ok := m.GetScheme().(*JWT_Location_Header); ok {
		return x.Header
	}
	return ""
}

func (m *JWT_Location) GetQuery() string {
	if x, ok := m.GetScheme().(*JWT_Location_Query); ok {
		return x.Query
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*JWT_Location) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _JWT_Location_OneofMarshaler, _JWT_Location_OneofUnmarshaler, _JWT_Location_OneofSizer, []interface{}{
		(*JWT_Location_Header)(nil),
		(*JWT_Location_Query)(nil),
	}
}

func _JWT_Location_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*JWT_Location)
	// scheme
	switch x := m.Scheme.(type) {
	case *JWT_Location_Header:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Header)
	case *JWT_Location_Query:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Query)
	case nil:
	default:
		return fmt.Errorf("JWT_Location.Scheme has unexpected type %T", x)
	}
	return nil
}

func _JWT_Location_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*JWT_Location)
	switch tag {
	case 1: // scheme.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Scheme = &JWT_Location_Header{x}
		return true, err
	case 2: // scheme.query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Scheme = &JWT_Location_Query{x}
		return true, err
	default:
		return false, nil
	}
}

func _JWT_Location_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*JWT_Location)
	// scheme
	switch x := m.Scheme.(type) {
	case *JWT_Location_Header:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Header)))
		n += len(x.Header)
	case *JWT_Location_Query:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Query)))
		n += len(x.Query)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Determines how to apply auth policies for individual requests.
type EndUserAuthenticationPolicySpec struct {
	// List of JWT rules to valide.
	//
	// If the request includes a JWT it must match one of the JWT listed
	// here matched by the issuer. If validation is successfull the
	// follow attributes are included in requests to the mixer:
	//
	//     request.auth.principal - The string of the issuer (`iss`) and
	//     subject (`sub`) claims within a JWT concatenated with “/”
	//     with a percent-encoded subject value
	//
	//     request.auth.audiences - This should reflect the audience
	//     (`aud`) claim within matched JWT.
	//
	//     request.auth.presenter - The authorized presenter of the
	//     credential. This value should reflect the optional Authorized
	//     Presenter (`azp`) claim within a JWT
	//
	// If no match is found the request is rejected with HTTP status
	// code 401.
	//
	// JWT validation is skipped if the user's traffic request does not
	// include a JWT.
	Jwts []*JWT `protobuf:"bytes,2,rep,name=jwts" json:"jwts,omitempty"`
	// If a request doesn't have JWT, it will be rejected.
	// But some requests are OK without JWT, such as OPTIONS for CORS,
	// or some paths for health checking.
	// If a request matches any of no_jwt_patterns, it is OK without JWT.
	NoJwtPatterns []*EndUserAuthenticationPolicySpec_Pattern `protobuf:"bytes,3,rep,name=no_jwt_patterns,json=noJwtPatterns" json:"no_jwt_patterns,omitempty"`
}

func (m *EndUserAuthenticationPolicySpec) Reset()      { *m = EndUserAuthenticationPolicySpec{} }
func (*EndUserAuthenticationPolicySpec) ProtoMessage() {}
func (*EndUserAuthenticationPolicySpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{1}
}

// This message defines a pattern to match a request.
// A pattern is matched only if both http_method and path_prefix are matched.
type EndUserAuthenticationPolicySpec_Pattern struct {
	// Define a HTTP method.
	HttpMethod string `protobuf:"bytes,1,opt,name=http_method,json=httpMethod,proto3" json:"http_method,omitempty"`
	// Defines a path prefix to match
	PathPrefix string `protobuf:"bytes,2,opt,name=path_prefix,json=pathPrefix,proto3" json:"path_prefix,omitempty"`
}

func (m *EndUserAuthenticationPolicySpec_Pattern) Reset() {
	*m = EndUserAuthenticationPolicySpec_Pattern{}
}
func (*EndUserAuthenticationPolicySpec_Pattern) ProtoMessage() {}
func (*EndUserAuthenticationPolicySpec_Pattern) Descriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{1, 0}
}

type EndUserAuthenticationPolicySpecReference struct {
	// REQUIRED. The short name of the
	// EndUserAuthenticationPolicySpec. This is the resource name
	// defined by the metadata name field.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional namespace of the
	// EndUserAuthenticationPolicySpec. Defaults to the value of the
	// metadata namespace field.
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *EndUserAuthenticationPolicySpecReference) Reset() {
	*m = EndUserAuthenticationPolicySpecReference{}
}
func (*EndUserAuthenticationPolicySpecReference) ProtoMessage() {}
func (*EndUserAuthenticationPolicySpecReference) Descriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{2}
}

// EndUserAuthenticationPolicySpecBinding defines the binding between
// EndUserAuthenticationPolicySpecs and one or more IstioService.
type EndUserAuthenticationPolicySpecBinding struct {
	// REQUIRED. One or more services to map the listed
	// EndUserAuthenticationPolicySpecs onto.
	Services []*IstioService `protobuf:"bytes,1,rep,name=services" json:"services,omitempty"`
	// REQUIRED. One or more EndUserAuthenticationPolicySpecReference
	// that should be mapped to the specified service(s).
	Policies []*EndUserAuthenticationPolicySpecReference `protobuf:"bytes,2,rep,name=policies" json:"policies,omitempty"`
}

func (m *EndUserAuthenticationPolicySpecBinding) Reset() {
	*m = EndUserAuthenticationPolicySpecBinding{}
}
func (*EndUserAuthenticationPolicySpecBinding) ProtoMessage() {}
func (*EndUserAuthenticationPolicySpecBinding) Descriptor() ([]byte, []int) {
	return fileDescriptorAuth, []int{3}
}

func init() {
	proto.RegisterType((*JWT)(nil), "istio.mixer.v1.config.client.JWT")
	proto.RegisterType((*JWT_Location)(nil), "istio.mixer.v1.config.client.JWT.Location")
	proto.RegisterType((*EndUserAuthenticationPolicySpec)(nil), "istio.mixer.v1.config.client.EndUserAuthenticationPolicySpec")
	proto.RegisterType((*EndUserAuthenticationPolicySpec_Pattern)(nil), "istio.mixer.v1.config.client.EndUserAuthenticationPolicySpec.Pattern")
	proto.RegisterType((*EndUserAuthenticationPolicySpecReference)(nil), "istio.mixer.v1.config.client.EndUserAuthenticationPolicySpecReference")
	proto.RegisterType((*EndUserAuthenticationPolicySpecBinding)(nil), "istio.mixer.v1.config.client.EndUserAuthenticationPolicySpecBinding")
}
func (m *JWT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JWT) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Issuer)))
		i += copy(dAtA[i:], m.Issuer)
	}
	if len(m.Audiences) > 0 {
		for _, s := range m.Audiences {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.JwksUri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.JwksUri)))
		i += copy(dAtA[i:], m.JwksUri)
	}
	if m.ForwardJwt {
		dAtA[i] = 0x20
		i++
		if m.ForwardJwt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PublicKeyCacheDuration != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(m.PublicKeyCacheDuration.Size()))
		n1, err := m.PublicKeyCacheDuration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x32
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.JwksUriEnvoyCluster) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.JwksUriEnvoyCluster)))
		i += copy(dAtA[i:], m.JwksUriEnvoyCluster)
	}
	return i, nil
}

func (m *JWT_Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JWT_Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Scheme != nil {
		nn2, err := m.Scheme.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *JWT_Location_Header) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintAuth(dAtA, i, uint64(len(m.Header)))
	i += copy(dAtA[i:], m.Header)
	return i, nil
}
func (m *JWT_Location_Query) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintAuth(dAtA, i, uint64(len(m.Query)))
	i += copy(dAtA[i:], m.Query)
	return i, nil
}
func (m *EndUserAuthenticationPolicySpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndUserAuthenticationPolicySpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jwts) > 0 {
		for _, msg := range m.Jwts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NoJwtPatterns) > 0 {
		for _, msg := range m.NoJwtPatterns {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndUserAuthenticationPolicySpec_Pattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndUserAuthenticationPolicySpec_Pattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HttpMethod) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.HttpMethod)))
		i += copy(dAtA[i:], m.HttpMethod)
	}
	if len(m.PathPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.PathPrefix)))
		i += copy(dAtA[i:], m.PathPrefix)
	}
	return i, nil
}

func (m *EndUserAuthenticationPolicySpecReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndUserAuthenticationPolicySpecReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuth(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func (m *EndUserAuthenticationPolicySpecBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndUserAuthenticationPolicySpecBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAuth(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAuth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *JWT) Size() (n int) {
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.Audiences) > 0 {
		for _, s := range m.Audiences {
			l = len(s)
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	l = len(m.JwksUri)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	if m.ForwardJwt {
		n += 2
	}
	if m.PublicKeyCacheDuration != nil {
		l = m.PublicKeyCacheDuration.Size()
		n += 1 + l + sovAuth(uint64(l))
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	l = len(m.JwksUriEnvoyCluster)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *JWT_Location) Size() (n int) {
	var l int
	_ = l
	if m.Scheme != nil {
		n += m.Scheme.Size()
	}
	return n
}

func (m *JWT_Location_Header) Size() (n int) {
	var l int
	_ = l
	l = len(m.Header)
	n += 1 + l + sovAuth(uint64(l))
	return n
}
func (m *JWT_Location_Query) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	n += 1 + l + sovAuth(uint64(l))
	return n
}
func (m *EndUserAuthenticationPolicySpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Jwts) > 0 {
		for _, e := range m.Jwts {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.NoJwtPatterns) > 0 {
		for _, e := range m.NoJwtPatterns {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func (m *EndUserAuthenticationPolicySpec_Pattern) Size() (n int) {
	var l int
	_ = l
	l = len(m.HttpMethod)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.PathPrefix)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *EndUserAuthenticationPolicySpecReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAuth(uint64(l))
	}
	return n
}

func (m *EndUserAuthenticationPolicySpecBinding) Size() (n int) {
	var l int
	_ = l
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovAuth(uint64(l))
		}
	}
	return n
}

func sovAuth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuth(x uint64) (n int) {
	return sovAuth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *JWT) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JWT{`,
		`Issuer:` + fmt.Sprintf("%v", this.Issuer) + `,`,
		`Audiences:` + fmt.Sprintf("%v", this.Audiences) + `,`,
		`JwksUri:` + fmt.Sprintf("%v", this.JwksUri) + `,`,
		`ForwardJwt:` + fmt.Sprintf("%v", this.ForwardJwt) + `,`,
		`PublicKeyCacheDuration:` + strings.Replace(fmt.Sprintf("%v", this.PublicKeyCacheDuration), "Duration", "google_protobuf1.Duration", 1) + `,`,
		`Locations:` + strings.Replace(fmt.Sprintf("%v", this.Locations), "JWT_Location", "JWT_Location", 1) + `,`,
		`JwksUriEnvoyCluster:` + fmt.Sprintf("%v", this.JwksUriEnvoyCluster) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JWT_Location) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JWT_Location{`,
		`Scheme:` + fmt.Sprintf("%v", this.Scheme) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JWT_Location_Header) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JWT_Location_Header{`,
		`Header:` + fmt.Sprintf("%v", this.Header) + `,`,
		`}`,
	}, "")
	return s
}
func (this *JWT_Location_Query) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&JWT_Location_Query{`,
		`Query:` + fmt.Sprintf("%v", this.Query) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndUserAuthenticationPolicySpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndUserAuthenticationPolicySpec{`,
		`Jwts:` + strings.Replace(fmt.Sprintf("%v", this.Jwts), "JWT", "JWT", 1) + `,`,
		`NoJwtPatterns:` + strings.Replace(fmt.Sprintf("%v", this.NoJwtPatterns), "EndUserAuthenticationPolicySpec_Pattern", "EndUserAuthenticationPolicySpec_Pattern", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndUserAuthenticationPolicySpec_Pattern) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndUserAuthenticationPolicySpec_Pattern{`,
		`HttpMethod:` + fmt.Sprintf("%v", this.HttpMethod) + `,`,
		`PathPrefix:` + fmt.Sprintf("%v", this.PathPrefix) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndUserAuthenticationPolicySpecReference) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndUserAuthenticationPolicySpecReference{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Namespace:` + fmt.Sprintf("%v", this.Namespace) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EndUserAuthenticationPolicySpecBinding) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EndUserAuthenticationPolicySpecBinding{`,
		`Services:` + strings.Replace(fmt.Sprintf("%v", this.Services), "IstioService", "IstioService", 1) + `,`,
		`Policies:` + strings.Replace(fmt.Sprintf("%v", this.Policies), "EndUserAuthenticationPolicySpecReference", "EndUserAuthenticationPolicySpecReference", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringAuth(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *JWT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JWT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JWT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audiences", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audiences = append(m.Audiences, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwksUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwksUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardJwt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForwardJwt = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyCacheDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicKeyCacheDuration == nil {
				m.PublicKeyCacheDuration = &google_protobuf1.Duration{}
			}
			if err := m.PublicKeyCacheDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &JWT_Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JwksUriEnvoyCluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JwksUriEnvoyCluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JWT_Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = &JWT_Location_Header{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scheme = &JWT_Location_Query{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndUserAuthenticationPolicySpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jwts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jwts = append(m.Jwts, &JWT{})
			if err := m.Jwts[len(m.Jwts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoJwtPatterns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoJwtPatterns = append(m.NoJwtPatterns, &EndUserAuthenticationPolicySpec_Pattern{})
			if err := m.NoJwtPatterns[len(m.NoJwtPatterns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndUserAuthenticationPolicySpec_Pattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndUserAuthenticationPolicySpecReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpecReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpecReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndUserAuthenticationPolicySpecBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpecBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndUserAuthenticationPolicySpecBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &IstioService{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &EndUserAuthenticationPolicySpecReference{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuth   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mixer/v1/config/client/auth.proto", fileDescriptorAuth) }

var fileDescriptorAuth = []byte{
	// 648 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xc1, 0x4e, 0xdb, 0x4a,
	0x14, 0xb5, 0x09, 0x84, 0x64, 0xa2, 0xa7, 0x27, 0xcd, 0x7b, 0x8a, 0x4c, 0x84, 0x4c, 0x48, 0xab,
	0x2a, 0xea, 0xc2, 0x16, 0xa0, 0x7e, 0x40, 0xa1, 0x20, 0x1a, 0x5a, 0x09, 0x19, 0x10, 0x52, 0x55,
	0xc9, 0x72, 0xec, 0x9b, 0x78, 0x20, 0xf1, 0xb8, 0x33, 0xe3, 0x84, 0xec, 0xfa, 0x09, 0x5d, 0xf0,
	0x11, 0xfd, 0x14, 0x96, 0x2c, 0xba, 0xe8, 0xb2, 0x71, 0x37, 0x5d, 0xf2, 0x09, 0xd5, 0x78, 0xc6,
	0xb0, 0x69, 0x49, 0xa5, 0xae, 0x32, 0xf7, 0xdc, 0x73, 0x8e, 0xe7, 0xcc, 0xdc, 0x09, 0xda, 0x1c,
	0x93, 0x2b, 0x60, 0xee, 0x64, 0xcb, 0x0d, 0x69, 0x32, 0x20, 0x43, 0x37, 0x1c, 0x11, 0x48, 0x84,
	0x1b, 0x64, 0x22, 0x76, 0x52, 0x46, 0x05, 0xc5, 0xeb, 0x84, 0x0b, 0x42, 0x9d, 0x82, 0xe8, 0x4c,
	0xb6, 0x1c, 0x45, 0x74, 0x14, 0xb1, 0xf5, 0xff, 0x90, 0x0e, 0x69, 0x41, 0x74, 0xe5, 0x4a, 0x69,
	0x5a, 0xf6, 0x90, 0xd2, 0xe1, 0x08, 0xdc, 0xa2, 0xea, 0x67, 0x03, 0x37, 0xca, 0x58, 0x20, 0x08,
	0x4d, 0x74, 0xff, 0xe9, 0x6f, 0x3e, 0xcb, 0x81, 0x4d, 0x48, 0x08, 0x8a, 0xd5, 0xb9, 0xae, 0xa0,
	0x4a, 0xef, 0xfc, 0x14, 0x37, 0x51, 0x95, 0x70, 0x9e, 0x01, 0xb3, 0xcc, 0xb6, 0xd9, 0xad, 0x7b,
	0xba, 0xc2, 0xeb, 0xa8, 0x1e, 0x64, 0x11, 0x81, 0x24, 0x04, 0x6e, 0x2d, 0xb5, 0x2b, 0xdd, 0xba,
	0xf7, 0x00, 0xe0, 0x35, 0x54, 0xbb, 0x98, 0x5e, 0x72, 0x3f, 0x63, 0xc4, 0xaa, 0x14, 0xba, 0x55,
	0x59, 0x9f, 0x31, 0x82, 0x37, 0x50, 0x63, 0x40, 0xd9, 0x34, 0x60, 0x91, 0x7f, 0x31, 0x15, 0xd6,
	0x72, 0xdb, 0xec, 0xd6, 0x3c, 0xa4, 0xa1, 0xde, 0x54, 0xe0, 0x53, 0xb4, 0x96, 0x66, 0xfd, 0x11,
	0x09, 0xfd, 0x4b, 0x98, 0xf9, 0x61, 0x10, 0xc6, 0xe0, 0x97, 0x11, 0xac, 0x95, 0xb6, 0xd9, 0x6d,
	0x6c, 0xaf, 0x39, 0x2a, 0xa3, 0x53, 0x66, 0x74, 0x5e, 0x69, 0x82, 0xd7, 0x54, 0xda, 0x23, 0x98,
	0xed, 0x49, 0x65, 0x89, 0xe3, 0x43, 0x54, 0x1f, 0xd1, 0xb0, 0x58, 0x73, 0xab, 0xda, 0xae, 0x74,
	0x1b, 0xdb, 0xcf, 0x9d, 0xc7, 0x4e, 0xd7, 0xe9, 0x9d, 0x9f, 0x3a, 0x6f, 0xb4, 0xc4, 0x7b, 0x10,
	0xe3, 0x1d, 0xd4, 0x2c, 0xb3, 0xf9, 0x90, 0x4c, 0xe8, 0xcc, 0x0f, 0x47, 0x19, 0x17, 0xc0, 0xac,
	0xd5, 0x22, 0xe9, 0x7f, 0x3a, 0xe9, 0xbe, 0xec, 0xed, 0xa9, 0x56, 0xeb, 0x00, 0xd5, 0x4a, 0x2f,
	0x6c, 0xa1, 0x6a, 0x0c, 0x41, 0x54, 0x1e, 0xe9, 0xa1, 0xe1, 0xe9, 0x1a, 0x37, 0xd1, 0xca, 0x87,
	0x0c, 0xd8, 0xcc, 0x5a, 0xd2, 0x0d, 0x55, 0xee, 0xd6, 0x50, 0x95, 0x87, 0x31, 0x8c, 0xa1, 0x73,
	0xbd, 0x84, 0x36, 0xf6, 0x93, 0xe8, 0x8c, 0x03, 0x7b, 0x99, 0x89, 0x18, 0x12, 0x41, 0x94, 0xeb,
	0x31, 0x1d, 0x91, 0x70, 0x76, 0x92, 0x42, 0x88, 0x5f, 0xa0, 0xe5, 0x8b, 0xa9, 0x50, 0xb7, 0xd2,
	0xd8, 0xde, 0x5c, 0x98, 0xd2, 0x2b, 0xe8, 0x78, 0x8c, 0xfe, 0x4d, 0xa8, 0xbc, 0x13, 0x3f, 0x0d,
	0x84, 0x00, 0x96, 0x70, 0xab, 0x52, 0x38, 0xec, 0x3f, 0xee, 0xb0, 0x60, 0x3b, 0xce, 0xb1, 0x72,
	0xf3, 0xfe, 0x49, 0x68, 0x6f, 0x2a, 0x74, 0xc5, 0x5b, 0x47, 0x68, 0x55, 0xaf, 0xe5, 0x48, 0xc4,
	0x42, 0xa4, 0xfe, 0x18, 0x44, 0x4c, 0x23, 0x3d, 0x68, 0x48, 0x42, 0x6f, 0x0b, 0x44, 0x12, 0xd2,
	0x40, 0xc4, 0x7e, 0xca, 0x60, 0x40, 0xae, 0xd4, 0xe9, 0x78, 0x48, 0x42, 0xc7, 0x05, 0xd2, 0x79,
	0x8f, 0xba, 0x0b, 0xb6, 0xe1, 0xc1, 0x00, 0x98, 0x1c, 0x4e, 0x8c, 0xd1, 0x72, 0x12, 0x8c, 0x41,
	0x7f, 0xa6, 0x58, 0xcb, 0x69, 0x96, 0xbf, 0x3c, 0x0d, 0x42, 0xd0, 0xf6, 0x0f, 0x40, 0xe7, 0x8b,
	0x89, 0x9e, 0x2d, 0xb0, 0xdf, 0x25, 0x49, 0x44, 0x92, 0x21, 0x3e, 0x40, 0x35, 0xfd, 0x8e, 0xb8,
	0x65, 0xfe, 0xc9, 0x94, 0xbd, 0x96, 0xcd, 0x13, 0x25, 0xf1, 0xee, 0xb5, 0xb8, 0x8f, 0x6a, 0xa9,
	0x34, 0x27, 0x50, 0xde, 0xe3, 0xc1, 0x5f, 0xdd, 0xc2, 0x7d, 0x7c, 0xef, 0xde, 0x77, 0xf7, 0xec,
	0x66, 0x6e, 0x1b, 0xb7, 0x73, 0xdb, 0xf8, 0x3a, 0xb7, 0x8d, 0xbb, 0xb9, 0x6d, 0x7c, 0xcc, 0x6d,
	0xf3, 0x73, 0x6e, 0x1b, 0x37, 0xb9, 0x6d, 0xde, 0xe6, 0xb6, 0xf9, 0x2d, 0xb7, 0xcd, 0x1f, 0xb9,
	0x6d, 0xdc, 0xe5, 0xb6, 0xf9, 0xe9, 0xbb, 0x6d, 0xbc, 0x7b, 0xa2, 0xb6, 0x40, 0xa8, 0x1b, 0xa4,
	0xc4, 0xfd, 0xf5, 0xff, 0x48, 0xbf, 0x5a, 0x3c, 0xca, 0x9d, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x56, 0x8e, 0x4e, 0xe7, 0xdf, 0x04, 0x00, 0x00,
}
