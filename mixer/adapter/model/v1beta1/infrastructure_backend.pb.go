// Code generated by protoc-gen-gogo. DO NOT EDIT.
// mixer/adapter/model/v1beta1/infrastructure_backend.proto is a deprecated file.

// This package defines the service and types used by adapter code to serve requests from Mixer.
// This package also defines the types that are used to create Mixer templates.

package v1beta1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	rpc "istio.io/gogo-genproto/googleapis/google/rpc"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Request message for `CreateSession` method.
type CreateSessionRequest struct {
	// Adapter specific configuration.
	AdapterConfig *types.Any `protobuf:"bytes,1,opt,name=adapter_config,json=adapterConfig,proto3" json:"adapter_config,omitempty"`
	// Map of instance names to their template-specific inferred type.
	InferredTypes map[string]*types.Any `protobuf:"bytes,2,rep,name=inferred_types,json=inferredTypes,proto3" json:"inferred_types,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CreateSessionRequest) Reset()      { *m = CreateSessionRequest{} }
func (*CreateSessionRequest) ProtoMessage() {}
func (*CreateSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{0}
}
func (m *CreateSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSessionRequest.Merge(m, src)
}
func (m *CreateSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSessionRequest proto.InternalMessageInfo

func (m *CreateSessionRequest) GetAdapterConfig() *types.Any {
	if m != nil {
		return m.AdapterConfig
	}
	return nil
}

func (m *CreateSessionRequest) GetInferredTypes() map[string]*types.Any {
	if m != nil {
		return m.InferredTypes
	}
	return nil
}

// Response message for `CreateSession` method.
type CreateSessionResponse struct {
	// Id of the created session.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// The success/failure status of create session call.
	Status *rpc.Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *CreateSessionResponse) Reset()      { *m = CreateSessionResponse{} }
func (*CreateSessionResponse) ProtoMessage() {}
func (*CreateSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{1}
}
func (m *CreateSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSessionResponse.Merge(m, src)
}
func (m *CreateSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSessionResponse proto.InternalMessageInfo

func (m *CreateSessionResponse) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *CreateSessionResponse) GetStatus() *rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request message for `Validate` method.
type ValidateRequest struct {
	// Adapter specific configuration.
	AdapterConfig *types.Any `protobuf:"bytes,1,opt,name=adapter_config,json=adapterConfig,proto3" json:"adapter_config,omitempty"`
	// Map of instance names to their template-specific inferred type.
	InferredTypes map[string]*types.Any `protobuf:"bytes,2,rep,name=inferred_types,json=inferredTypes,proto3" json:"inferred_types,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ValidateRequest) Reset()      { *m = ValidateRequest{} }
func (*ValidateRequest) ProtoMessage() {}
func (*ValidateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{2}
}
func (m *ValidateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateRequest.Merge(m, src)
}
func (m *ValidateRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateRequest proto.InternalMessageInfo

func (m *ValidateRequest) GetAdapterConfig() *types.Any {
	if m != nil {
		return m.AdapterConfig
	}
	return nil
}

func (m *ValidateRequest) GetInferredTypes() map[string]*types.Any {
	if m != nil {
		return m.InferredTypes
	}
	return nil
}

// Response message for `Validate` method.
type ValidateResponse struct {
	// The success/failure status of validation call.
	Status *rpc.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ValidateResponse) Reset()      { *m = ValidateResponse{} }
func (*ValidateResponse) ProtoMessage() {}
func (*ValidateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{3}
}
func (m *ValidateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidateResponse.Merge(m, src)
}
func (m *ValidateResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidateResponse proto.InternalMessageInfo

func (m *ValidateResponse) GetStatus() *rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Request message for `CloseSession` method.
type CloseSessionRequest struct {
	// Id of the session to be closed.
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *CloseSessionRequest) Reset()      { *m = CloseSessionRequest{} }
func (*CloseSessionRequest) ProtoMessage() {}
func (*CloseSessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{4}
}
func (m *CloseSessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionRequest.Merge(m, src)
}
func (m *CloseSessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionRequest proto.InternalMessageInfo

func (m *CloseSessionRequest) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

// Response message for `CloseSession` method.
type CloseSessionResponse struct {
	// The success/failure status of close session call.
	Status *rpc.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *CloseSessionResponse) Reset()      { *m = CloseSessionResponse{} }
func (*CloseSessionResponse) ProtoMessage() {}
func (*CloseSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b62a0b3a6ebb4b55, []int{5}
}
func (m *CloseSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseSessionResponse.Merge(m, src)
}
func (m *CloseSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *CloseSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CloseSessionResponse proto.InternalMessageInfo

func (m *CloseSessionResponse) GetStatus() *rpc.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func init() {
	proto.RegisterType((*CreateSessionRequest)(nil), "istio.mixer.adapter.model.v1beta1.CreateSessionRequest")
	proto.RegisterMapType((map[string]*types.Any)(nil), "istio.mixer.adapter.model.v1beta1.CreateSessionRequest.InferredTypesEntry")
	proto.RegisterType((*CreateSessionResponse)(nil), "istio.mixer.adapter.model.v1beta1.CreateSessionResponse")
	proto.RegisterType((*ValidateRequest)(nil), "istio.mixer.adapter.model.v1beta1.ValidateRequest")
	proto.RegisterMapType((map[string]*types.Any)(nil), "istio.mixer.adapter.model.v1beta1.ValidateRequest.InferredTypesEntry")
	proto.RegisterType((*ValidateResponse)(nil), "istio.mixer.adapter.model.v1beta1.ValidateResponse")
	proto.RegisterType((*CloseSessionRequest)(nil), "istio.mixer.adapter.model.v1beta1.CloseSessionRequest")
	proto.RegisterType((*CloseSessionResponse)(nil), "istio.mixer.adapter.model.v1beta1.CloseSessionResponse")
}

func init() {
	proto.RegisterFile("mixer/adapter/model/v1beta1/infrastructure_backend.proto", fileDescriptor_b62a0b3a6ebb4b55)
}

var fileDescriptor_b62a0b3a6ebb4b55 = []byte{
	// 542 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x54, 0x31, 0x6f, 0xd3, 0x40,
	0x14, 0xf6, 0x39, 0xa2, 0xa2, 0x57, 0x5a, 0xaa, 0x23, 0x15, 0xc1, 0x12, 0xa7, 0x92, 0x29, 0xea,
	0x70, 0x56, 0x53, 0x44, 0x23, 0x90, 0x90, 0x48, 0xd4, 0x21, 0x8c, 0x29, 0xea, 0xc0, 0x12, 0x5d,
	0xec, 0x4b, 0x74, 0xaa, 0xeb, 0x73, 0xef, 0xce, 0x55, 0xbd, 0x75, 0x40, 0x82, 0x91, 0x81, 0x99,
	0x81, 0x89, 0x9f, 0xc0, 0x4f, 0x60, 0xcc, 0xd8, 0x91, 0x38, 0x0b, 0x63, 0x7f, 0x02, 0xaa, 0x7d,
	0x51, 0x93, 0x14, 0xd2, 0x1a, 0x21, 0xb1, 0x59, 0xf7, 0xde, 0xf7, 0xbe, 0xef, 0x7d, 0xef, 0x3d,
	0xc3, 0xc6, 0x11, 0x3f, 0x65, 0xd2, 0xa5, 0x3e, 0x8d, 0x34, 0x93, 0xee, 0x91, 0xf0, 0x59, 0xe0,
	0x9e, 0x6c, 0xf7, 0x98, 0xa6, 0xdb, 0x2e, 0x0f, 0xfb, 0x92, 0x2a, 0x2d, 0x63, 0x4f, 0xc7, 0x92,
	0x75, 0x7b, 0xd4, 0x3b, 0x64, 0xa1, 0x4f, 0x22, 0x29, 0xb4, 0x40, 0x4f, 0xb8, 0xd2, 0x5c, 0x90,
	0x0c, 0x4f, 0x0c, 0x9e, 0x64, 0x78, 0x62, 0xf0, 0xce, 0xa3, 0x81, 0x10, 0x83, 0x80, 0xb9, 0x19,
	0xa0, 0x17, 0xf7, 0x5d, 0x1a, 0x26, 0x39, 0xda, 0x79, 0x68, 0x42, 0x32, 0xf2, 0x5c, 0xa5, 0xa9,
	0x8e, 0x55, 0x1e, 0xa8, 0x7e, 0xb6, 0x61, 0xb9, 0x25, 0x19, 0xd5, 0x6c, 0x9f, 0x29, 0xc5, 0x45,
	0xd8, 0x61, 0xc7, 0x31, 0x53, 0x1a, 0xbd, 0x80, 0x6b, 0x86, 0xa5, 0xeb, 0x89, 0xb0, 0xcf, 0x07,
	0x15, 0xb0, 0x09, 0x6a, 0x2b, 0xf5, 0x32, 0xc9, 0x4b, 0x91, 0x09, 0x0b, 0x79, 0x15, 0x26, 0x9d,
	0x55, 0x93, 0xdb, 0xca, 0x52, 0xd1, 0x31, 0x5c, 0xe3, 0x61, 0x9f, 0x49, 0xc9, 0xfc, 0xae, 0x4e,
	0x22, 0xa6, 0x2a, 0xf6, 0x66, 0xa9, 0xb6, 0x52, 0x7f, 0x4d, 0x6e, 0xec, 0x82, 0xfc, 0x4e, 0x0d,
	0x69, 0x9b, 0x6a, 0x6f, 0x2e, 0x8b, 0xed, 0x85, 0x5a, 0x26, 0x9d, 0x55, 0x3e, 0xfd, 0xe6, 0x1c,
	0x40, 0x74, 0x3d, 0x09, 0xad, 0xc3, 0xd2, 0x21, 0x4b, 0x32, 0xe9, 0xcb, 0x9d, 0xcb, 0x4f, 0xb4,
	0x05, 0xef, 0x9c, 0xd0, 0x20, 0x66, 0x15, 0x7b, 0x41, 0x3b, 0x79, 0xca, 0x73, 0xbb, 0x01, 0xaa,
	0x3d, 0xb8, 0x31, 0xa7, 0x48, 0x45, 0x22, 0x54, 0x0c, 0x3d, 0x86, 0x50, 0xe5, 0x4f, 0x5d, 0xee,
	0x1b, 0x86, 0x65, 0xf3, 0xd2, 0xf6, 0xd1, 0x16, 0x5c, 0xca, 0x8d, 0x36, 0x44, 0x68, 0x42, 0x24,
	0x23, 0x8f, 0xec, 0x67, 0x91, 0x8e, 0xc9, 0xa8, 0x7e, 0xb2, 0xe1, 0xfd, 0x03, 0x1a, 0x70, 0x9f,
	0x6a, 0xf6, 0x4f, 0xfc, 0x0f, 0xfe, 0xe0, 0xff, 0xde, 0x2d, 0xfc, 0x9f, 0x13, 0xf2, 0x1f, 0xad,
	0x7f, 0x09, 0xd7, 0xaf, 0xc4, 0x18, 0xd7, 0xaf, 0x6c, 0x05, 0x37, 0xda, 0xfa, 0x14, 0x3e, 0x68,
	0x05, 0x42, 0xcd, 0x6f, 0xf6, 0xe2, 0xc1, 0x55, 0x9b, 0xb0, 0x3c, 0x8b, 0x2a, 0xce, 0x5c, 0xff,
	0x52, 0x82, 0x1b, 0xed, 0x99, 0x6b, 0x6e, 0xe6, 0xc7, 0x8c, 0x4e, 0xe1, 0xdd, 0x49, 0x4f, 0xa8,
	0x5e, 0x7c, 0x1a, 0xce, 0x4e, 0x21, 0x4c, 0x2e, 0xbd, 0x5a, 0xfa, 0x60, 0x03, 0xf4, 0x1e, 0xc0,
	0xd5, 0x99, 0x4d, 0x46, 0xbb, 0x7f, 0x79, 0x8d, 0x4e, 0xa3, 0x38, 0x70, 0x5a, 0xc9, 0x3b, 0x00,
	0xef, 0x4d, 0x5b, 0x8c, 0x9e, 0xdd, 0xa6, 0xde, 0xf5, 0x49, 0x3a, 0xbb, 0x85, 0x71, 0x53, 0x32,
	0x9a, 0xfe, 0x70, 0x84, 0xad, 0xf3, 0x11, 0xb6, 0x2e, 0x46, 0x18, 0x9c, 0xa5, 0x18, 0x7c, 0x4d,
	0x31, 0xf8, 0x9e, 0x62, 0x30, 0x4c, 0x31, 0xf8, 0x91, 0x62, 0xf0, 0x33, 0xc5, 0xd6, 0x45, 0x8a,
	0xc1, 0xc7, 0x31, 0xb6, 0x86, 0x63, 0x6c, 0x9d, 0x8f, 0xb1, 0xf5, 0xb6, 0x96, 0x53, 0x72, 0xe1,
	0xd2, 0x88, 0xbb, 0x0b, 0x7e, 0xe7, 0x67, 0x00, 0x7c, 0x03, 0xa0, 0xb7, 0x94, 0x6d, 0xf7, 0xce,
	0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x4e, 0x9e, 0xf0, 0xba, 0xfa, 0x05, 0x00, 0x00,
}

func (this *CreateSessionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSessionRequest)
	if !ok {
		that2, ok := that.(CreateSessionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AdapterConfig.Equal(that1.AdapterConfig) {
		return false
	}
	if len(this.InferredTypes) != len(that1.InferredTypes) {
		return false
	}
	for i := range this.InferredTypes {
		if !this.InferredTypes[i].Equal(that1.InferredTypes[i]) {
			return false
		}
	}
	return true
}
func (this *CreateSessionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CreateSessionResponse)
	if !ok {
		that2, ok := that.(CreateSessionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *ValidateRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidateRequest)
	if !ok {
		that2, ok := that.(ValidateRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.AdapterConfig.Equal(that1.AdapterConfig) {
		return false
	}
	if len(this.InferredTypes) != len(that1.InferredTypes) {
		return false
	}
	for i := range this.InferredTypes {
		if !this.InferredTypes[i].Equal(that1.InferredTypes[i]) {
			return false
		}
	}
	return true
}
func (this *ValidateResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidateResponse)
	if !ok {
		that2, ok := that.(ValidateResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *CloseSessionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloseSessionRequest)
	if !ok {
		that2, ok := that.(CloseSessionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	return true
}
func (this *CloseSessionResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CloseSessionResponse)
	if !ok {
		that2, ok := that.(CloseSessionResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	return true
}
func (this *CreateSessionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.CreateSessionRequest{")
	if this.AdapterConfig != nil {
		s = append(s, "AdapterConfig: "+fmt.Sprintf("%#v", this.AdapterConfig)+",\n")
	}
	keysForInferredTypes := make([]string, 0, len(this.InferredTypes))
	for k, _ := range this.InferredTypes {
		keysForInferredTypes = append(keysForInferredTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInferredTypes)
	mapStringForInferredTypes := "map[string]*types.Any{"
	for _, k := range keysForInferredTypes {
		mapStringForInferredTypes += fmt.Sprintf("%#v: %#v,", k, this.InferredTypes[k])
	}
	mapStringForInferredTypes += "}"
	if this.InferredTypes != nil {
		s = append(s, "InferredTypes: "+mapStringForInferredTypes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CreateSessionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.CreateSessionResponse{")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",\n")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidateRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&v1beta1.ValidateRequest{")
	if this.AdapterConfig != nil {
		s = append(s, "AdapterConfig: "+fmt.Sprintf("%#v", this.AdapterConfig)+",\n")
	}
	keysForInferredTypes := make([]string, 0, len(this.InferredTypes))
	for k, _ := range this.InferredTypes {
		keysForInferredTypes = append(keysForInferredTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInferredTypes)
	mapStringForInferredTypes := "map[string]*types.Any{"
	for _, k := range keysForInferredTypes {
		mapStringForInferredTypes += fmt.Sprintf("%#v: %#v,", k, this.InferredTypes[k])
	}
	mapStringForInferredTypes += "}"
	if this.InferredTypes != nil {
		s = append(s, "InferredTypes: "+mapStringForInferredTypes+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ValidateResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1beta1.ValidateResponse{")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloseSessionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1beta1.CloseSessionRequest{")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CloseSessionResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&v1beta1.CloseSessionResponse{")
	if this.Status != nil {
		s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringInfrastructureBackend(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InfrastructureBackendClient is the client API for InfrastructureBackend service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InfrastructureBackendClient interface {
	// Validates the handler configuration along with the template-specific instances that would be routed to that
	// handler. The `CreateSession` for a specific handler configuration is invoked only if its associated `Validate`
	// call has returned success.
	Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error)
	// Creates a session for a given handler configuration and the template-specific instances that would be routed to
	// that handler. For every handler configuration, Mixer creates a separate session by invoking `CreateSession`
	// on the backend.
	//
	// `CreateSessionRequest` contains the adapter specific handler configuration and the inferred type information about
	// the instances the handler would receive during request processing.
	//
	// `CreateSession` must return a `session_id` which Mixer uses to invoke template-specific Handle functions during
	// request processing. The `session_id` provides the Handle functions a way to retrieve the necessary configuration
	// associated with the session. Upon Mixer configuration change, Mixer will re-invoke `CreateSession` for all
	// handler configurations whose existing sessions are invalidated or didn't existed.
	//
	// Backend is allowed to return the same session id if given the same configuration block.
	// This would happen when multiple instances of Mixer in a deployment all create sessions with the same configuration.
	// Note that given individual instances of Mixer can call `CloseSession`, reusing `session_id` by the backend
	// assumes that the backend is doing reference counting.
	//
	// If the backend couldn't create a session for a specific handler configuration and
	// returns non S_OK status, Mixer will not make request-time Handle calls associated with that handler configuration.
	CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error)
	// Closes the session associated with the `session_id`. Mixer closes a session when its associated handler
	// configuration or the instance configuration changes. Backend is supposed to cleanup all the resources associated
	// with the session_id referenced by CloseSessionRequest.
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error)
}

type infrastructureBackendClient struct {
	cc *grpc.ClientConn
}

func NewInfrastructureBackendClient(cc *grpc.ClientConn) InfrastructureBackendClient {
	return &infrastructureBackendClient{cc}
}

// Deprecated: Do not use.
func (c *infrastructureBackendClient) Validate(ctx context.Context, in *ValidateRequest, opts ...grpc.CallOption) (*ValidateResponse, error) {
	out := new(ValidateResponse)
	err := c.cc.Invoke(ctx, "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/Validate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *infrastructureBackendClient) CreateSession(ctx context.Context, in *CreateSessionRequest, opts ...grpc.CallOption) (*CreateSessionResponse, error) {
	out := new(CreateSessionResponse)
	err := c.cc.Invoke(ctx, "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *infrastructureBackendClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error) {
	out := new(CloseSessionResponse)
	err := c.cc.Invoke(ctx, "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/CloseSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfrastructureBackendServer is the server API for InfrastructureBackend service.
type InfrastructureBackendServer interface {
	// Validates the handler configuration along with the template-specific instances that would be routed to that
	// handler. The `CreateSession` for a specific handler configuration is invoked only if its associated `Validate`
	// call has returned success.
	Validate(context.Context, *ValidateRequest) (*ValidateResponse, error)
	// Creates a session for a given handler configuration and the template-specific instances that would be routed to
	// that handler. For every handler configuration, Mixer creates a separate session by invoking `CreateSession`
	// on the backend.
	//
	// `CreateSessionRequest` contains the adapter specific handler configuration and the inferred type information about
	// the instances the handler would receive during request processing.
	//
	// `CreateSession` must return a `session_id` which Mixer uses to invoke template-specific Handle functions during
	// request processing. The `session_id` provides the Handle functions a way to retrieve the necessary configuration
	// associated with the session. Upon Mixer configuration change, Mixer will re-invoke `CreateSession` for all
	// handler configurations whose existing sessions are invalidated or didn't existed.
	//
	// Backend is allowed to return the same session id if given the same configuration block.
	// This would happen when multiple instances of Mixer in a deployment all create sessions with the same configuration.
	// Note that given individual instances of Mixer can call `CloseSession`, reusing `session_id` by the backend
	// assumes that the backend is doing reference counting.
	//
	// If the backend couldn't create a session for a specific handler configuration and
	// returns non S_OK status, Mixer will not make request-time Handle calls associated with that handler configuration.
	CreateSession(context.Context, *CreateSessionRequest) (*CreateSessionResponse, error)
	// Closes the session associated with the `session_id`. Mixer closes a session when its associated handler
	// configuration or the instance configuration changes. Backend is supposed to cleanup all the resources associated
	// with the session_id referenced by CloseSessionRequest.
	CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error)
}

// UnimplementedInfrastructureBackendServer can be embedded to have forward compatible implementations.
type UnimplementedInfrastructureBackendServer struct {
}

func (*UnimplementedInfrastructureBackendServer) Validate(ctx context.Context, req *ValidateRequest) (*ValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}
func (*UnimplementedInfrastructureBackendServer) CreateSession(ctx context.Context, req *CreateSessionRequest) (*CreateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSession not implemented")
}
func (*UnimplementedInfrastructureBackendServer) CloseSession(ctx context.Context, req *CloseSessionRequest) (*CloseSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}

func RegisterInfrastructureBackendServer(s *grpc.Server, srv InfrastructureBackendServer) {
	s.RegisterService(&_InfrastructureBackend_serviceDesc, srv)
}

func _InfrastructureBackend_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfrastructureBackendServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/Validate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfrastructureBackendServer).Validate(ctx, req.(*ValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfrastructureBackend_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfrastructureBackendServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfrastructureBackendServer).CreateSession(ctx, req.(*CreateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfrastructureBackend_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfrastructureBackendServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/istio.mixer.adapter.model.v1beta1.InfrastructureBackend/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfrastructureBackendServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _InfrastructureBackend_serviceDesc = grpc.ServiceDesc{
	ServiceName: "istio.mixer.adapter.model.v1beta1.InfrastructureBackend",
	HandlerType: (*InfrastructureBackendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Validate",
			Handler:    _InfrastructureBackend_Validate_Handler,
		},
		{
			MethodName: "CreateSession",
			Handler:    _InfrastructureBackend_CreateSession_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _InfrastructureBackend_CloseSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mixer/adapter/model/v1beta1/infrastructure_backend.proto",
}

func (m *CreateSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InferredTypes) > 0 {
		for k := range m.InferredTypes {
			v := m.InferredTypes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AdapterConfig != nil {
		{
			size, err := m.AdapterConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintInfrastructureBackend(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InferredTypes) > 0 {
		for k := range m.InferredTypes {
			v := m.InferredTypes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AdapterConfig != nil {
		{
			size, err := m.AdapterConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseSessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintInfrastructureBackend(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInfrastructureBackend(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintInfrastructureBackend(dAtA []byte, offset int, v uint64) int {
	offset -= sovInfrastructureBackend(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdapterConfig != nil {
		l = m.AdapterConfig.Size()
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	if len(m.InferredTypes) > 0 {
		for k, v := range m.InferredTypes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovInfrastructureBackend(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovInfrastructureBackend(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovInfrastructureBackend(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CreateSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	return n
}

func (m *ValidateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AdapterConfig != nil {
		l = m.AdapterConfig.Size()
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	if len(m.InferredTypes) > 0 {
		for k, v := range m.InferredTypes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovInfrastructureBackend(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovInfrastructureBackend(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovInfrastructureBackend(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ValidateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	return n
}

func (m *CloseSessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	return n
}

func (m *CloseSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovInfrastructureBackend(uint64(l))
	}
	return n
}

func sovInfrastructureBackend(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInfrastructureBackend(x uint64) (n int) {
	return sovInfrastructureBackend(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CreateSessionRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForInferredTypes := make([]string, 0, len(this.InferredTypes))
	for k, _ := range this.InferredTypes {
		keysForInferredTypes = append(keysForInferredTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInferredTypes)
	mapStringForInferredTypes := "map[string]*types.Any{"
	for _, k := range keysForInferredTypes {
		mapStringForInferredTypes += fmt.Sprintf("%v: %v,", k, this.InferredTypes[k])
	}
	mapStringForInferredTypes += "}"
	s := strings.Join([]string{`&CreateSessionRequest{`,
		`AdapterConfig:` + strings.Replace(fmt.Sprintf("%v", this.AdapterConfig), "Any", "types.Any", 1) + `,`,
		`InferredTypes:` + mapStringForInferredTypes + `,`,
		`}`,
	}, "")
	return s
}
func (this *CreateSessionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CreateSessionResponse{`,
		`SessionId:` + fmt.Sprintf("%v", this.SessionId) + `,`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Status", "rpc.Status", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForInferredTypes := make([]string, 0, len(this.InferredTypes))
	for k, _ := range this.InferredTypes {
		keysForInferredTypes = append(keysForInferredTypes, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForInferredTypes)
	mapStringForInferredTypes := "map[string]*types.Any{"
	for _, k := range keysForInferredTypes {
		mapStringForInferredTypes += fmt.Sprintf("%v: %v,", k, this.InferredTypes[k])
	}
	mapStringForInferredTypes += "}"
	s := strings.Join([]string{`&ValidateRequest{`,
		`AdapterConfig:` + strings.Replace(fmt.Sprintf("%v", this.AdapterConfig), "Any", "types.Any", 1) + `,`,
		`InferredTypes:` + mapStringForInferredTypes + `,`,
		`}`,
	}, "")
	return s
}
func (this *ValidateResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ValidateResponse{`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Status", "rpc.Status", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloseSessionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloseSessionRequest{`,
		`SessionId:` + fmt.Sprintf("%v", this.SessionId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CloseSessionResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CloseSessionResponse{`,
		`Status:` + strings.Replace(fmt.Sprintf("%v", this.Status), "Status", "rpc.Status", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringInfrastructureBackend(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *CreateSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdapterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdapterConfig == nil {
				m.AdapterConfig = &types.Any{}
			}
			if err := m.AdapterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferredTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InferredTypes == nil {
				m.InferredTypes = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInfrastructureBackend
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInfrastructureBackend
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInfrastructureBackend
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InferredTypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdapterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdapterConfig == nil {
				m.AdapterConfig = &types.Any{}
			}
			if err := m.AdapterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InferredTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InferredTypes == nil {
				m.InferredTypes = make(map[string]*types.Any)
			}
			var mapkey string
			var mapvalue *types.Any
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInfrastructureBackend
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInfrastructureBackend
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInfrastructureBackend
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &types.Any{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthInfrastructureBackend
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InferredTypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &rpc.Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInfrastructureBackend(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInfrastructureBackend
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInfrastructureBackend(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInfrastructureBackend
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInfrastructureBackend
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInfrastructureBackend
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInfrastructureBackend
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInfrastructureBackend
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInfrastructureBackend(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInfrastructureBackend
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInfrastructureBackend = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInfrastructureBackend   = fmt.Errorf("proto: integer overflow")
)
