// Copyright 2016 IBM Corporation
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/any.proto";
package istio.proxy.v1.config;

// Glossary of terms and concepts used in this file

// For a given microservice, multiple versions of the same service with
// slightly differing functionality can be running concurrently. Common
// scenarios where this occurs include A/B testing, canary rollouts,
// etc. The choice of a particular version can be decided based on various
// criterion (headers, url, etc.) and/or by weights assigned to each
// version.

// RouteRule: Describes rules for routing a request/connection to a
// microservice, based on attributes associated with the request and
// calling service.

// Downstream service - client (browser or another microservice) calling
// the proxy/sidecar (typically to reach another microservice).

// Upstream service - The remote service to which the proxy/sidecar is
// talking to, on behalf of the Downstream service.


// Proxy level global configurations go here
message ProxyConfig {
  string version = 1;

  // Port at which the proxy should listen for incoming connections
  uint32 listener_port = 2;

  // Need atleast one vhost
  repeated VirtualHost vhost = 3;

  // TODO: access log, stats, admin port, etc.
}

// A virtual host (in the traditional proxy sense)
message VirtualHost {
  // fully qualified domain name for the virtual host. Regular
  // expressions are not allowed here, except * which indicates a catch
  // all virtual host.
  string virtual_host_name = 1;
    
  // Request routing related configurations for the proxy/sidecar.  The
  // configuration generated for the proxy will preserve the order of
  // rules specified by the user in the Istio config.

  //When a request matches multiple route rules, the choice of a
  // RouteRule is specific to proxy implementation. When a request does
  // not match any rule for Http, the downstream service would receive a
  // HTTP 404 or HTTP 502 error code depending on the http_default_error_code.
  repeated RouteRule routing_rules = 2;

  // The error code to return for HTTP requests, when none of the routes
  // match.
  uint32 http_default_error_code = 3;
}

// A single routing rule
message RouteRule {
  // Set of conditions that must be satisfied, such as downstream service
  // labels, request attributes, etc.
  MatchCondition match = 1;

  // One or more versions of this microservice, with weights that determine
  // proportion of traffic to send to each version.
  repeated VersionedService service_versions = 2;

  // Faults can be injected into the API calls by the proxy, for testing
  // the failure recovery capabilities of downstream services.  Faults
  // include aborting the request/connection from downstream service,
  // delaying the proxying of request/connection to the upstream service,
  // and throttling the bandwidth of the connection (either end).

  // TODO: This should move into VersionedService
  FaultInjection fault = 3;

  // Other things? such as enabling tracing, etc. ?
}

// TODO: Merge with the proposal for "Deriving Request Metadata in
// Kubernetes" by Sven Manson
message MatchCondition {

  // src/dst Ip and port
  TcpMatchCondition tcp_match = 1;
  // attributes of a HTTP request
  HttpMatchCondition http_match = 2;

  // One or more tags that identify the downstream service.
  // Tags can be arbitrary strings (includes key=value pairs)
  repeated string src_tags = 3;

  message TcpMatchCondition {
    // IPv4 Subnet mask/IPv6 prefix that identifies network where the downstream
    // request originates. It could be as specific as a single downstream IP.
    // Must be in a.b.c.d/xx or a.b.c.d format for IPv4 or IPv6 prefix format.
    string src_subnet_mask = 1;
    // source port
    uint32 src_port = 2;

    // Subnet mask that identifies the IP subnet to which the request is
    // targeted. It could be as specific as a single destination IP.
    string dst_subnet_mask = 3;
    // destination port
    uint32 dst_port = 4;
  }

  message HttpMatchCondition {
    string scheme = 1;
    string authority = 2;
    oneof uri_match {
      // exact match with the Http path
      string path = 3;
      // prefix match
      string prefix = 4;
      // Posix style regular expressions. Not all proxies support this.
      string regex = 5;
    }
    // Match Http requests based on the specified headers
    map<string, string> http_match_headers = 6;
  }

}

message VersionedService {
  // A unique name across all VersionedService objects, that can be used to
  // refer to this VersionedService from different parts of the config.
  string name = 1;

  // When there are multiple versions of the same upstream service service
  // (e.g., in A/B testing), traffic_weight determines the proportion of
  // request traffic to be sent to a particular version. Max is 1000. Sum
  // of weights across versions should add up to 1000.
  uint32 traffic_weight = 2;
}

// Describes load balancing and failure recovery policies for a particular
// version of an upstream service.
message VersionedServicePolicies {

  // Must be the same as VersionedService.name
  string name = 1;

  // A tag is an arbitrary string. One or more tags uniquely a version of
  // the upstream service. These tags are used by the service discovery
  // component of the proxy to identify the IP addresses of the pods
  // running this service.
  repeated string dst_tags = 2; // labels or tags

  // User can override service discovery and specify a list of upstream hosts/IPs for
  // the upstream service. TODO: either tags or hosts. Not both.
  repeated string hosts = 3;

  // Should be either http://.. or tcp://.. 
  string health_check_endpoint = 4;
  LoadBalancingPolicy lb_policy = 5;
  TimeoutPolicy timeout_policy = 6;
  RetryPolicy retry_policy = 7;
  CircuitBreakerPolicy circuit_breaker_policy = 8;
}

// Load balancing policy to use when forwarding traffic to upstream services.
message LoadBalancingPolicy {
  enum SimpleLBPolicy {
    // These four simple load balancing policies have literally no
    // additional configuration.
    ROUND_ROBIN = 0;
    LEAST_CONN = 1;
    IP_HASH = 2;
    RANDOM = 3;
  }
  oneof lbpolicy {
    SimpleLBPolicy policy_name = 1;
    //Custom policy implementations
    google.protobuf.Any custom_lb_policy_impl = 2;
  }
}

// Request timeout (implies read/write/connect timeouts)
message TimeoutPolicy {
  message SimpleTimeoutPolicy {
    // timeout is per attempt, when retries are specified as well.
    // seconds.nanoseconds format
    double timeout_sec = 1;
    // Downstream service could specify timeout via Http header to the
    // proxy, if the proxy supports such a feature.
    string override_header_name = 2;
  }
  oneof timeoutpolicy {
    SimpleTimeoutPolicy simple_timeout = 1;
    // For proxies that support custom timeout policies
    google.protobuf.Any custom_timeout_policy_impl = 2;
  }
}

message RetryPolicy {
  message SimpleRetryPolicy {
    // number of times the request to the upstream service should be retried.
    // total timeout would be attempts * timeout
    uint32 attempts = 1;
    // Downstream Service could specify retry attempts via Http header to
    // the proxy, if the proxy supports such a feature.
    string override_header_name = 2;
  }
  oneof retrypolicy {
    SimpleRetryPolicy simple_retry = 1;
    // For proxies that support custom retry policies
    google.protobuf.Any custom_retry_policy_impl = 2;
  }
}

// A minimal circuit breaker configuration
message CircuitBreakerPolicy {
  message SimpleCircuitBreakerPolicy {
    // (for an unhealthy upstream service) number of consecutive requests that
    // should succeed before the upstream service is marked healthy.
    uint32 success_threshold = 1;

    // (for a healthy upstream service) number of consecutive requests that
    // can fail before the upstream service is marked unhealthy.
    uint32 failure_threshold = 2;

    // When a healthy upstream service becomes unhealthy, duration to wait before
    // attempting to send requests to that upstream service.
    // format seconds.nanoseconds
    double reset_timeout_sec = 3;
  }
  oneof cbpolicy {
    SimpleCircuitBreakerPolicy simple_cb = 1;
    // For proxies that support custom circuit breaker policies.
    google.protobuf.Any custom_cb_policy_impl = 2;
  }
}

// Fault Injection policies
message FaultInjection {
  HttpFaultInjection http_fault = 1;
  TcpFaultInjection tcp_fault = 2;
}

// Fault injection for Http based services
message HttpFaultInjection {
  // Delay requests before forwarding to upstream service, emulating
  // various failures such as network issues, overloaded upstream service, etc.
  Delay delay_policy = 1;

  // Abort Http request attempts and return error codes back to Downstream
  // service, giving the impression that the Upstream service is faulty.
  // N.B. Both delay and abort can be specified simultaneously. In such
  // cases, a request would be first delayed and then aborted with an error
  // code.
  Abort abort_policy = 2;
  
  // Only requests with these Http headers will be subjected to fault
  // injection
  map<string, string> http_match_headers = 3;

  // Either a fixed delay or exponential delay.
  message Delay {
    string type = 1;
    oneof http_delay_type {
      FixedDelay fixed_delay=2;
      ExponentialDelay exp_delay=3;
    }
  }

  // Add a fixed delay before forwarding the request upstream
  message FixedDelay {
    float percent = 1;
    // delay duration in seconds.nanoseconds
    double fixed_delay_sec = 2;
    // Specify delay duration as part of Http request
    string override_header_name = 3;
  }

  // Determine the delay to be added based on an exponential function
  message ExponentialDelay {
    float percent = 1;
    double mean_delay_sec = 2;
  }

  // Abort Http request attempts and return error codes back to Downstream
  // service.
  message Abort {
    // percentage of requests to be aborted with 
    float percent = 1;
    oneof error_type {
      string grpc_status = 2;
      string http2_error = 3;
      uint32 http_status = 4;
    }
    string override_header_name = 5;
  }
}

// Fault injection for Tcp based services
message TcpFaultInjection {
  // Unlike HTTP services, we have very little context for raw TCP
  // connections. We could throttle bandwidth of the connections (slow down
  // the connection) and/or abruptly reset the TCP connection.
  Delay delay_policy = 1;
  Abort abort_policy = 2;

 // Only bandwidth throttling is supported.
  message Delay {
    // percentage of connections to throttle.
    float percent = 1;
    // bandwidth in "bits" per second
    uint64 bandwidth_bps = 2;

    // Wait for X seconds after the connection is established, before
    // starting bandwidth throttling. This would allow us to inject fault
    // after the application protocol (e.g., MySQL) has had time to
    // establish sessions/whatever handshake necessary.
    double throttle_wait_sec = 3;

    // Stop throttling after the given duration
    double throttle_duration_sec = 4;
  }

  message Abort {
    // percentage of connection attempts to be terminated/reset.
    float  percent = 1;
  }
}
