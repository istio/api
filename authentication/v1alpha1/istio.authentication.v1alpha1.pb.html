---
title: Authentication Policy
overview: Authentication policy for Istio services.
layout: protoc-gen-docs
number_of_entries: 8
---
<p>This package defines user-facing authentication policy as well as configs
that the sidecar proxy uses to perform authentication.</p>

<h2 id="CredentialRule">CredentialRule</h2>
<section>
<p>CredentialRule defines which identity (e.g from peer or end-user
authentication) will be used as request principal. The rule can be activated
conditionally, based on matching condition (currently use only peer identity)</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="CredentialRule.binding">
<td><code>binding</code></td>
<td><code><a href="#CredentialRule.Binding">CredentialRule.Binding</a></code></td>
<td>
<p>Defines which authentication (peer vs origin) will be binded to
request principal.</p>

</td>
</tr>
<tr id="CredentialRule.origins">
<td><code>origins</code></td>
<td><code><a href="#OriginAuthenticationMethod">OriginAuthenticationMethod[]</a></code></td>
<td>
<p>This list of origin authentication methods that should be
considered for the rule.
At run time, each method will be evaluated in order, until the first valid
(if none success, request should be rejected).
If binding is USE_ORIGIN, request.auth.principal attribute will be set to
the identity extracted from that valid certificate.</p>

</td>
</tr>
<tr id="CredentialRule.matching_peers">
<td><code>matchingPeers</code></td>
<td><code>string[]</code></td>
<td>
<p>Condition to activate the rule. If not empty, the rule will be activated
if the request comes from one of these peers (identity).
Leave blank to activate the rule unconditionally.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="CredentialRule.Binding">CredentialRule.Binding</h2>
<section>
<p>Associates authentication with request principal.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="CredentialRule.Binding.USE_PEER">
<td><code>USE_PEER</code></td>
<td>
<p>Principal will be set to the identity from peer authentication.</p>

</td>
</tr>
<tr id="CredentialRule.Binding.USE_ORIGIN">
<td><code>USE_ORIGIN</code></td>
<td>
<p>Principal will be set to the identity from origin authentication.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Jwt">Jwt</h2>
<section>
<p>JSON Web Token (JWT) token format for authentication as defined by
https://tools.ietf.org/html/rfc7519. See <a href="https://tools.ietf.org/html/rfc6749">OAuth
2.0</a> and <a href="http://openid.net/connect">OIDC
1.0</a> for how this is used in the whole
authentication flow.</p>

<p>Example,</p>

<pre><code class="language-yaml">issuer: https://example.com
audiences:
- bookstore_android.apps.googleusercontent.com
  bookstore_web.apps.googleusercontent.com
jwksUri: https://example.com/.well-known/jwks.json
</code></pre>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="Jwt.issuer">
<td><code>issuer</code></td>
<td><code>string</code></td>
<td>
<p>Identifies the issuer that issued the JWT. See
<a href="https://tools.ietf.org/html/rfc7519#section-4.1.1">issuer</a>
Usually a URL or an email address.</p>

<p>Example: https://securetoken.google.com
Example: 1234567-compute@developer.gserviceaccount.com</p>

</td>
</tr>
<tr id="Jwt.audiences">
<td><code>audiences</code></td>
<td><code>string[]</code></td>
<td>
<p>The list of JWT
<a href="https://tools.ietf.org/html/rfc7519#section-4.1.3">audiences</a>.
that are allowed to access. A JWT containing any of these
audiences will be accepted.</p>

<p>The service name will be accepted if audiences is empty.</p>

<p>Example:</p>

<pre><code class="language-yaml">audiences:
- bookstore_android.apps.googleusercontent.com
  bookstore_web.apps.googleusercontent.com
</code></pre>

</td>
</tr>
<tr id="Jwt.jwks_uri">
<td><code>jwksUri</code></td>
<td><code>string</code></td>
<td>
<p>URL of the provider&rsquo;s public key set to validate signature of the
JWT. See <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata">OpenID
Discovery</a>.</p>

<p>Optional if the key set document can either (a) be retrieved from
<a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID
Discovery</a> of
the issuer or (b) inferred from the email domain of the issuer (e.g. a
Google service account).</p>

<p>Example: https://www.googleapis.com/oauth2/v1/certs</p>

</td>
</tr>
<tr id="Jwt.jwt_headers">
<td><code>jwtHeaders</code></td>
<td><code>string[]</code></td>
<td>
<p>JWT is sent in a request header. <code>header</code> represents the
header name.</p>

<p>For example, if <code>header=x-goog-iap-jwt-assertion</code>, the header
format will be x-goog-iap-jwt-assertion: <JWT>.</p>

</td>
</tr>
<tr id="Jwt.jwt_params">
<td><code>jwtParams</code></td>
<td><code>string[]</code></td>
<td>
<p>JWT is sent in a query parameter. <code>query</code> represents the
query parameter name.</p>

<p>For example, <code>query=jwt_token</code>.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="MutualTls">MutualTls</h2>
<section>
<p>Placeholder for mTLS authentication params.</p>

</section>
<h2 id="None">None</h2>
<section>
<p>Placeholder for None authentication params.</p>

</section>
<h2 id="OriginAuthenticationMethod">OriginAuthenticationMethod</h2>
<section>
<p>OriginAuthenticationMethod defines authentication method/params for origin
authentication. Origin could be end-user, device, delegate service etc.
Method should have unique name so they can be referred later in credential
rules. Currently, only JWT is supported for origin authentication.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="OriginAuthenticationMethod.jwt">
<td><code>jwt</code></td>
<td><code><a href="#Jwt">Jwt</a></code></td>
<td>
<p>Jwt params for the method.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="PeerAuthenticationMethod">PeerAuthenticationMethod</h2>
<section>
<p>PeerAuthenticationMethod defines one particular type of authentication, e.g
mutual TLS, JWT etc, (no authentication is one type by itself) that can
be used for peer authentication.
The type can be progammatically determine by checking the type of the
&ldquo;params&rdquo; field.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="PeerAuthenticationMethod.none" class="oneof oneof-start">
<td><code>none</code></td>
<td><code><a href="#None">None (oneof)</a></code></td>
<td>
<p>Set if authentication is not required. This is typically used to indicate
other methods are optional.</p>

</td>
</tr>
<tr id="PeerAuthenticationMethod.mtls" class="oneof">
<td><code>mtls</code></td>
<td><code><a href="#MutualTls">MutualTls (oneof)</a></code></td>
<td>
<p>Set if mTLS is used.</p>

</td>
</tr>
<tr id="PeerAuthenticationMethod.jwt" class="oneof">
<td><code>jwt</code></td>
<td><code><a href="#Jwt">Jwt (oneof)</a></code></td>
<td>
<p>Set if JWT is used.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Policy">Policy</h2>
<section>
<p>Policy defines what authentication methods can be accepted on workload(s),
and if authenticated, which method/certificate will set the request principal
(i.e request.auth.principal attribute).</p>

<p>Authentication policy is composed of 2-part authentication:
- peer: verify caller service credentials. This part will set source.user
(peer identity).
- origin: verify the origin credentials. This part will set request.auth.user
(origin identity), as well as other attributes like request.auth.presenter,
request.auth.audiences and raw claims. Note that the identity could be
end-user, service account, device etc.</p>

<p>request.auth.principal will be assigned follow the credential rules. The
rule also dictates which origin authentication method(s) should run, based
on peer identity.</p>

<p>Examples:
Policy to enable mTLS for all services in namespace frod</p>

<pre><code class="language-yaml">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: mTLS_enable
  namespace: frod
spec:
  destinations:
  peers:
  - mtls: null
</code></pre>

<p>Policy to disable mTLS for &ldquo;productpage&rdquo; service</p>

<pre><code class="language-yaml">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: mTLS_disable
  namespace: frod
spec:
  destinations:
  - name: productpage
  peers:
</code></pre>

<p>Policy to enable mTLS, and use JWT for productpage:9000.</p>

<pre><code class="language-yaml">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: mTLS_enable
  namespace: frod
spec:
  destinations:
  - name: productpage
    port:
      number: 9000
  peers:
  - mtls: null
  credentialRules:
  - binding: USE_ORIGIN
    origins:
      jwt:
        issuer: &quot;https://securetoken.google.com&quot;
        audiences:
        - &quot;productpage&quot;
        jwksUri: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;
        locations:
        - header: x-goog-iap-jwt-assertion
</code></pre>

<p>Policy to enable mTLS, and use JWT for productpage:9000 only when caller is
frontend.serviceaccount.</p>

<pre><code class="language-yaml">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: mTLS_enable
  namespace: frod
spec:
  destinations:
  - name: productpage
    port:
      number: 9000
  peers:
  - mtls: null
  credentialRules:
  - binding: USE_ORIGIN
    matchingSources:
    - frontend.serviceaccount
    origins:
    - jwt:
        issuer: &quot;https://securetoken.google.com&quot;
        audiences:
        - &quot;productpage&quot;
        jwksUri: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;
        locations:
        - header: x-goog-iap-jwt-assertion
</code></pre>

<p>Note that a credential rule that unconditional-use-peer (identity)  is
implicitly check if no rule match, so the above credentialRules is the same
as this:</p>

<pre><code>credentialRules:
- binding: USE_ORIGIN
  selectedOriginMethods:
  - google_jwt
  matchingSources:
  - productpage.serviceaccount
  origins:
  - jwt:
    ...
- binding: USE_PEER
</code></pre>

<p>Policy that enable mTLS, requires google JWT if caller is
frontend.serviceaccount, no JWT (i.e peer authentication only) if caller
is admin, and istio JWT in all other cases.</p>

<pre><code class="language-yaml">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: mTLS_enable
  namespace: frod
spec:
  destinations:
  - name: productpage
    port:
      number: 9000
  peers:
  - mtls: null
  origins:
  - name: google_jwt
  - name: istio_jwt
  credentialRules:
  - binding: USE_ORIGIN
    orgins:
    - jwt:
        issuer: &quot;https://securetoken.google.com&quot;
        audiences:
        - &quot;productpage&quot;
        jwksUri: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;
        locations:
        - header: x-goog-iap-jwt-assertion
    matchingSources:
    - productpage.serviceaccount
  - binding: USE_PEER
    matchingSource:
    - admin
  - binding: USE_ORIGIN
    origins:
    - jwt:
        issuer: &quot;https://securetoken.istio.io&quot;
        locations:
        - header: x-istio-jwt-assertion
</code></pre>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="Policy.destinations">
<td><code>destinations</code></td>
<td><code><a href="https://istio.io/docs/reference/config/istio.networking.v1alpha3.html#Destination">istio.networking.v1alpha3.Destination[]</a></code></td>
<td>
<p>List of destinations (workloads) that the policy should be applied on.
If empty, policy will be used on all destinations in the same namespace.</p>

</td>
</tr>
<tr id="Policy.peers">
<td><code>peers</code></td>
<td><code><a href="#PeerAuthenticationMethod">PeerAuthenticationMethod[]</a></code></td>
<td>
<p>List of authentication methods that can be used for peer authentication.
They will be evaluated in order, until the first one satisfied; peer
identity is then extracted from the associated certificate. On the other
hand, if none of these methods pass, request should be rejected with
authentication failed error (401).
Leave the list empty if no peer authentication is required, or have single
entry of method &lsquo;None&rsquo;. The source.user attribute will not be set in that
case.</p>

</td>
</tr>
<tr id="Policy.credential_rules">
<td><code>credentialRules</code></td>
<td><code><a href="#CredentialRule">CredentialRule[]</a></code></td>
<td>
<p>Rules to define how request principal will be set. Each rule can have
conditions that determine if the rule should be applied or not. The rule
will be checked for matching conditions at runtime, in order, and stop at
the first match. If there are no rule matching condtion, peer identity
will be used as principal (in other words, the credential rule with
USE_PEER with no matching condition is implicitly added to the end
of the list.)</p>

</td>
</tr>
</tbody>
</table>
</section>
