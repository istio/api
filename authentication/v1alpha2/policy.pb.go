// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authentication/v1alpha2/policy.proto

// This package defines user-facing authentication policy.

package v1alpha2

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	v1beta1 "istio.io/api/common/v1beta1"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// $hide_from_docs
// AuthenticationPolicy describes authentication requirements for the workload(s) it is attached to.
// Example of a simple policy that enable mTLS for all workloads in the namespace scope of the
// policy. Note that `istio.mtls` is a name of the pre-define `Credential` for Istio
// mutual TLS.
//
// ```
// spec:
//   rules:
//   - require:
//       credential: "istio.mtls"
// ```
//
// This example sets end-user authentication for workloads that match label `app=foo`, using JWT
// The JWT authentication details are defined directly in the policy (`inline`).
// ```
// spec:
//   workloadSelector:
//     app: foo
//   rules:
//   - require:
//     - credential: "none"
//       override:
//         jwt:
//           issuer: "https://securetoken.google.com"
//           audiences:
//           - "productpage"
//           jwksUri: "https://www.googleapis.com/oauth2/v1/certs"
// ```
//
// This example sets policy for workload `app=foo`, requires mTLS for all traffic, and JWT for
// (HTTP) request with path start with `/set`
// ```
// spec:
//   workloadSelector:
//     app: foo
//   rules:
//   - require:
//     - credential: "istio.mtls"
//   - match:
//       paths:
//         prefix: '/set'
//     require:
//     - credential: "my-jwt"
// ```
// This example requires mTLS *or* JWT for port 9090, and mTLS (only) else where.
// ```
// spec:
//   workloadSelector:
//     app: foo
//   rules:
//   - match:
//       ports: [9090]
//     require:
//     - credential: "istio.mtls"
//     - credential: "my-jwt"
//   - require:
//     - credential: "istio.mtls"
//
// This last example shows a policy to set peer authentication with mTLS for all requests, and
// end-user authentication if requests have "/create" or "/update" prefix. For all other paths,
// end-user authentication is not required (though peer mTLS still needed)
// ```
// spec:
//   workloadSelector:
//     app: bar
//   rules:
//   - require:
//     - credential: "istio.mtls"
//   - match:
//       paths:
//       - prefix: "/create"
//       - prefix: "/update"
//     require:
//     - credential: "my-jwt"
// ```
type AuthenticationPolicy struct {
	// Criteria used to select the specific set of pods/VMs on which this
	// authentication policy should be applied. If omitted, the authentication policy
	// be applied to all workload instances in the same namespace.
	WorkloadSelector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty"`
	// Rules specify what credential(s) can be used to authenticate with the service. Each rule
	// contains (match) conditions. The first one that meets the conditions will be applied, i.e
	// the corresponding credentials must be provided and and valid. If the list is empty, or no
	// rule is activated, authentication is not required.
	Rules                []*CredentialRule `protobuf:"bytes,2,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AuthenticationPolicy) Reset()         { *m = AuthenticationPolicy{} }
func (m *AuthenticationPolicy) String() string { return proto.CompactTextString(m) }
func (*AuthenticationPolicy) ProtoMessage()    {}
func (*AuthenticationPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{0}
}
func (m *AuthenticationPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthenticationPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthenticationPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthenticationPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthenticationPolicy.Merge(m, src)
}
func (m *AuthenticationPolicy) XXX_Size() int {
	return m.Size()
}
func (m *AuthenticationPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthenticationPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_AuthenticationPolicy proto.InternalMessageInfo

func (m *AuthenticationPolicy) GetWorkloadSelector() *v1beta1.WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *AuthenticationPolicy) GetRules() []*CredentialRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// $hide_from_docs
// CredentialRule specifies the conditions, if any, and the credential(s) required in that case.
// Examples:
// - Rule to require mTLS for all:
// ```
// require:
//   credential: "istio.mtls"
// ```
// - Rule to require mTLS *or* JWT
// ```
// require:
//   credential: "istio.mtls"
//   credential: "my-jwt"
// ```
// - Rule to require mTLS only on port 9090
// ```
// require:
//   match:
//     ports: [9090]
//   require:
//     credential: "istio.mtls"
// ```
type CredentialRule struct {
	// Defines the conditions that require the credentials below.
	Match []*Match `protobuf:"bytes,1,rep,name=match,proto3" json:"match,omitempty"`
	// If the `match` conditions are satisfied, all of these credential requirement must be
	// provided (ANDed).
	Require              []*CredentialRequirement `protobuf:"bytes,2,rep,name=require,proto3" json:"require,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *CredentialRule) Reset()         { *m = CredentialRule{} }
func (m *CredentialRule) String() string { return proto.CompactTextString(m) }
func (*CredentialRule) ProtoMessage()    {}
func (*CredentialRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{1}
}
func (m *CredentialRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialRule.Merge(m, src)
}
func (m *CredentialRule) XXX_Size() int {
	return m.Size()
}
func (m *CredentialRule) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialRule.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialRule proto.InternalMessageInfo

func (m *CredentialRule) GetMatch() []*Match {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *CredentialRule) GetRequire() []*CredentialRequirement {
	if m != nil {
		return m.Require
	}
	return nil
}

// $hide_from_docs
// CredentialRequirement defines the credential(s) to be provided. The credential is referred by name,
// and can be defined/overriden inline.
// Example (see AuthenticationPolicy for the use of this in the full context)
// - Require "istio.mtls" credential:
// ```
// credential: "istio.mtls"
// ```
// - Require JWT-type credential, defining inline:
// ```
// credential: "none" # or leave empty
// override:
//   jwt:
//     issuer: "secret@example.com"
// ```
// - Require JWT-type credential, based on "foo-jwt", with specific `audience` require.
// ```
// credential: "foo-jwt"
// override:
//   jwt:
//     aud: "my-service"
// ```
type CredentialRequirement struct {
	// Name of the required credential. This is one of `Credential` CRs, or Istio pre-defined one, such as
	// `none`, `istio.mtls` etc. If not set, it will be treated as `none`.
	Credential string `protobuf:"bytes,1,opt,name=credential,proto3" json:"credential,omitempty"`
	// Override credential definition. The override credential must be the same type as the one
	// defined by the `credential` (name) above, unless the base credential is `none`.
	Override             *Credential `protobuf:"bytes,2,opt,name=override,proto3" json:"override,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *CredentialRequirement) Reset()         { *m = CredentialRequirement{} }
func (m *CredentialRequirement) String() string { return proto.CompactTextString(m) }
func (*CredentialRequirement) ProtoMessage()    {}
func (*CredentialRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{2}
}
func (m *CredentialRequirement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CredentialRequirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CredentialRequirement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CredentialRequirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CredentialRequirement.Merge(m, src)
}
func (m *CredentialRequirement) XXX_Size() int {
	return m.Size()
}
func (m *CredentialRequirement) XXX_DiscardUnknown() {
	xxx_messageInfo_CredentialRequirement.DiscardUnknown(m)
}

var xxx_messageInfo_CredentialRequirement proto.InternalMessageInfo

func (m *CredentialRequirement) GetCredential() string {
	if m != nil {
		return m.Credential
	}
	return ""
}

func (m *CredentialRequirement) GetOverride() *Credential {
	if m != nil {
		return m.Override
	}
	return nil
}

// $hide_from_docs
// Match specifies a set of criterion to be met in order for the rule to be applied.
// For example, the following restricts mTLS being applied only on port 8080, and JWT
// authentication if the request path starts with /get.
//
// ```
// spec:
//   policy:
//     peers:
//     - match
//         ports:
//         - 8080
//       method: istio.mtls
//     origins:
//     - match:
//         paths:
//         - prefix: "/get"
//       method: example-jwt
// ```
type Match struct {
	// Ports to match. If not specified, it matches to any port number.
	// Note: these are workload ports, not service ports.
	Ports []uint32 `protobuf:"varint,1,rep,packed,name=ports,proto3" json:"ports,omitempty"`
	// Request path to match. Available for `L7` authentication method only (e.g JWT). If not
	// specified, it matches to any paths.
	// Values are case-sensitive and formatted as follows:
	//
	// - `exact: "value"` for exact string match
	//
	// - `prefix: "value"` for prefix-based match
	//
	// - `regex: "value"` for ECMAscript style regex-based match
	Paths                []*v1beta1.StringMatch `protobuf:"bytes,2,rep,name=paths,proto3" json:"paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *Match) Reset()         { *m = Match{} }
func (m *Match) String() string { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()    {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_de35128e1eb23de7, []int{3}
}
func (m *Match) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Match.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return m.Size()
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Match) GetPaths() []*v1beta1.StringMatch {
	if m != nil {
		return m.Paths
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthenticationPolicy)(nil), "istio.authentication.v1alpha2.AuthenticationPolicy")
	proto.RegisterType((*CredentialRule)(nil), "istio.authentication.v1alpha2.CredentialRule")
	proto.RegisterType((*CredentialRequirement)(nil), "istio.authentication.v1alpha2.CredentialRequirement")
	proto.RegisterType((*Match)(nil), "istio.authentication.v1alpha2.Match")
}

func init() {
	proto.RegisterFile("authentication/v1alpha2/policy.proto", fileDescriptor_de35128e1eb23de7)
}

var fileDescriptor_de35128e1eb23de7 = []byte{
	// 371 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xdd, 0x4a, 0xc3, 0x30,
	0x14, 0x26, 0x4a, 0xfd, 0xc9, 0x50, 0x34, 0x4c, 0x18, 0x83, 0x95, 0x59, 0x86, 0xcc, 0x0b, 0x53,
	0x56, 0x05, 0xc1, 0x3b, 0x1d, 0x5e, 0x2a, 0xd2, 0x81, 0x82, 0x37, 0x92, 0x75, 0xc1, 0x06, 0xd3,
	0xa6, 0xa6, 0xe9, 0x86, 0x37, 0x3e, 0x89, 0x0f, 0xe1, 0x63, 0x78, 0xe9, 0x23, 0xc8, 0x9e, 0x44,
	0x9a, 0xb4, 0xd3, 0x8d, 0x4d, 0x77, 0xd9, 0xf3, 0xfd, 0xf4, 0x3b, 0xdf, 0x09, 0x6c, 0x91, 0x4c,
	0x85, 0x34, 0x56, 0x2c, 0x20, 0x8a, 0x89, 0xd8, 0x1d, 0x76, 0x08, 0x4f, 0x42, 0xe2, 0xb9, 0x89,
	0xe0, 0x2c, 0x78, 0xc1, 0x89, 0x14, 0x4a, 0xa0, 0x06, 0x4b, 0x15, 0x13, 0x78, 0x9a, 0x8b, 0x4b,
	0x6e, 0xbd, 0xbd, 0xc8, 0x24, 0x90, 0x74, 0x90, 0xcf, 0x09, 0x37, 0x46, 0xf5, 0x46, 0x20, 0xa2,
	0x48, 0x33, 0xfa, 0x54, 0x91, 0x8e, 0x9b, 0x52, 0x4e, 0x03, 0x25, 0x64, 0x01, 0xd7, 0x67, 0xe0,
	0x88, 0xa8, 0x20, 0x34, 0x98, 0xf3, 0x0e, 0x60, 0xf5, 0x7c, 0xea, 0x3f, 0x37, 0x3a, 0x22, 0xea,
	0xc1, 0xdd, 0x91, 0x90, 0x4f, 0x5c, 0x90, 0xc1, 0x43, 0xe9, 0x57, 0x03, 0x4d, 0xd0, 0xae, 0x78,
	0x07, 0xd8, 0x04, 0x37, 0xb6, 0xb8, 0xb0, 0xc5, 0x77, 0x05, 0xbd, 0x57, 0xb0, 0xfd, 0x9d, 0xd1,
	0xcc, 0x04, 0x75, 0xa1, 0x25, 0x33, 0x4e, 0xd3, 0xda, 0x4a, 0x73, 0xb5, 0x5d, 0xf1, 0x8e, 0xf0,
	0x9f, 0x0d, 0xe0, 0xee, 0x64, 0x51, 0x3f, 0xe3, 0xd4, 0x37, 0x5a, 0xe7, 0x0d, 0xc0, 0xed, 0x69,
	0x04, 0x9d, 0x41, 0x4b, 0x2f, 0x55, 0x03, 0xda, 0xb7, 0xf5, 0x8f, 0xef, 0x55, 0xce, 0xf5, 0x8d,
	0x04, 0x5d, 0xc3, 0x75, 0x49, 0x9f, 0x33, 0x26, 0x69, 0x91, 0xea, 0x64, 0xf9, 0x54, 0x46, 0x17,
	0xd1, 0x58, 0xf9, 0xa5, 0x89, 0xf3, 0x0a, 0xf7, 0xe6, 0x32, 0x90, 0x0d, 0xe1, 0xcf, 0xe5, 0x74,
	0x95, 0x9b, 0xfe, 0xaf, 0x09, 0xba, 0x84, 0x1b, 0x62, 0x48, 0xa5, 0x64, 0x83, 0x3c, 0x49, 0x5e,
	0xf4, 0xe1, 0xf2, 0x49, 0x26, 0x52, 0xe7, 0x16, 0x5a, 0x7a, 0x3f, 0x54, 0x85, 0x56, 0x22, 0xa4,
	0x4a, 0x75, 0x29, 0x5b, 0xbe, 0xf9, 0x40, 0xa7, 0xd0, 0x4a, 0x88, 0x0a, 0xcb, 0x13, 0xec, 0xcf,
	0xbf, 0x65, 0x4f, 0x49, 0x16, 0x3f, 0x16, 0x3d, 0x69, 0xfe, 0x85, 0xf7, 0x31, 0xb6, 0xc1, 0xe7,
	0xd8, 0x06, 0x5f, 0x63, 0x1b, 0xdc, 0xb7, 0x8c, 0x8c, 0x09, 0x97, 0x24, 0xcc, 0x5d, 0xf0, 0x52,
	0xfb, 0x6b, 0xfa, 0x91, 0x1d, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x1a, 0x32, 0xfc, 0xe7, 0x10,
	0x03, 0x00, 0x00,
}

func (m *AuthenticationPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthenticationPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WorkloadSelector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.WorkloadSelector.Size()))
		n1, err1 := m.WorkloadSelector.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CredentialRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, msg := range m.Match {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Require) > 0 {
		for _, msg := range m.Require {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CredentialRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CredentialRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Credential) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(len(m.Credential)))
		i += copy(dAtA[i:], m.Credential)
	}
	if m.Override != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(m.Override.Size()))
		n2, err2 := m.Override.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		dAtA4 := make([]byte, len(m.Ports)*10)
		var j3 int
		for _, num := range m.Ports {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPolicy(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Paths) > 0 {
		for _, msg := range m.Paths {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPolicy(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPolicy(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthenticationPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkloadSelector != nil {
		l = m.WorkloadSelector.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Match) > 0 {
		for _, e := range m.Match {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if len(m.Require) > 0 {
		for _, e := range m.Require {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CredentialRequirement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Credential)
	if l > 0 {
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.Override != nil {
		l = m.Override.Size()
		n += 1 + l + sovPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Match) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ports) > 0 {
		l = 0
		for _, e := range m.Ports {
			l += sovPolicy(uint64(e))
		}
		n += 1 + sovPolicy(uint64(l)) + l
	}
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPolicy(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPolicy(x uint64) (n int) {
	return sovPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthenticationPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthenticationPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthenticationPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSelector == nil {
				m.WorkloadSelector = &v1beta1.WorkloadSelector{}
			}
			if err := m.WorkloadSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &CredentialRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Match = append(m.Match, &Match{})
			if err := m.Match[len(m.Match)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Require", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Require = append(m.Require, &CredentialRequirement{})
			if err := m.Require[len(m.Require)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CredentialRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CredentialRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CredentialRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credential", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credential = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Override == nil {
				m.Override = &Credential{}
			}
			if err := m.Override.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ports = append(m.Ports, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPolicy
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPolicy
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Ports) == 0 {
					m.Ports = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPolicy
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ports = append(m.Ports, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &v1beta1.StringMatch{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthPolicy
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPolicy
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPolicy(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthPolicy
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPolicy = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPolicy   = fmt.Errorf("proto: integer overflow")
)
