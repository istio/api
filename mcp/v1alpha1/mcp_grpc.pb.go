// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: mcp/v1alpha1/mcp.proto

// $mode: none

package v1alpha1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AggregatedMeshConfigService_StreamAggregatedResources_FullMethodName      = "/istio.mcp.v1alpha1.AggregatedMeshConfigService/StreamAggregatedResources"
	AggregatedMeshConfigService_IncrementalAggregatedResources_FullMethodName = "/istio.mcp.v1alpha1.AggregatedMeshConfigService/IncrementalAggregatedResources"
)

// AggregatedMeshConfigServiceClient is the client API for AggregatedMeshConfigService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AggregatedMeshConfigServiceClient interface {
	// StreamAggregatedResources provides the ability to carefully
	// sequence updates across multiple resource types. A single stream
	// is used with multiple independent MeshConfigRequest /
	// MeshConfigResponses sequences multiplexed via the type URL.
	StreamAggregatedResources(ctx context.Context, opts ...grpc.CallOption) (AggregatedMeshConfigService_StreamAggregatedResourcesClient, error)
	// IncrementalAggregatedResources provides the ability to incrementally
	// update the resources on the client. This supports the goal of
	// scalability of MCP resources.
	IncrementalAggregatedResources(ctx context.Context, opts ...grpc.CallOption) (AggregatedMeshConfigService_IncrementalAggregatedResourcesClient, error)
}

type aggregatedMeshConfigServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAggregatedMeshConfigServiceClient(cc grpc.ClientConnInterface) AggregatedMeshConfigServiceClient {
	return &aggregatedMeshConfigServiceClient{cc}
}

func (c *aggregatedMeshConfigServiceClient) StreamAggregatedResources(ctx context.Context, opts ...grpc.CallOption) (AggregatedMeshConfigService_StreamAggregatedResourcesClient, error) {
	stream, err := c.cc.NewStream(ctx, &AggregatedMeshConfigService_ServiceDesc.Streams[0], AggregatedMeshConfigService_StreamAggregatedResources_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aggregatedMeshConfigServiceStreamAggregatedResourcesClient{stream}
	return x, nil
}

type AggregatedMeshConfigService_StreamAggregatedResourcesClient interface {
	Send(*MeshConfigRequest) error
	Recv() (*MeshConfigResponse, error)
	grpc.ClientStream
}

type aggregatedMeshConfigServiceStreamAggregatedResourcesClient struct {
	grpc.ClientStream
}

func (x *aggregatedMeshConfigServiceStreamAggregatedResourcesClient) Send(m *MeshConfigRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aggregatedMeshConfigServiceStreamAggregatedResourcesClient) Recv() (*MeshConfigResponse, error) {
	m := new(MeshConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aggregatedMeshConfigServiceClient) IncrementalAggregatedResources(ctx context.Context, opts ...grpc.CallOption) (AggregatedMeshConfigService_IncrementalAggregatedResourcesClient, error) {
	stream, err := c.cc.NewStream(ctx, &AggregatedMeshConfigService_ServiceDesc.Streams[1], AggregatedMeshConfigService_IncrementalAggregatedResources_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aggregatedMeshConfigServiceIncrementalAggregatedResourcesClient{stream}
	return x, nil
}

type AggregatedMeshConfigService_IncrementalAggregatedResourcesClient interface {
	Send(*IncrementalMeshConfigRequest) error
	Recv() (*IncrementalMeshConfigResponse, error)
	grpc.ClientStream
}

type aggregatedMeshConfigServiceIncrementalAggregatedResourcesClient struct {
	grpc.ClientStream
}

func (x *aggregatedMeshConfigServiceIncrementalAggregatedResourcesClient) Send(m *IncrementalMeshConfigRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aggregatedMeshConfigServiceIncrementalAggregatedResourcesClient) Recv() (*IncrementalMeshConfigResponse, error) {
	m := new(IncrementalMeshConfigResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AggregatedMeshConfigServiceServer is the server API for AggregatedMeshConfigService service.
// All implementations must embed UnimplementedAggregatedMeshConfigServiceServer
// for forward compatibility
type AggregatedMeshConfigServiceServer interface {
	// StreamAggregatedResources provides the ability to carefully
	// sequence updates across multiple resource types. A single stream
	// is used with multiple independent MeshConfigRequest /
	// MeshConfigResponses sequences multiplexed via the type URL.
	StreamAggregatedResources(AggregatedMeshConfigService_StreamAggregatedResourcesServer) error
	// IncrementalAggregatedResources provides the ability to incrementally
	// update the resources on the client. This supports the goal of
	// scalability of MCP resources.
	IncrementalAggregatedResources(AggregatedMeshConfigService_IncrementalAggregatedResourcesServer) error
	mustEmbedUnimplementedAggregatedMeshConfigServiceServer()
}

// UnimplementedAggregatedMeshConfigServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAggregatedMeshConfigServiceServer struct {
}

func (UnimplementedAggregatedMeshConfigServiceServer) StreamAggregatedResources(AggregatedMeshConfigService_StreamAggregatedResourcesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAggregatedResources not implemented")
}
func (UnimplementedAggregatedMeshConfigServiceServer) IncrementalAggregatedResources(AggregatedMeshConfigService_IncrementalAggregatedResourcesServer) error {
	return status.Errorf(codes.Unimplemented, "method IncrementalAggregatedResources not implemented")
}
func (UnimplementedAggregatedMeshConfigServiceServer) mustEmbedUnimplementedAggregatedMeshConfigServiceServer() {
}

// UnsafeAggregatedMeshConfigServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AggregatedMeshConfigServiceServer will
// result in compilation errors.
type UnsafeAggregatedMeshConfigServiceServer interface {
	mustEmbedUnimplementedAggregatedMeshConfigServiceServer()
}

func RegisterAggregatedMeshConfigServiceServer(s grpc.ServiceRegistrar, srv AggregatedMeshConfigServiceServer) {
	s.RegisterService(&AggregatedMeshConfigService_ServiceDesc, srv)
}

func _AggregatedMeshConfigService_StreamAggregatedResources_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AggregatedMeshConfigServiceServer).StreamAggregatedResources(&aggregatedMeshConfigServiceStreamAggregatedResourcesServer{stream})
}

type AggregatedMeshConfigService_StreamAggregatedResourcesServer interface {
	Send(*MeshConfigResponse) error
	Recv() (*MeshConfigRequest, error)
	grpc.ServerStream
}

type aggregatedMeshConfigServiceStreamAggregatedResourcesServer struct {
	grpc.ServerStream
}

func (x *aggregatedMeshConfigServiceStreamAggregatedResourcesServer) Send(m *MeshConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aggregatedMeshConfigServiceStreamAggregatedResourcesServer) Recv() (*MeshConfigRequest, error) {
	m := new(MeshConfigRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AggregatedMeshConfigService_IncrementalAggregatedResources_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AggregatedMeshConfigServiceServer).IncrementalAggregatedResources(&aggregatedMeshConfigServiceIncrementalAggregatedResourcesServer{stream})
}

type AggregatedMeshConfigService_IncrementalAggregatedResourcesServer interface {
	Send(*IncrementalMeshConfigResponse) error
	Recv() (*IncrementalMeshConfigRequest, error)
	grpc.ServerStream
}

type aggregatedMeshConfigServiceIncrementalAggregatedResourcesServer struct {
	grpc.ServerStream
}

func (x *aggregatedMeshConfigServiceIncrementalAggregatedResourcesServer) Send(m *IncrementalMeshConfigResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aggregatedMeshConfigServiceIncrementalAggregatedResourcesServer) Recv() (*IncrementalMeshConfigRequest, error) {
	m := new(IncrementalMeshConfigRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AggregatedMeshConfigService_ServiceDesc is the grpc.ServiceDesc for AggregatedMeshConfigService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AggregatedMeshConfigService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "istio.mcp.v1alpha1.AggregatedMeshConfigService",
	HandlerType: (*AggregatedMeshConfigServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAggregatedResources",
			Handler:       _AggregatedMeshConfigService_StreamAggregatedResources_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "IncrementalAggregatedResources",
			Handler:       _AggregatedMeshConfigService_IncrementalAggregatedResources_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "mcp/v1alpha1/mcp.proto",
}

const (
	ResourceSource_EstablishResourceStream_FullMethodName = "/istio.mcp.v1alpha1.ResourceSource/EstablishResourceStream"
)

// ResourceSourceClient is the client API for ResourceSource service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourceSourceClient interface {
	// The sink, acting as gRPC client, establishes a new resource stream
	// with the source. The sink sends RequestResources message to
	// and receives Resources messages from the source.
	EstablishResourceStream(ctx context.Context, opts ...grpc.CallOption) (ResourceSource_EstablishResourceStreamClient, error)
}

type resourceSourceClient struct {
	cc grpc.ClientConnInterface
}

func NewResourceSourceClient(cc grpc.ClientConnInterface) ResourceSourceClient {
	return &resourceSourceClient{cc}
}

func (c *resourceSourceClient) EstablishResourceStream(ctx context.Context, opts ...grpc.CallOption) (ResourceSource_EstablishResourceStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResourceSource_ServiceDesc.Streams[0], ResourceSource_EstablishResourceStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &resourceSourceEstablishResourceStreamClient{stream}
	return x, nil
}

type ResourceSource_EstablishResourceStreamClient interface {
	Send(*RequestResources) error
	Recv() (*Resources, error)
	grpc.ClientStream
}

type resourceSourceEstablishResourceStreamClient struct {
	grpc.ClientStream
}

func (x *resourceSourceEstablishResourceStreamClient) Send(m *RequestResources) error {
	return x.ClientStream.SendMsg(m)
}

func (x *resourceSourceEstablishResourceStreamClient) Recv() (*Resources, error) {
	m := new(Resources)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ResourceSourceServer is the server API for ResourceSource service.
// All implementations must embed UnimplementedResourceSourceServer
// for forward compatibility
type ResourceSourceServer interface {
	// The sink, acting as gRPC client, establishes a new resource stream
	// with the source. The sink sends RequestResources message to
	// and receives Resources messages from the source.
	EstablishResourceStream(ResourceSource_EstablishResourceStreamServer) error
	mustEmbedUnimplementedResourceSourceServer()
}

// UnimplementedResourceSourceServer must be embedded to have forward compatible implementations.
type UnimplementedResourceSourceServer struct {
}

func (UnimplementedResourceSourceServer) EstablishResourceStream(ResourceSource_EstablishResourceStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EstablishResourceStream not implemented")
}
func (UnimplementedResourceSourceServer) mustEmbedUnimplementedResourceSourceServer() {}

// UnsafeResourceSourceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourceSourceServer will
// result in compilation errors.
type UnsafeResourceSourceServer interface {
	mustEmbedUnimplementedResourceSourceServer()
}

func RegisterResourceSourceServer(s grpc.ServiceRegistrar, srv ResourceSourceServer) {
	s.RegisterService(&ResourceSource_ServiceDesc, srv)
}

func _ResourceSource_EstablishResourceStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ResourceSourceServer).EstablishResourceStream(&resourceSourceEstablishResourceStreamServer{stream})
}

type ResourceSource_EstablishResourceStreamServer interface {
	Send(*Resources) error
	Recv() (*RequestResources, error)
	grpc.ServerStream
}

type resourceSourceEstablishResourceStreamServer struct {
	grpc.ServerStream
}

func (x *resourceSourceEstablishResourceStreamServer) Send(m *Resources) error {
	return x.ServerStream.SendMsg(m)
}

func (x *resourceSourceEstablishResourceStreamServer) Recv() (*RequestResources, error) {
	m := new(RequestResources)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ResourceSource_ServiceDesc is the grpc.ServiceDesc for ResourceSource service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourceSource_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "istio.mcp.v1alpha1.ResourceSource",
	HandlerType: (*ResourceSourceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EstablishResourceStream",
			Handler:       _ResourceSource_EstablishResourceStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "mcp/v1alpha1/mcp.proto",
}

const (
	ResourceSink_EstablishResourceStream_FullMethodName = "/istio.mcp.v1alpha1.ResourceSink/EstablishResourceStream"
)

// ResourceSinkClient is the client API for ResourceSink service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourceSinkClient interface {
	// The source, acting as gRPC client, establishes a new resource stream
	// with the sink. The sink sends RequestResources message to and
	// receives Resources messages from the source.
	EstablishResourceStream(ctx context.Context, opts ...grpc.CallOption) (ResourceSink_EstablishResourceStreamClient, error)
}

type resourceSinkClient struct {
	cc grpc.ClientConnInterface
}

func NewResourceSinkClient(cc grpc.ClientConnInterface) ResourceSinkClient {
	return &resourceSinkClient{cc}
}

func (c *resourceSinkClient) EstablishResourceStream(ctx context.Context, opts ...grpc.CallOption) (ResourceSink_EstablishResourceStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &ResourceSink_ServiceDesc.Streams[0], ResourceSink_EstablishResourceStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &resourceSinkEstablishResourceStreamClient{stream}
	return x, nil
}

type ResourceSink_EstablishResourceStreamClient interface {
	Send(*Resources) error
	Recv() (*RequestResources, error)
	grpc.ClientStream
}

type resourceSinkEstablishResourceStreamClient struct {
	grpc.ClientStream
}

func (x *resourceSinkEstablishResourceStreamClient) Send(m *Resources) error {
	return x.ClientStream.SendMsg(m)
}

func (x *resourceSinkEstablishResourceStreamClient) Recv() (*RequestResources, error) {
	m := new(RequestResources)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ResourceSinkServer is the server API for ResourceSink service.
// All implementations must embed UnimplementedResourceSinkServer
// for forward compatibility
type ResourceSinkServer interface {
	// The source, acting as gRPC client, establishes a new resource stream
	// with the sink. The sink sends RequestResources message to and
	// receives Resources messages from the source.
	EstablishResourceStream(ResourceSink_EstablishResourceStreamServer) error
	mustEmbedUnimplementedResourceSinkServer()
}

// UnimplementedResourceSinkServer must be embedded to have forward compatible implementations.
type UnimplementedResourceSinkServer struct {
}

func (UnimplementedResourceSinkServer) EstablishResourceStream(ResourceSink_EstablishResourceStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EstablishResourceStream not implemented")
}
func (UnimplementedResourceSinkServer) mustEmbedUnimplementedResourceSinkServer() {}

// UnsafeResourceSinkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourceSinkServer will
// result in compilation errors.
type UnsafeResourceSinkServer interface {
	mustEmbedUnimplementedResourceSinkServer()
}

func RegisterResourceSinkServer(s grpc.ServiceRegistrar, srv ResourceSinkServer) {
	s.RegisterService(&ResourceSink_ServiceDesc, srv)
}

func _ResourceSink_EstablishResourceStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ResourceSinkServer).EstablishResourceStream(&resourceSinkEstablishResourceStreamServer{stream})
}

type ResourceSink_EstablishResourceStreamServer interface {
	Send(*RequestResources) error
	Recv() (*Resources, error)
	grpc.ServerStream
}

type resourceSinkEstablishResourceStreamServer struct {
	grpc.ServerStream
}

func (x *resourceSinkEstablishResourceStreamServer) Send(m *RequestResources) error {
	return x.ServerStream.SendMsg(m)
}

func (x *resourceSinkEstablishResourceStreamServer) Recv() (*Resources, error) {
	m := new(Resources)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ResourceSink_ServiceDesc is the grpc.ServiceDesc for ResourceSink service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourceSink_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "istio.mcp.v1alpha1.ResourceSink",
	HandlerType: (*ResourceSinkServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EstablishResourceStream",
			Handler:       _ResourceSink_EstablishResourceStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "mcp/v1alpha1/mcp.proto",
}
