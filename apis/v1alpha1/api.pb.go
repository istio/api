// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: apis/v1alpha1/api.proto

/*
	Package v1alpha1 is a generated protocol buffer package.

	$title: APIs
	$overview: Configuration for describing the API surface of services and edge load balancers (e.g. ingress).
	$location: https://istio.io/docs/reference/config/istio.apis.v1alpha1.html

	It is generated from these files:
		apis/v1alpha1/api.proto
		apis/v1alpha1/http_generic.proto

	It has these top-level messages:
		SchemaSource
		OpenApiv2
		OpenApiv3
		Grpc
		HttpApi
		Destination
		PortSelector
		HttpGeneric
		HttpGenericPattern
*/
package v1alpha1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/struct"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import reflect "reflect"
import github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// SchemeSource defines the source for an API schema.
type SchemaSource struct {
	// External URL reference to the source API schema. The reference is
	// expected to be immutable and valid for the lifetime of the
	// SchemeSource and encompassing API specification. Changing the
	// referenced spec after the reference is submitted is undefined
	// behavior.
	External string `protobuf:"bytes,1,opt,name=external,proto3" json:"external,omitempty"`
	// String inlined in the configuration. Binary data should be base64
	// encoded.
	InlineString string `protobuf:"bytes,2,opt,name=inline_string,json=inlineString,proto3" json:"inline_string,omitempty"`
}

func (m *SchemaSource) Reset()                    { *m = SchemaSource{} }
func (*SchemaSource) ProtoMessage()               {}
func (*SchemaSource) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

// [OpenAPI v2](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md)
type OpenApiv2 struct {
	// Source of the OpenAPI v2 specification for the API. The inline
	// string representation should be UTF-8 encoded.
	Source *SchemaSource `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
}

func (m *OpenApiv2) Reset()                    { *m = OpenApiv2{} }
func (*OpenApiv2) ProtoMessage()               {}
func (*OpenApiv2) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

// [OpenAPI v3](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md)
type OpenApiv3 struct {
	// Source of the OpenAPI v3 specification for the API. The inline
	// string representation should be UTF-8 encoded.
	Source *SchemaSource `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
}

func (m *OpenApiv3) Reset()                    { *m = OpenApiv3{} }
func (*OpenApiv3) ProtoMessage()               {}
func (*OpenApiv3) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

// A protobuf descriptor set for a gRPC service.
//
// Protocol buffers do not contain descriptions of their own types and
// services. However, the contents of a .proto file itself can be
// represented using protocol buffers (see
// [google/protobuf/descriptor.proto](https://github.com/google/protobuf/blob/master/src/google/protobuf/descriptor.proto)). protoc
// can output a FileDescriptorSet – which represents a set of .proto
// files – using the --descriptor_set_out option.
//
// For example, the following generates the descriptor set from
// bookstore.proto:
//
//     protoc -I. --include_imports --include_source_info \
//         --descriptor_set_out=proto.pb test/proto/bookstore.proto
//
// proto2 and proto3 syntax are supported.
type Grpc struct {
	// Source of the gRPC specification for the API. The inline
	// representation of the protobuf descriptor set should be base64
	// encoded.
	Source *SchemaSource `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Select the set of services in the descriptor set that this grpc
	// definition references. A descriptor set may include multiple
	// service definitions, due to dependencies, but only a subset of
	// them are served by the specified backend.
	SelectedServices []string `protobuf:"bytes,2,rep,name=selected_services,json=selectedServices" json:"selected_services,omitempty"`
}

func (m *Grpc) Reset()                    { *m = Grpc{} }
func (*Grpc) ProtoMessage()               {}
func (*Grpc) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

// API configuration for describing the API surface of a service,
// subset of services, or edge proxies. These API descriptions are
// used to generate API related attibutes and enable other API
// management features, e.g. transcoding (when applicable), unify
// discovery of API services within the mesh. Security definitions,
// extensions, etc. are preserved but not used by Istio.
//
//   apiVersion: apis.istio.io/v1alpha1
//     kind: HttpApi
//     metadata:
//       name: petstore
//     spec:
//       type: OpenApiv2
//       schema:
//         source:
//           external: https://github.com/googleapis/gnostic/blob/master/examples/v2.0/yaml/petstore-simple.yaml
//       destinations:
//       - host: petstore.foo.svc
//         labels:
//           version: v1
//         port:
//           80
//
type HttpApi struct {
	// The type of API schema that is stored in `schema`. Valid types
	// are "OpenApiv2", "OpenApiv3", "Grpc", and "HttpGeneric".
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// Schema for the API. Valid schema types OpenApiv2, OpenApiv3,
	// Grpc, and HttpGeneric in the `apis.istio.io/v1alpha1` apiversion.
	Schema *google_protobuf.Struct `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	// List of destination services that this API is bound
	// to. Destinations may be omitted if one or more gateways is
	// specified.
	Destinations []*Destination `protobuf:"bytes,4,rep,name=destinations" json:"destinations,omitempty"`
	// The names of gateways that should apply these API specifications
	// as defined by routing.istio.io/v1alpha2/Gateway. Gateways may be
	// omitted if one or more destination services is specified.
	Gateways []string `protobuf:"bytes,5,rep,name=gateways" json:"gateways,omitempty"`
	// openapi v2/v3 and grpc are normalized to the generic form.
	Normalized *HttpGeneric `protobuf:"bytes,6,opt,name=normalized" json:"normalized,omitempty"`
}

func (m *HttpApi) Reset()                    { *m = HttpApi{} }
func (*HttpApi) ProtoMessage()               {}
func (*HttpApi) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

// The intent of this message is to define a destination service
// (name) that can be qualified by subset (labels) and port(s). This
// is uses the same concepts defined by routing's Destination,
// DestinationRule, and Subset messages. I could have used those types
// directly but they included things TrafficPolicy which isn't
// appropriate here. It also seemed unintuitive to require creating
// DestinationRules to apply an API spec.
//
// TODO - other policy (e.g. auth, quota) may want to use simlar
// concepts. Should we introduce a common type for such a purpose and,
// if so, where should it live?
//
type Destination struct {
	// REQUIRED. The destination address for traffic captured by this routing
	// rule. Could be a DNS name with wildcard prefix or a CIDR
	// prefix. Depending on the platform, short-names can also be used
	// instead of a FQDN (i.e. has no dots in the name). In such a scenario,
	// the FQDN of the host would be derived based on the underlying
	// platform.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// Labels defines a subset of endpoints of a service. Subsets can be
	// used for scenarios like A/B testing, or routing to a specific
	// version of a service.
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Specifies the port on the destination. Many services only expose a
	// single port or label ports with the protocols they support, in these
	// cases it is not required to explicitly select the port. Note that
	// selection priority is to first match by name and then match by number.
	//
	// Names must comply with DNS label syntax (rfc1035) and therefore cannot
	// collide with numbers. If there are multiple ports on a service with
	// the same protocol the names should be of the form <protocol-name>-<DNS
	// label>.
	Port *PortSelector `protobuf:"bytes,3,opt,name=port" json:"port,omitempty"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

// PortSelector specifies the name or number of a port to be used for
// matching or selection for final routing.
type PortSelector struct {
	// Types that are valid to be assigned to Port:
	//	*PortSelector_Number
	//	*PortSelector_Name
	Port isPortSelector_Port `protobuf_oneof:"port"`
}

func (m *PortSelector) Reset()                    { *m = PortSelector{} }
func (*PortSelector) ProtoMessage()               {}
func (*PortSelector) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

type isPortSelector_Port interface {
	isPortSelector_Port()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PortSelector_Number struct {
	Number uint32 `protobuf:"varint,1,opt,name=number,proto3,oneof"`
}
type PortSelector_Name struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3,oneof"`
}

func (*PortSelector_Number) isPortSelector_Port() {}
func (*PortSelector_Name) isPortSelector_Port()   {}

func (m *PortSelector) GetPort() isPortSelector_Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *PortSelector) GetNumber() uint32 {
	if x, ok := m.GetPort().(*PortSelector_Number); ok {
		return x.Number
	}
	return 0
}

func (m *PortSelector) GetName() string {
	if x, ok := m.GetPort().(*PortSelector_Name); ok {
		return x.Name
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PortSelector) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PortSelector_OneofMarshaler, _PortSelector_OneofUnmarshaler, _PortSelector_OneofSizer, []interface{}{
		(*PortSelector_Number)(nil),
		(*PortSelector_Name)(nil),
	}
}

func _PortSelector_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PortSelector)
	// port
	switch x := m.Port.(type) {
	case *PortSelector_Number:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Number))
	case *PortSelector_Name:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Name)
	case nil:
	default:
		return fmt.Errorf("PortSelector.Port has unexpected type %T", x)
	}
	return nil
}

func _PortSelector_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PortSelector)
	switch tag {
	case 1: // port.number
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Port = &PortSelector_Number{uint32(x)}
		return true, err
	case 2: // port.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Port = &PortSelector_Name{x}
		return true, err
	default:
		return false, nil
	}
}

func _PortSelector_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PortSelector)
	// port
	switch x := m.Port.(type) {
	case *PortSelector_Number:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Number))
	case *PortSelector_Name:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*SchemaSource)(nil), "istio.apis.v1alpha1.SchemaSource")
	proto.RegisterType((*OpenApiv2)(nil), "istio.apis.v1alpha1.OpenApiv2")
	proto.RegisterType((*OpenApiv3)(nil), "istio.apis.v1alpha1.OpenApiv3")
	proto.RegisterType((*Grpc)(nil), "istio.apis.v1alpha1.Grpc")
	proto.RegisterType((*HttpApi)(nil), "istio.apis.v1alpha1.HttpApi")
	proto.RegisterType((*Destination)(nil), "istio.apis.v1alpha1.Destination")
	proto.RegisterType((*PortSelector)(nil), "istio.apis.v1alpha1.PortSelector")
}
func (m *SchemaSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaSource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.External) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.External)))
		i += copy(dAtA[i:], m.External)
	}
	if len(m.InlineString) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.InlineString)))
		i += copy(dAtA[i:], m.InlineString)
	}
	return i, nil
}

func (m *OpenApiv2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenApiv2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *OpenApiv3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenApiv3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Grpc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grpc) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Source.Size()))
		n3, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.SelectedServices) > 0 {
		for _, s := range m.SelectedServices {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HttpApi) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpApi) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.Schema != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Schema.Size()))
		n4, err := m.Schema.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Destinations) > 0 {
		for _, msg := range m.Destinations {
			dAtA[i] = 0x22
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Gateways) > 0 {
		for _, s := range m.Gateways {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Normalized != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Normalized.Size()))
		n5, err := m.Normalized.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Destination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Destination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x12
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.Port != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Port.Size()))
		n6, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *PortSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PortSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != nil {
		nn7, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn7
	}
	return i, nil
}

func (m *PortSelector_Number) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintApi(dAtA, i, uint64(m.Number))
	return i, nil
}
func (m *PortSelector_Name) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}
func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SchemaSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.External)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.InlineString)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *OpenApiv2) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *OpenApiv3) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Grpc) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.SelectedServices) > 0 {
		for _, s := range m.SelectedServices {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *HttpApi) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Schema != nil {
		l = m.Schema.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Destinations) > 0 {
		for _, e := range m.Destinations {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.Gateways) > 0 {
		for _, s := range m.Gateways {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Normalized != nil {
		l = m.Normalized.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Destination) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *PortSelector) Size() (n int) {
	var l int
	_ = l
	if m.Port != nil {
		n += m.Port.Size()
	}
	return n
}

func (m *PortSelector_Number) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovApi(uint64(m.Number))
	return n
}
func (m *PortSelector_Name) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovApi(uint64(l))
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SchemaSource) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SchemaSource{`,
		`External:` + fmt.Sprintf("%v", this.External) + `,`,
		`InlineString:` + fmt.Sprintf("%v", this.InlineString) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenApiv2) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenApiv2{`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "SchemaSource", "SchemaSource", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OpenApiv3) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OpenApiv3{`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "SchemaSource", "SchemaSource", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Grpc) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Grpc{`,
		`Source:` + strings.Replace(fmt.Sprintf("%v", this.Source), "SchemaSource", "SchemaSource", 1) + `,`,
		`SelectedServices:` + fmt.Sprintf("%v", this.SelectedServices) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HttpApi) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HttpApi{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Schema:` + strings.Replace(fmt.Sprintf("%v", this.Schema), "Struct", "google_protobuf.Struct", 1) + `,`,
		`Destinations:` + strings.Replace(fmt.Sprintf("%v", this.Destinations), "Destination", "Destination", 1) + `,`,
		`Gateways:` + fmt.Sprintf("%v", this.Gateways) + `,`,
		`Normalized:` + strings.Replace(fmt.Sprintf("%v", this.Normalized), "HttpGeneric", "HttpGeneric", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Destination) String() string {
	if this == nil {
		return "nil"
	}
	keysForLabels := make([]string, 0, len(this.Labels))
	for k, _ := range this.Labels {
		keysForLabels = append(keysForLabels, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForLabels)
	mapStringForLabels := "map[string]string{"
	for _, k := range keysForLabels {
		mapStringForLabels += fmt.Sprintf("%v: %v,", k, this.Labels[k])
	}
	mapStringForLabels += "}"
	s := strings.Join([]string{`&Destination{`,
		`Host:` + fmt.Sprintf("%v", this.Host) + `,`,
		`Labels:` + mapStringForLabels + `,`,
		`Port:` + strings.Replace(fmt.Sprintf("%v", this.Port), "PortSelector", "PortSelector", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortSelector) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortSelector{`,
		`Port:` + fmt.Sprintf("%v", this.Port) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortSelector_Number) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortSelector_Number{`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PortSelector_Name) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PortSelector_Name{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringApi(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SchemaSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.External = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenApiv2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenApiv2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenApiv2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SchemaSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenApiv3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenApiv3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenApiv3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SchemaSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grpc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grpc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grpc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SchemaSource{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedServices", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectedServices = append(m.SelectedServices, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpApi) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpApi: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpApi: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Schema == nil {
				m.Schema = &google_protobuf.Struct{}
			}
			if err := m.Schema.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destinations = append(m.Destinations, &Destination{})
			if err := m.Destinations[len(m.Destinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Normalized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Normalized == nil {
				m.Normalized = &HttpGeneric{}
			}
			if err := m.Normalized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Destination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Destination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Destination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &PortSelector{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &PortSelector_Number{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = &PortSelector_Name{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("apis/v1alpha1/api.proto", fileDescriptorApi) }

var fileDescriptorApi = []byte{
	// 567 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x41, 0x6f, 0xd3, 0x30,
	0x14, 0x4e, 0xd6, 0x2e, 0x50, 0xa7, 0x93, 0x86, 0xa9, 0xb4, 0xa8, 0x42, 0x56, 0x29, 0x97, 0x4a,
	0xa0, 0x44, 0xeb, 0x84, 0xc4, 0x38, 0xb1, 0xa9, 0x6c, 0x3d, 0x4c, 0x1a, 0x4a, 0x6e, 0x5c, 0x2a,
	0x37, 0x35, 0xa9, 0x45, 0x6a, 0x5b, 0xb6, 0x5b, 0x28, 0x27, 0x7e, 0x02, 0x3f, 0x83, 0x9f, 0xb2,
	0xe3, 0x8e, 0x70, 0xa3, 0xe1, 0xc2, 0x71, 0xe2, 0x17, 0xa0, 0x38, 0xe9, 0x48, 0xa5, 0x0a, 0x0e,
	0xbb, 0xbd, 0xf7, 0xfc, 0xbd, 0xcf, 0xef, 0xf3, 0xf7, 0x12, 0x70, 0x80, 0x05, 0x55, 0xc1, 0xe2,
	0x10, 0xa7, 0x62, 0x8a, 0x0f, 0x03, 0x2c, 0xa8, 0x2f, 0x24, 0xd7, 0x1c, 0x3e, 0xa4, 0x4a, 0x53,
	0xee, 0xe7, 0xc7, 0xfe, 0xfa, 0xb8, 0xfd, 0x28, 0xe1, 0x3c, 0x49, 0x49, 0x60, 0x20, 0xe3, 0xf9,
	0xbb, 0x40, 0x69, 0x39, 0x8f, 0x75, 0xd1, 0xd2, 0x6e, 0x25, 0x3c, 0xe1, 0x26, 0x0c, 0xf2, 0xa8,
	0xac, 0x76, 0x36, 0x6f, 0x98, 0x6a, 0x2d, 0x46, 0x09, 0x61, 0x44, 0xd2, 0xb8, 0x40, 0x74, 0x2f,
	0x41, 0x33, 0x8a, 0xa7, 0x64, 0x86, 0x23, 0x3e, 0x97, 0x31, 0x81, 0x6d, 0x70, 0x9f, 0x7c, 0xd4,
	0x44, 0x32, 0x9c, 0x7a, 0x76, 0xc7, 0xee, 0x35, 0xc2, 0xdb, 0x1c, 0x3e, 0x01, 0x7b, 0x94, 0xa5,
	0x94, 0x91, 0x91, 0xd2, 0x92, 0xb2, 0xc4, 0xdb, 0x31, 0x80, 0x66, 0x51, 0x8c, 0x4c, 0xad, 0x7b,
	0x06, 0x1a, 0x97, 0x82, 0xb0, 0x13, 0x41, 0x17, 0x7d, 0x78, 0x0c, 0x1c, 0x65, 0x78, 0x0d, 0x97,
	0xdb, 0x7f, 0xec, 0x6f, 0x51, 0xe6, 0x57, 0x07, 0x08, 0xcb, 0x86, 0x2a, 0xcf, 0xd1, 0x5d, 0x78,
	0x18, 0xa8, 0x9f, 0x4b, 0x11, 0xdf, 0x81, 0x02, 0x3e, 0x05, 0x0f, 0x14, 0x49, 0x49, 0xac, 0xc9,
	0x64, 0xa4, 0x88, 0x5c, 0xd0, 0x98, 0x28, 0x6f, 0xa7, 0x53, 0xeb, 0x35, 0xc2, 0xfd, 0xf5, 0x41,
	0x54, 0xd6, 0xbb, 0xbf, 0x6d, 0x70, 0x6f, 0xa8, 0xb5, 0x38, 0x11, 0x14, 0x42, 0x50, 0xd7, 0x4b,
	0x41, 0xca, 0x87, 0x34, 0x31, 0x0c, 0x80, 0xa3, 0xcc, 0x25, 0xe6, 0xf5, 0xdc, 0xfe, 0x81, 0x5f,
	0xf8, 0xea, 0xaf, 0x7d, 0xf5, 0x23, 0xe3, 0x6b, 0x58, 0xc2, 0xe0, 0x00, 0x34, 0x27, 0x44, 0x69,
	0xca, 0xb0, 0xa6, 0x9c, 0x29, 0xaf, 0xde, 0xa9, 0xf5, 0xdc, 0x7e, 0x67, 0xeb, 0xf8, 0x83, 0xbf,
	0xc0, 0x70, 0xa3, 0x2b, 0xf7, 0x35, 0xc1, 0x9a, 0x7c, 0xc0, 0x4b, 0xe5, 0xed, 0x9a, 0xd1, 0x6f,
	0x73, 0xf8, 0x0a, 0x00, 0xc6, 0xe5, 0x0c, 0xa7, 0xf4, 0x13, 0x99, 0x78, 0x8e, 0x19, 0x6b, 0x3b,
	0x7f, 0x2e, 0xec, 0xbc, 0xd8, 0x9f, 0xb0, 0xd2, 0xd3, 0xfd, 0x6e, 0x03, 0xb7, 0x72, 0x77, 0x2e,
	0x7c, 0xca, 0x95, 0x5e, 0x0b, 0xcf, 0x63, 0x38, 0x00, 0x4e, 0x8a, 0xc7, 0x24, 0x2d, 0x9e, 0xce,
	0xed, 0x3f, 0xfb, 0x9f, 0x02, 0xff, 0xc2, 0xc0, 0x5f, 0x33, 0x2d, 0x97, 0x61, 0xd9, 0x0b, 0x9f,
	0x83, 0xba, 0xe0, 0x52, 0x7b, 0xb5, 0x7f, 0x98, 0xf8, 0x86, 0x4b, 0x1d, 0x19, 0x5f, 0xb8, 0x0c,
	0x0d, 0xbc, 0x7d, 0x0c, 0xdc, 0x0a, 0x1b, 0xdc, 0x07, 0xb5, 0xf7, 0x64, 0x59, 0x8e, 0x97, 0x87,
	0xb0, 0x05, 0x76, 0x17, 0x38, 0x9d, 0x93, 0x72, 0xa7, 0x8b, 0xe4, 0xe5, 0xce, 0x0b, 0xbb, 0x7b,
	0x06, 0x9a, 0x55, 0x42, 0xe8, 0x01, 0x87, 0xcd, 0x67, 0x63, 0x22, 0x4d, 0xfb, 0xde, 0xd0, 0x0a,
	0xcb, 0x1c, 0xb6, 0x40, 0x9d, 0xe1, 0x59, 0x49, 0x31, 0xb4, 0x42, 0x93, 0x9d, 0x3a, 0xc5, 0xc4,
	0xa7, 0x17, 0x57, 0x2b, 0x64, 0x5d, 0xaf, 0x90, 0xf5, 0x6d, 0x85, 0xac, 0x9b, 0x15, 0xb2, 0x3e,
	0x67, 0xc8, 0xfe, 0x9a, 0x21, 0xeb, 0x2a, 0x43, 0xf6, 0x75, 0x86, 0xec, 0x1f, 0x19, 0xb2, 0x7f,
	0x65, 0xc8, 0xba, 0xc9, 0x90, 0xfd, 0xe5, 0x27, 0xb2, 0xde, 0xb6, 0x0b, 0x71, 0x94, 0xe7, 0xbf,
	0x86, 0x60, 0xe3, 0x53, 0x1e, 0x3b, 0x66, 0x5d, 0x8e, 0xfe, 0x04, 0x00, 0x00, 0xff, 0xff, 0x0d,
	0x8d, 0x00, 0x06, 0x44, 0x04, 0x00, 0x00,
}
