// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "networking/v1alpha3/gateway.proto";

package istio.networking.v1alpha3;

option go_package = "istio.io/api/networking/v1alpha3";

// `Sidecar` describes the describes the configuration of the sidecar proxy
// that mediates inbound and outbound communication to the workload it is
// attached to. By default, Istio will program all sidecar proxies in the
// mesh with the necessary configuration required to reach every workload
// in the mesh, as well as accept traffic on all the ports associated with
// the workload. The Sidecar resource provides a way to fine tune the set
// of ports, protocols that the proxy will accept when forwarding traffic
// to and from the workload. In addition, it is possible to restrict the
// set of services that the proxy can reach when forwarding outbound
// traffic from the workload.
//
// Services and configuration in a mesh are organized into one or more
// namespaces (e.g., a Kubernetes namespace or a CF org/space). A Sidecar
// resource in a namespace will apply to all workloads in the namespace.
// *_Currently, each namespace should have only one Sidecar resource named
// "default"_*. The behavior of the system is undefined if more than one
// Sidecar resource exists in a given namespace.
//
// The example below delcares a Sidecar resource in the prod-us1 namespace
// that configures the sidecar to proxy egress traffic for services in the
// prod-us1 and prod-apis namespaces, and the policy and telemetry service
// (if enabled) in the istio-system namespace.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: Sidecar
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   egress:
//   - hosts:
//     - "prod-us1/*"
//     - "prod-apis/*"
//     - "istio-system/*"
// ```
//
// The example below delcares a Sidecar resource in the prod-us1 namespace
// that accepts inbound HTTP traffic on port 10.10.10.10:9080 and forwards
// it to the attached workload listening on a unix domain socket. In the
// egress direction, in addition to the istio-system namespace, the sidecar
// proxies only HTTP traffic bound for port 9080 for services in the
// prod-us1 namespace.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: Sidecar
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   ingress:
//   - bind: tcp://10.10.10.10:9080
//     protocol: HTTP
//     defaultEndpoint: unix:///var/run/someuds.sock
//   egress:
//   - hosts:
//     - "istio-system/*"
//   - bind: tcp://0.0.0.0:9080
//     protocol: HTTP
//     hosts:
//     - "prod-us1/*"
// ```
//
message Sidecar {
  // Criteria used to select the specific set of pods/VMs on which this
  // sidecar configuration should be applied. If omitted, the sidecar
  // configuration will be applied to all workloads in the current config
  // namespace.
  WorkloadSelector workload_selector = 1;

  // Ingress specifies the configuration of the sidecar for processing
  // inbound traffic to the attached workload. If omitted, Istio will
  // autoconfigure the sidecar based on the information about the workload
  // obtained from the service registry (e.g., exposed ports, services,
  // etc.).
  repeated IstioListener ingress = 2;

  // Egress specifies the configuration of the sidecar for processing
  // outbound traffic from the attached workload to other services in the
  // mesh. If omitted, Istio will autoconfigure the sidecar to be able to
  // reach every service in the mesh.  etc.).
  repeated IstioListener egress = 3;
}

// IstioListener specifies the properties of a single listener on the
// sidecar proxy attached to a workload.
message IstioListener {
  // An arbitrary name associated with the listener used for emitting metrics.
  string name = 1;

  // The ip:port or the unix domain socket to which the listener should be
  // bound to. Format: tcp://x.x.x.x:yyyy or unix:///path/to/uds or
  // unix://@foobar (Linux abstract namespace).  To bind to any IP with
  // specific port, use tcp://0.0.0.0:<port>
  string bind_address = 2;

  // When the bind address is an IP:port, the bindToPort option dictates
  // whether or not the sidecar should bind its listener socket to the
  // specified port. Set bindToPort to false (default) if application
  // traffic entering/leaving a pod/VM is captured automatically through
  // iptables redirection and forwarded to the sidecar on a specific port
  // (see proxyListenPort in the global MeshConfig). When not using
  // iptables for traffic capture, set bindToPort to true to force the
  // sidecar to bind to the specified port. Note that the binding might
  // fail if the application workload is already bound to the same port.
  bool bind_to_port = 3;

  // The protocol associated with this listener.
  // MUST BE one of HTTP|TCP|TLS|MONGO.
  // TLS implies the connection will be routed based on the SNI header.
  // HTTP implies HTTP 1.1/HTTP 2/gRPC
  string protocol = 4;

  // One or more hosts (HTTP or SNI) exposed by the listener in
  // namespace/dnsName format.  _*Hosts will be ignored for ingress
  // servers*_. For egress servers, the hosts field results in importing
  // one or more publicly scoped services and VirtualServices from remote
  // namespaces. The service in a namespace can be a service in the service
  // registry (e.g., a kubernetes or cloud foundry service) or a service
  // specified via ServiceEntry configuration. In addition, any publicly
  // scoped DestinationRule associated with the imported services will also
  // be imported.
  //
  // Set the namespace to * to import a particular service from any
  // available namespace (e.g., "*/foo.example.com"). Set the dnsName field
  // to * to import all services from the specified namespace (e.g.,
  // "prod/*"). Wildcard DNS names can be used to import a specific set of
  // services from the specified namespace (e.g., "prod/*.example.com").
  //
  // NOTE: Only exported services and configuration artifacts from a
  // namespace can be imported. Private services/configuration will not be
  // imported. Refer to the scope setting associated with VirtualService,
  // DestinationRule, ServiceEntry, etc. for details.
  repeated string hosts = 5;

  // The IP endpoint or unix domain socket to which traffic should be
  // forwarded to by default. In the context of an ingress server, this
  // configuration can be used to redirect traffic arriving at the bind
  // point on the sidecar to a port or unix domain socket where the
  // application workload is listening for connections. Format should be
  // tcp://127.0.0.1:PORT or unix:///path/to/socket
  string default_endpoint = 6;
}

// ConfigScope defines the visibility of an Istio configuration artifact in
// a namespace when the namespace is imported.  By default all
// configuration artifacts are public. Configurations with private scope
// will not be imported when the namespace containing the configuration is
// imported in a Sidecar.
enum ConfigScope {
  // Config with this scope are visible to all workloads in the mesh
  PUBLIC = 0;

  // Configs with this scope are visible to only workloads in the same
  // namespace as the configuration resource.
  PRIVATE = 1;
}
