// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/service_export_policy.proto

package v1alpha3

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	_ "istio.io/gogo-genproto/googleapis/google/api"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ServiceExportPolicy configures the exporting of services across the mesh.
//
// We use the term "exporting" to refer to the process where a service's endpoints are
// made accessible to one or more workloads. If no endpoint for a service is exported
// to a workload, the service will be effectively unreachable from the workload.
//
// ServiceExportPolicy supports a variety of use cases that require partitioning the mesh
// and providing customized views of service endpoints to each workload. For example,
// it may be desirable that workloads in a given cluster use only the service endpoints
// residing within the same cluster.
//
// By default (if no ServiceExportPolicy is specified), all services are exported to all
// workloads in the mesh. This means that any workload can call any service endpoint.
//
// The mesh-wide default can be overridden by applying a ServiceExportPolicy to the
// Istio system namespace, using the service wildcard. For example, the following will
// disable export of all services across the mesh by default, requiring that services
// be explicitly exported:
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceExportPolicy
// metadata:
//   name: auto-export-off
//   namespace: istio-system # Using the Istio system namespace applies mesh-wide
// spec:
//   from:
//     service: * # Using wildcard applies to all services.
//   # No "to" is specified, so services will not export by default.
// ```
// {{</tab>}}
// {{</tabset>}}
//
// Similarly, a namespace-wide default can be specified by applying a ServiceExportPolicy
// to the namespace the service being exported.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceExportPolicy
// metadata:
//   name: auto-export-off
//   namespace: example-ns
// spec:
//   from:
//     service: * # Using wildcard applies to all services in the namespace.
//   to:
//     hosts:
//     - *.example.svc.cluster.local # Export to all workloads in the same namespace.
// ```
// {{</tab>}}
// {{</tabset>}}
//
// The selection of service endpoints to be exported can be further refined by selecting
// specific workloads by label. For example, the following policy configures the service
// endpoints in cluster1 to be exported only to workloads running in the same cluster.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceExportPolicy
// metadata:
//   name: myservice-cluster1-to-cluster1-cluster2
//   namespace: example-ns
// spec:
//   from:
//     service: MyService
//     selector:
//       "topology.istio.io/cluster": cluster1
//   to:
//     hosts:
//     - *
//     selector:
//       "topology.istio.io/cluster": cluster1
// ```
// {{</tab>}}
// {{</tabset>}}
//
// The workload selectors can also be used to match against a number of
// label values. The following expands the previous example to export
// the service to both cluster1 and cluster2.
//
// {{<tabset category-name="example">}}
// {{<tab name="v1alpha3" category-value="v1alpha3">}}
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceExportPolicy
// metadata:
//   name: myservice-cluster1-to-cluster1-cluster2
//   namespace: example-ns
// spec:
//   from:
//     service: MyService
//     selector:
//       "topology.istio.io/cluster": cluster1
//   to:
//     hosts:
//     - *
//     selector:
//       "topology.istio.io/cluster": cluster1,cluster2
// ```
// {{</tab>}}
// {{</tabset>}}
//
type ServiceExportPolicy struct {
	// Required. Selects the services to be exported.
	From []*ServiceExportPolicy_From `protobuf:"bytes,1,rep,name=from,proto3" json:"from,omitempty"`
	// Optional. Selects the workloads to which the services are to be exported.
	// Only selected workloads will be able to reach the services. If not set,
	// no workloads will be able to reach the selected services.
	To                   []*ServiceExportPolicy_To `protobuf:"bytes,2,rep,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ServiceExportPolicy) Reset()         { *m = ServiceExportPolicy{} }
func (m *ServiceExportPolicy) String() string { return proto.CompactTextString(m) }
func (*ServiceExportPolicy) ProtoMessage()    {}
func (*ServiceExportPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aadce1629168caa, []int{0}
}
func (m *ServiceExportPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceExportPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceExportPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceExportPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceExportPolicy.Merge(m, src)
}
func (m *ServiceExportPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ServiceExportPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceExportPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceExportPolicy proto.InternalMessageInfo

func (m *ServiceExportPolicy) GetFrom() []*ServiceExportPolicy_From {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ServiceExportPolicy) GetTo() []*ServiceExportPolicy_To {
	if m != nil {
		return m.To
	}
	return nil
}

type ServiceExportPolicy_From struct {
	// Required. Selects a specific service within the namespace to be included in the
	// operation. If a wildcard ('*'), all services within the scope
	// (namespace or mesh-wide) are selected
	Service string `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	// Optional. Further refines the selection of service endpoints that should be
	// included in the operation.
	//
	// Allows multiple values to be specified for a given label, separated by commas. In
	// which case, a workload will be selected if its value matches any of the values
	// specified.
	Selector             *WorkloadSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceExportPolicy_From) Reset()         { *m = ServiceExportPolicy_From{} }
func (m *ServiceExportPolicy_From) String() string { return proto.CompactTextString(m) }
func (*ServiceExportPolicy_From) ProtoMessage()    {}
func (*ServiceExportPolicy_From) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aadce1629168caa, []int{0, 0}
}
func (m *ServiceExportPolicy_From) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceExportPolicy_From) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceExportPolicy_From.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceExportPolicy_From) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceExportPolicy_From.Merge(m, src)
}
func (m *ServiceExportPolicy_From) XXX_Size() int {
	return m.Size()
}
func (m *ServiceExportPolicy_From) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceExportPolicy_From.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceExportPolicy_From proto.InternalMessageInfo

func (m *ServiceExportPolicy_From) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *ServiceExportPolicy_From) GetSelector() *WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

type ServiceExportPolicy_To struct {
	// Required. The hosts to which the selected services should be exported.
	// Could be a DNS name with wildcard prefix.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts,proto3" json:"hosts,omitempty"`
	// Optional. Selects workloads to have access to the exported services. If not
	// set, all workloads in the selected namespaces will be selected.
	//
	// Allows multiple values to be specified for a given label, separated by commas. In
	// which case, a workload will be selected if its value matches any of the values
	// specified.
	Selector             *WorkloadSelector `protobuf:"bytes,2,opt,name=selector,proto3" json:"selector,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ServiceExportPolicy_To) Reset()         { *m = ServiceExportPolicy_To{} }
func (m *ServiceExportPolicy_To) String() string { return proto.CompactTextString(m) }
func (*ServiceExportPolicy_To) ProtoMessage()    {}
func (*ServiceExportPolicy_To) Descriptor() ([]byte, []int) {
	return fileDescriptor_3aadce1629168caa, []int{0, 1}
}
func (m *ServiceExportPolicy_To) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceExportPolicy_To) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceExportPolicy_To.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceExportPolicy_To) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceExportPolicy_To.Merge(m, src)
}
func (m *ServiceExportPolicy_To) XXX_Size() int {
	return m.Size()
}
func (m *ServiceExportPolicy_To) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceExportPolicy_To.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceExportPolicy_To proto.InternalMessageInfo

func (m *ServiceExportPolicy_To) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *ServiceExportPolicy_To) GetSelector() *WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func init() {
	proto.RegisterType((*ServiceExportPolicy)(nil), "istio.networking.v1alpha3.ServiceExportPolicy")
	proto.RegisterType((*ServiceExportPolicy_From)(nil), "istio.networking.v1alpha3.ServiceExportPolicy.From")
	proto.RegisterType((*ServiceExportPolicy_To)(nil), "istio.networking.v1alpha3.ServiceExportPolicy.To")
}

func init() {
	proto.RegisterFile("networking/v1alpha3/service_export_policy.proto", fileDescriptor_3aadce1629168caa)
}

var fileDescriptor_3aadce1629168caa = []byte{
	// 301 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x91, 0x41, 0x4b, 0xf3, 0x30,
	0x18, 0x80, 0x49, 0xb6, 0xef, 0x53, 0xb3, 0x5b, 0xbc, 0xd4, 0x1e, 0x6a, 0xf5, 0x54, 0x10, 0x52,
	0xb6, 0xfe, 0x82, 0x0d, 0xd4, 0x93, 0x20, 0xdd, 0x40, 0xf0, 0x52, 0xb2, 0x36, 0x6b, 0xc3, 0xb2,
	0xbd, 0x25, 0x0d, 0x55, 0xcf, 0xfe, 0x39, 0x8f, 0xfe, 0x04, 0xe9, 0x2f, 0x11, 0xd3, 0x56, 0x2f,
	0x55, 0x10, 0xbc, 0xbe, 0xe4, 0x79, 0x9e, 0xf0, 0xbe, 0x24, 0xdc, 0x0b, 0xf3, 0x00, 0x7a, 0x2b,
	0xf7, 0x79, 0x58, 0x4f, 0xb9, 0x2a, 0x0b, 0x1e, 0x85, 0x95, 0xd0, 0xb5, 0x4c, 0x45, 0x22, 0x1e,
	0x4b, 0xd0, 0x26, 0x29, 0x41, 0xc9, 0xf4, 0x89, 0x95, 0x1a, 0x0c, 0xd0, 0x13, 0x59, 0x19, 0x09,
	0xec, 0x0b, 0x63, 0x3d, 0xe6, 0x9e, 0xe6, 0x00, 0xb9, 0x12, 0x21, 0x2f, 0x65, 0xb8, 0x91, 0x42,
	0x65, 0xc9, 0x5a, 0x14, 0xbc, 0x96, 0xa0, 0x5b, 0xd6, 0x3d, 0x1b, 0x8c, 0xc9, 0x4c, 0xa4, 0xbc,
	0x7b, 0x72, 0xfe, 0x3c, 0x22, 0xc7, 0xcb, 0x36, 0x7f, 0x69, 0xeb, 0xb7, 0x36, 0x4e, 0x6f, 0xc8,
	0x78, 0xa3, 0x61, 0xe7, 0x20, 0x7f, 0x14, 0x4c, 0x66, 0x11, 0xfb, 0xf6, 0x17, 0x6c, 0x80, 0x66,
	0x57, 0x1a, 0x76, 0x8b, 0x71, 0x33, 0x47, 0x38, 0xb6, 0x1a, 0x3a, 0x27, 0xd8, 0x80, 0x83, 0xad,
	0x6c, 0xfa, 0x4b, 0xd9, 0x0a, 0x62, 0x6c, 0xc0, 0x05, 0x32, 0xfe, 0xd0, 0x52, 0x8f, 0x1c, 0x74,
	0xfb, 0x72, 0x90, 0x8f, 0x82, 0xa3, 0xae, 0xd3, 0x0f, 0xe9, 0x35, 0x39, 0xac, 0x84, 0x12, 0xa9,
	0x01, 0xed, 0x60, 0x1f, 0x05, 0x93, 0xd9, 0xc5, 0x0f, 0xc1, 0x3b, 0xd0, 0x5b, 0x05, 0x3c, 0x5b,
	0x76, 0x48, 0xfc, 0x09, 0xbb, 0x92, 0xe0, 0x15, 0x50, 0x97, 0xfc, 0x2b, 0xa0, 0x32, 0x95, 0xdd,
	0x44, 0x1f, 0x6b, 0x47, 0x7f, 0x96, 0x5a, 0xb0, 0x97, 0xc6, 0x43, 0xaf, 0x8d, 0x87, 0xde, 0x1a,
	0x0f, 0xdd, 0xfb, 0xad, 0x43, 0x82, 0xbd, 0xec, 0xc0, 0x0d, 0xd7, 0xff, 0xed, 0xf1, 0xa2, 0xf7,
	0x00, 0x00, 0x00, 0xff, 0xff, 0x22, 0xd0, 0x00, 0x39, 0x4e, 0x02, 0x00, 0x00,
}

func (m *ServiceExportPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceExportPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceExportPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.To) > 0 {
		for iNdEx := len(m.To) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.To[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServiceExportPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.From) > 0 {
		for iNdEx := len(m.From) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.From[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintServiceExportPolicy(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ServiceExportPolicy_From) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceExportPolicy_From) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceExportPolicy_From) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceExportPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Service) > 0 {
		i -= len(m.Service)
		copy(dAtA[i:], m.Service)
		i = encodeVarintServiceExportPolicy(dAtA, i, uint64(len(m.Service)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceExportPolicy_To) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceExportPolicy_To) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceExportPolicy_To) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintServiceExportPolicy(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Hosts) > 0 {
		for iNdEx := len(m.Hosts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Hosts[iNdEx])
			copy(dAtA[i:], m.Hosts[iNdEx])
			i = encodeVarintServiceExportPolicy(dAtA, i, uint64(len(m.Hosts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintServiceExportPolicy(dAtA []byte, offset int, v uint64) int {
	offset -= sovServiceExportPolicy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServiceExportPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.From) > 0 {
		for _, e := range m.From {
			l = e.Size()
			n += 1 + l + sovServiceExportPolicy(uint64(l))
		}
	}
	if len(m.To) > 0 {
		for _, e := range m.To {
			l = e.Size()
			n += 1 + l + sovServiceExportPolicy(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceExportPolicy_From) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovServiceExportPolicy(uint64(l))
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovServiceExportPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServiceExportPolicy_To) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovServiceExportPolicy(uint64(l))
		}
	}
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovServiceExportPolicy(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovServiceExportPolicy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozServiceExportPolicy(x uint64) (n int) {
	return sovServiceExportPolicy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceExportPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceExportPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceExportPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceExportPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From, &ServiceExportPolicy_From{})
			if err := m.From[len(m.From)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To, &ServiceExportPolicy_To{})
			if err := m.To[len(m.To)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceExportPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceExportPolicy_From) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceExportPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: From: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: From: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceExportPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceExportPolicy_To) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceExportPolicy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: To: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: To: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceExportPolicy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthServiceExportPolicy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServiceExportPolicy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServiceExportPolicy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceExportPolicy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthServiceExportPolicy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupServiceExportPolicy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthServiceExportPolicy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthServiceExportPolicy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServiceExportPolicy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupServiceExportPolicy = fmt.Errorf("proto: unexpected end of group")
)
