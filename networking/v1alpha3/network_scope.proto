// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

package istio.networking.v1alpha3;

option go_package = "istio.io/api/networking/v1alpha3";

// `NetworkScope` describes the set of services that a workload depends on
// for its operation. In other words, it describes the properties of egress
// traffic from a given workload. By default, the service mesh established
// by Istio will have a full mesh connectivity - i.e. every workload will
// have proxy configuration required to reach every other workload in the
// mesh. However most connectivity graphs are sparse in practice. The
// NetworkScope provides a way to prune the connectivity graph
// (i.e. dependencies) associated with each workload.
//
// Services and configuration in a mesh are organized into one or more
// namespaces (e.g., a Kubernetes namespace or a CF org/space).  Workloads
// in a namespace will be able to reach other workloads in the same
// namespace. To declare dependencies on workloads in other namespaces, a
// NetworkScope resource has to be specified in the current
// namespace. *_Each namespace can have only one NetworkScope
// resource_*. The behavior of the system is undefined if more than one
// NetworkScope resource exists in a given namespace. The set of
// dependencies specified in a NetworkScope resource will be used to
// compute the [outbound] connectivity graph for every workload in the
// namespace.
//
// NOTE: If workloads in the mesh depend only on other workloads in the
// same namespace, use the mesh global setting to specify the default
// network scope as CURRENT_NAMESPACE. To facilitate incremental pruning of
// the connectivity graph, the default network scope for the mesh is set to
// ALL_NAMESPACES. In otherwords, every workload will be able to reach
// every other workload. Specifying a NetworkScope resource in a namespace
// will automatically prune the configuration for the workloads in that
// namespace.
//
// The following examples illustrate a few specific use cases of NetworkScope.
//
// The example below delcares a NetworkScope resource in the prod-us1
// namespace. The workload with the `version: newlandingpage` label will be
// able to reach all services declared in the egress namespace as well as
// the landing.qa.foo.com service in the qa namespace. All other workloads
// in the prod-us1 namespace will be able to reach the services in the
// egress namespace only.
//
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: NetworkScope
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   dependencies:
//   - sourceWorkloadLabels:
//       version: newlandingpage
//     imports:
//     - namespace: qa
//       host: landing.qa.foo.com
//     - namespace: egress
//   - imports:
//     - namespace: egress
// ```
//
// In a mesh where the default network scope is set to CURRENT_NAMESPACE
// only, if one or more workloads need to be able to reach every other
// service in the mesh (e.g., metrics collection server), the following
// NetworkScope resource can be used to specify such a dependency:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: NetworkScope
// metadata:
//   name: default
//   namespace: metrics-collection
// spec:
//   dependencies:
//   - sourceWorkloadLabels:
//        app: metricsScraper
//     imports:
//     - namespace: '*'
// ```
//
// The configuration above will allow workloads in the metrics-collection
// namespace with the labels `app: metricsScraper` to access service in any
// namespace while other workloads in the same namespace will be configured
// for namespace local access as per the global default network scope
// (CURRENT_NAMESPACE).
//
message NetworkScope {

  // Import describes the set of namespaces whose exported services
  // (real/virtual) will be accessed by workloads in a given namespace. The
  // sidecars attached to the workloads will be configured with information
  // required to reach the imported services only. The gateways in the
  // current namespace will only honor imported VirtualServices instead of
  // every VirtualService that binds itself to the gateway.
  //
  // Importing a service from a namespace will automatically import the
  // exported configuration artifacts associated with the service, such as
  // VirtualService, DestinationRule, etc. The service in a namespace can be
  // a service in the service registry (e.g., a kubernetes or cloud foundry
  // service) or a service specified via ServiceEntry configuration.
  //
  // NOTE: Only exported services and configuration artifacts from a
  // namespace can be imported. Private services/configuration will not be
  // imported. See the scope setting associated with VirtualService,
  // DestinationRule, ServiceEntry, etc.
  message Import {
    // The configuration namespace whose services need to be imported.
    // Specify * to import all namespaces. The import can be scoped further
    // by specifying individual hosts.
    string namespace = 1;

    // A FQDN or wildcard prefixed DNS name of the host to import from the
    // specified namespace. The hostnames include names of services from the
    // service registry as well as those specified in a VirtualService.
    string host = 2;
  };

  // Dependency describes a workload and the set of service dependencies
  // for the workload.
  message Dependency {
    // One or more labels that indicate a specific set of pods/VMs on which
    // this dependency configuration should be applied.  The scope of label
    // search is platform dependent.  On Kubernetes, for example, the scope
    // includes pods running in the namespace in which the NetworkScope
    // resource is present.  If the sourceWorkloadLabels are omitted, the
    // imports specified will be applicable to all workloads in the current
    // configuration namespace.
    map<string, string> source_workload_labels = 1;

    // REQUIRED: Import describes the set of namespaces whose exported
    // services will be accessed by the workloads selected by the
    // sourceWorkloadLabels. The sidecars attached to the workloads will be
    // configured with information required to reach other services in the
    // same namespace and the imported services. In addition to the
    // explicitly specified namespaces, namespaces specified in the global
    // mesh config (through NetworkScope.sharedNamespaces) will also be
    // imported.
    repeated Import imports = 2;
  };

  // REQUIRED. The set of services that workloads in this namespace are
  // expected to talk to, in addition to other workloads in the same
  // namespace. Dependencies describe the properties of egress traffic from
  // a given workload.
  repeated Dependency dependencies = 1;
}

// ConfigScope defines the visibility of an Istio configuration artifact in
// a namespace when the namespace is imported.  By default all
// configuration artifacts are public. Configurations with private scope
// will not be imported when the namespace containing the configuration is
// imported in a NetworkScope.
enum ConfigScope {
  PUBLIC = 0;
  PRIVATE = 1;
}
