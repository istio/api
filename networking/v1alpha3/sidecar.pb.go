// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/sidecar.proto

package v1alpha3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ConfigScope defines the visibility of an Istio configuration artifact in
// a namespace when the namespace is imported.  By default all
// configuration artifacts are public. Configurations with private scope
// will not be imported when the namespace containing the configuration is
// imported in a Sidecar.
type ConfigScope int32

const (
	// Config with this scope are visible to all workloads in the mesh
	ConfigScope_PUBLIC ConfigScope = 0
	// Configs with this scope are visible to only workloads in the same
	// namespace as the configuration resource.
	ConfigScope_PRIVATE ConfigScope = 1
)

var ConfigScope_name = map[int32]string{
	0: "PUBLIC",
	1: "PRIVATE",
}
var ConfigScope_value = map[string]int32{
	"PUBLIC":  0,
	"PRIVATE": 1,
}

func (x ConfigScope) String() string {
	return proto.EnumName(ConfigScope_name, int32(x))
}
func (ConfigScope) EnumDescriptor() ([]byte, []int) { return fileDescriptorSidecar, []int{0} }

// `Sidecar` describes the describes the configuration of the sidecar proxy
// that mediates inbound and outbound communication to the workload it is
// attached to. By default, Istio will program all sidecar proxies in the
// mesh with the necessary configuration required to reach every workload
// in the mesh, as well as accept traffic on all the ports associated with
// the workload. The Sidecar resource provides a way to fine tune the set
// of ports, protocols that the proxy will accept when forwarding traffic
// to and from the workload. In addition, it is possible to restrict the
// set of services that the proxy can reach when forwarding outbound
// traffic from the workload.
//
// Services and configuration in a mesh are organized into one or more
// namespaces (e.g., a Kubernetes namespace or a CF org/space). A Sidecar
// resource in a namespace will apply to all workloads selected using the
// workloadSelector. In the absence of a workloadSelector, it will apply to
// all workloads in the namespace. When determining the Sidecar resource to
// be applied to a workload, preference will be given to the resource with
// a workloadSelector that selects this workload, over a Sidecar resource
// without any workloadSelector.
//
// NOTE: *_Each namespace can have only one Sidecar resource without any
// workload selector_*. The behavior of the system is undefined if more
// than one selector-less Sidecar resources exist in a given namespace. The
// behavior of the system is undefined if two or more Sidecar resources
// with a workload selector select the same workload.
//
// The example below delcares a Sidecar resource in the prod-us1 namespace
// that configures the sidecar to allow egress traffic to services in the
// prod-us1 and prod-apis namespaces, and the policy and telemetry service
// (if enabled) in the istio-system namespace.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: Sidecar
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   egress:
//   - hosts:
//     - "prod-us1/*"
//     - "prod-apis/*"
//     - "istio-system/*"
// ```
//
type Sidecar struct {
	// $hide_from_docs
	// Criteria used to select the specific set of pods/VMs on which this
	// sidecar configuration should be applied. If omitted, the sidecar
	// configuration will be applied to all workloads in the current config
	// namespace.
	WorkloadSelector *WorkloadSelector `protobuf:"bytes,1,opt,name=workload_selector,json=workloadSelector" json:"workload_selector,omitempty"`
	// $hide_from_docs
	// Ingress specifies the configuration of the sidecar for processing
	// inbound traffic to the attached workload. If omitted, Istio will
	// autoconfigure the sidecar based on the information about the workload
	// obtained from the orchestration platform (e.g., exposed ports, services,
	// etc.).
	Ingress []*IstioListener `protobuf:"bytes,2,rep,name=ingress" json:"ingress,omitempty"`
	// Egress specifies the configuration of the sidecar for processing
	// outbound traffic from the attached workload to other services in the
	// mesh. If omitted, Istio will autoconfigure the sidecar to be able to
	// reach every service in the mesh that is visible to this namespace.
	Egress []*IstioListener `protobuf:"bytes,3,rep,name=egress" json:"egress,omitempty"`
}

func (m *Sidecar) Reset()                    { *m = Sidecar{} }
func (m *Sidecar) String() string            { return proto.CompactTextString(m) }
func (*Sidecar) ProtoMessage()               {}
func (*Sidecar) Descriptor() ([]byte, []int) { return fileDescriptorSidecar, []int{0} }

func (m *Sidecar) GetWorkloadSelector() *WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *Sidecar) GetIngress() []*IstioListener {
	if m != nil {
		return m.Ingress
	}
	return nil
}

func (m *Sidecar) GetEgress() []*IstioListener {
	if m != nil {
		return m.Egress
	}
	return nil
}

// IstioListener specifies the properties of a single listener on the
// sidecar proxy attached to a workload.
type IstioListener struct {
	// An optional arbitrary name associated with the listener used for
	// emitting metrics.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// $hide_from_docs
	// REQUIRED for ingress. The port associated with the listener. If using
	// unix domain socket, use 0 as the port number, with a valid
	// protocol. In the egress path, the port if specified, will be used as
	// the default destination port associated with the imported hosts. If
	// the port is omitted, Istio will infer the listener ports based on the
	// imported hosts. Note that when multiple egress listeners are
	// specified, where one or more listeners have specific ports while
	// others have no port, the hosts exposed on a listener port will be
	// based on the listener with the most specific port.
	Port *Port `protobuf:"bytes,2,opt,name=port" json:"port,omitempty"`
	// $hide_from_docs
	// The ip or the unix domain socket to which the listener should be bound
	// to. Port MUST be specified if bind is not empty. Format:
	// x.x.x.x or unix:///path/to/uds or unix://@foobar (Linux abstract
	// namespace). If omitted, Istio will autoconfigure the defaults based on
	// imported services and the workload to which this configuration is
	// applied to.
	Bind string `protobuf:"bytes,3,opt,name=bind,proto3" json:"bind,omitempty"`
	// $hide_from_docs
	// When the bind address is an IP, the bindToPort option dictates
	// whether or not the sidecar should bind its listener socket to the
	// specified port. Set bindToPort to false (default) if application
	// traffic entering/leaving a pod/VM is captured automatically through
	// iptables redirection and forwarded to the sidecar on a specific port
	// (see proxyListenPort in the global MeshConfig). When not using
	// iptables for traffic capture, set bindToPort to true to force the
	// sidecar to bind to the specified port. Note that the binding might
	// fail if the application workload is already bound to the same port.
	BindToPort bool `protobuf:"varint,4,opt,name=bind_to_port,json=bindToPort,proto3" json:"bind_to_port,omitempty"`
	// One or more services/virtualServices exposed by the listener in
	// namespace/dnsName format.  _*Hosts will be ignored for ingress
	// servers*_. For egress servers, the hosts field results in importing
	// one or more publicly scoped services and VirtualServices from remote
	// namespaces. The service in a namespace can be a service in the service
	// registry (e.g., a kubernetes or cloud foundry service) or a service
	// specified via ServiceEntry configuration. In addition, any publicly
	// scoped DestinationRule associated with the imported services will also
	// be imported.
	//
	// Set the namespace to * to import a particular service from any
	// available namespace (e.g., "*/foo.example.com"). Set the dnsName field
	// to * to import all services from the specified namespace (e.g.,
	// "prod/*"). The services should be specified using FQDN format.
	//
	// NOTE: Only exported services and configuration artifacts from a
	// namespace can be imported. Private services/configuration will not be
	// imported. Refer to the scope setting associated with VirtualService,
	// DestinationRule, ServiceEntry, etc. for details.
	Hosts []string `protobuf:"bytes,5,rep,name=hosts" json:"hosts,omitempty"`
	// The IP endpoint or unix domain socket to which traffic should be
	// forwarded to by default. In the context of an ingress server, this
	// configuration can be used to redirect traffic arriving at the bind
	// point on the sidecar to a port or unix domain socket where the
	// application workload is listening for connections. Format should be
	// 127.0.0.1:PORT or unix:///path/to/socket
	DefaultEndpoint string `protobuf:"bytes,6,opt,name=default_endpoint,json=defaultEndpoint,proto3" json:"default_endpoint,omitempty"`
}

func (m *IstioListener) Reset()                    { *m = IstioListener{} }
func (m *IstioListener) String() string            { return proto.CompactTextString(m) }
func (*IstioListener) ProtoMessage()               {}
func (*IstioListener) Descriptor() ([]byte, []int) { return fileDescriptorSidecar, []int{1} }

func (m *IstioListener) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IstioListener) GetPort() *Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *IstioListener) GetBind() string {
	if m != nil {
		return m.Bind
	}
	return ""
}

func (m *IstioListener) GetBindToPort() bool {
	if m != nil {
		return m.BindToPort
	}
	return false
}

func (m *IstioListener) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *IstioListener) GetDefaultEndpoint() string {
	if m != nil {
		return m.DefaultEndpoint
	}
	return ""
}

// WorkloadSelector specifies the criteria used to determine if the Gateway
// or Sidecar resource can be applied to a proxy. The matching criteria
// includes the metadata associated with a proxy, workload info such as
// labels attached to the pod/VM, or any other info that the proxy provides
// to Istio during the initial handshake. If multiple conditions are
// specified, all conditions need to match in order for the workload to be
// selected. Currently, only label based selection mechanism is supported.
type WorkloadSelector struct {
	// One or more labels that indicate a specific set of pods/VMs on which
	// this sidecar configuration should be applied. The scope of label
	// search is restricted to the configuration namespace in which the the
	// resource is present.
	Labels map[string]string `protobuf:"bytes,1,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *WorkloadSelector) Reset()                    { *m = WorkloadSelector{} }
func (m *WorkloadSelector) String() string            { return proto.CompactTextString(m) }
func (*WorkloadSelector) ProtoMessage()               {}
func (*WorkloadSelector) Descriptor() ([]byte, []int) { return fileDescriptorSidecar, []int{2} }

func (m *WorkloadSelector) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func init() {
	proto.RegisterType((*Sidecar)(nil), "istio.networking.v1alpha3.Sidecar")
	proto.RegisterType((*IstioListener)(nil), "istio.networking.v1alpha3.IstioListener")
	proto.RegisterType((*WorkloadSelector)(nil), "istio.networking.v1alpha3.WorkloadSelector")
	proto.RegisterEnum("istio.networking.v1alpha3.ConfigScope", ConfigScope_name, ConfigScope_value)
}
func (m *Sidecar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sidecar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WorkloadSelector != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSidecar(dAtA, i, uint64(m.WorkloadSelector.Size()))
		n1, err := m.WorkloadSelector.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSidecar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Egress) > 0 {
		for _, msg := range m.Egress {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintSidecar(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IstioListener) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IstioListener) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSidecar(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Port != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSidecar(dAtA, i, uint64(m.Port.Size()))
		n2, err := m.Port.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Bind) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSidecar(dAtA, i, uint64(len(m.Bind)))
		i += copy(dAtA[i:], m.Bind)
	}
	if m.BindToPort {
		dAtA[i] = 0x20
		i++
		if m.BindToPort {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.DefaultEndpoint) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSidecar(dAtA, i, uint64(len(m.DefaultEndpoint)))
		i += copy(dAtA[i:], m.DefaultEndpoint)
	}
	return i, nil
}

func (m *WorkloadSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkloadSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xa
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovSidecar(uint64(len(k))) + 1 + len(v) + sovSidecar(uint64(len(v)))
			i = encodeVarintSidecar(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintSidecar(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintSidecar(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func encodeVarintSidecar(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Sidecar) Size() (n int) {
	var l int
	_ = l
	if m.WorkloadSelector != nil {
		l = m.WorkloadSelector.Size()
		n += 1 + l + sovSidecar(uint64(l))
	}
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovSidecar(uint64(l))
		}
	}
	if len(m.Egress) > 0 {
		for _, e := range m.Egress {
			l = e.Size()
			n += 1 + l + sovSidecar(uint64(l))
		}
	}
	return n
}

func (m *IstioListener) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSidecar(uint64(l))
	}
	if m.Port != nil {
		l = m.Port.Size()
		n += 1 + l + sovSidecar(uint64(l))
	}
	l = len(m.Bind)
	if l > 0 {
		n += 1 + l + sovSidecar(uint64(l))
	}
	if m.BindToPort {
		n += 2
	}
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovSidecar(uint64(l))
		}
	}
	l = len(m.DefaultEndpoint)
	if l > 0 {
		n += 1 + l + sovSidecar(uint64(l))
	}
	return n
}

func (m *WorkloadSelector) Size() (n int) {
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSidecar(uint64(len(k))) + 1 + len(v) + sovSidecar(uint64(len(v)))
			n += mapEntrySize + 1 + sovSidecar(uint64(mapEntrySize))
		}
	}
	return n
}

func sovSidecar(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSidecar(x uint64) (n int) {
	return sovSidecar(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Sidecar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSidecar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sidecar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sidecar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSelector == nil {
				m.WorkloadSelector = &WorkloadSelector{}
			}
			if err := m.WorkloadSelector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &IstioListener{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Egress = append(m.Egress, &IstioListener{})
			if err := m.Egress[len(m.Egress)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSidecar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSidecar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IstioListener) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSidecar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IstioListener: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IstioListener: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Port == nil {
				m.Port = &Port{}
			}
			if err := m.Port.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindToPort", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BindToPort = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultEndpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultEndpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSidecar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSidecar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkloadSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSidecar
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkloadSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkloadSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSidecar
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSidecar
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSidecar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSidecar
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSidecar
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSidecar
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSidecar(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthSidecar
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSidecar(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSidecar
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSidecar(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSidecar
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSidecar
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSidecar
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSidecar
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSidecar(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSidecar = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSidecar   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("networking/v1alpha3/sidecar.proto", fileDescriptorSidecar) }

var fileDescriptorSidecar = []byte{
	// 438 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x71, 0xd3, 0xa5, 0xf4, 0x0d, 0x88, 0x60, 0x71, 0x08, 0x3b, 0x94, 0xd0, 0x03, 0x0a,
	0x20, 0x25, 0x62, 0x3d, 0xf0, 0xe7, 0x04, 0x9d, 0x7a, 0xa8, 0x54, 0x89, 0xca, 0x1d, 0x7f, 0xc4,
	0x25, 0x72, 0x1b, 0x2f, 0xb3, 0x16, 0xec, 0xc8, 0xf6, 0x56, 0xf5, 0xcb, 0xf0, 0x79, 0xb8, 0xc1,
	0x47, 0x40, 0xbd, 0xf1, 0x2d, 0x90, 0x9d, 0x4c, 0xc0, 0xb4, 0x4d, 0xea, 0x29, 0xaf, 0x1f, 0xbf,
	0xcf, 0xcf, 0x79, 0x1f, 0x1b, 0x1e, 0x0b, 0x66, 0xd6, 0x52, 0x9d, 0x72, 0x51, 0x66, 0xe7, 0x2f,
	0x68, 0x55, 0x9f, 0xd0, 0x51, 0xa6, 0x79, 0xc1, 0x56, 0x54, 0xa5, 0xb5, 0x92, 0x46, 0xe2, 0x87,
	0x5c, 0x1b, 0x2e, 0xd3, 0xbf, 0x8d, 0xe9, 0x45, 0xe3, 0xfe, 0x95, 0xee, 0x92, 0x1a, 0xb6, 0xa6,
	0x9b, 0xc6, 0x3d, 0xfc, 0x8d, 0xa0, 0xb7, 0x68, 0x78, 0xf8, 0x33, 0xdc, 0xb7, 0xdd, 0x95, 0xa4,
	0x45, 0xae, 0x59, 0xc5, 0x56, 0x46, 0xaa, 0x08, 0xc5, 0x28, 0x09, 0x0e, 0x9e, 0xa7, 0xd7, 0x9e,
	0x92, 0x7e, 0x6a, 0x3d, 0x8b, 0xd6, 0x42, 0xc2, 0xf5, 0x25, 0x05, 0x8f, 0xa1, 0xc7, 0x45, 0xa9,
	0x98, 0xd6, 0x51, 0x27, 0xf6, 0x92, 0xe0, 0x20, 0xb9, 0x81, 0x37, 0xb5, 0x3b, 0x33, 0xae, 0x0d,
	0x13, 0x4c, 0x91, 0x0b, 0x23, 0x7e, 0x0b, 0x3e, 0x6b, 0x10, 0xde, 0x8e, 0x88, 0xd6, 0x37, 0xfc,
	0x81, 0xe0, 0xee, 0x7f, 0x3b, 0x18, 0x43, 0x57, 0xd0, 0xaf, 0xcc, 0x0d, 0xd9, 0x27, 0xae, 0xc6,
	0x23, 0xe8, 0xd6, 0x52, 0x99, 0xa8, 0xe3, 0x06, 0x7f, 0x74, 0xc3, 0x29, 0x73, 0xa9, 0x0c, 0x71,
	0xcd, 0x16, 0xb4, 0xe4, 0xa2, 0x88, 0xbc, 0x06, 0x64, 0x6b, 0x1c, 0xc3, 0x1d, 0xfb, 0xcd, 0x8d,
	0xcc, 0x1d, 0xb0, 0x1b, 0xa3, 0xe4, 0x36, 0x01, 0xab, 0x1d, 0x49, 0xeb, 0xc5, 0x0f, 0x60, 0xef,
	0x44, 0x6a, 0xa3, 0xa3, 0xbd, 0xd8, 0x4b, 0xfa, 0xa4, 0x59, 0xe0, 0xa7, 0x10, 0x16, 0xec, 0x98,
	0x9e, 0x55, 0x26, 0x67, 0xa2, 0xa8, 0x25, 0x17, 0x26, 0xf2, 0x1d, 0xf7, 0x5e, 0xab, 0x4f, 0x5a,
	0x79, 0xf8, 0x0d, 0x41, 0x78, 0x39, 0x7e, 0xfc, 0x1e, 0xfc, 0x8a, 0x2e, 0x59, 0xa5, 0x23, 0xe4,
	0x82, 0x7a, 0xb9, 0xc3, 0xdd, 0xa5, 0x33, 0xe7, 0x9c, 0x08, 0xa3, 0x36, 0xa4, 0xc5, 0xec, 0xbf,
	0x86, 0xe0, 0x1f, 0x19, 0x87, 0xe0, 0x9d, 0xb2, 0x4d, 0x9b, 0x99, 0x2d, 0xed, 0x1c, 0xe7, 0xb4,
	0x3a, 0x63, 0x2e, 0xb3, 0x3e, 0x69, 0x16, 0x6f, 0x3a, 0xaf, 0xd0, 0xb3, 0x27, 0x10, 0x1c, 0x4a,
	0x71, 0xcc, 0xcb, 0xc5, 0x4a, 0xd6, 0x0c, 0x03, 0xf8, 0xf3, 0x0f, 0xe3, 0xd9, 0xf4, 0x30, 0xbc,
	0x85, 0x03, 0xe8, 0xcd, 0xc9, 0xf4, 0xe3, 0xbb, 0xa3, 0x49, 0x88, 0xc6, 0xe9, 0xf7, 0xed, 0x00,
	0xfd, 0xdc, 0x0e, 0xd0, 0xaf, 0xed, 0x00, 0x7d, 0x89, 0x9b, 0x1f, 0xe6, 0x32, 0xa3, 0x35, 0xcf,
	0xae, 0x78, 0xc4, 0x4b, 0xdf, 0xbd, 0xde, 0xd1, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x37,
	0x9e, 0xaa, 0x20, 0x03, 0x00, 0x00,
}
