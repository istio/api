// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/struct.proto";

// $title: Envoy Filter
// $description: Configuration affecting insertion of custom Envoy filters.
// $location: https://istio.io/docs/reference/config/networking/v1alpha3/envoy-filter.html

// `EnvoyFilter` describes Envoy proxy-specific filters that can be used to
// customize the Envoy proxy configuration generated by Istio networking
// subsystem (Pilot). This feature must be used with care, as incorrect
// configurations could potentially destabilize the entire mesh.
//
// NOTE 1: Since this is break glass configuration, there will not be any
// backward compatibility across different Istio releases. In other words,
// this configuration is subject to change based on internal implementation
// of Istio networking subsystem.
//
// NOTE 2: When multiple EnvoyFilters are bound to the same workload, all filter
// configurations will be processed sequentially in order of creation time.
// The behavior is undefined if multiple EnvoyFilter configurations conflict
// with each other.
//
// NOTE 3: For filters of `filterType: HTTP` you must include a `listenerMatch` section
// with a `listenerProtocol: HTTP` or the filter have no effect.
//
// The following example for Kubernetes enables Envoy's Lua filter for all
// inbound HTTP calls arriving at service port 8080 of the reviews service pod with
// labels "app: reviews".
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
// spec:
//   workloadLabels:
//     app: reviews
//   filters:
//   - listenerMatch:
//       portNumber: 8080
//       context: SIDECAR_INBOUND # will match with the inbound listener for reviews:8080
//       listenerProtocol: HTTP
//     filterName: envoy.lua
//     filterType: HTTP
//     filterConfig:
//       inlineCode: |
//         ... lua code ...
// ```
//
// For a more flexible approach, use Listener/Cluster to specify a
// JSON Path based expression to match in the generated Envoy config
// and a replacement value for the matched section. It can be used to
// arbitrarily modify the generated Envoy config for a sidecar or
// gateway. No guarantee is made with respect to the applicability of
// the generated Envoy config. The following example overwrites
// certain fields (HTTP idle timeout and X-Forward-For trusted hops)
// in the HTTP connection manager in a listener on the ingress gateway
// while leaving the rest as is.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: hcm-tweaks
//   namespace: istio-system
// spec:
//   workloadLabels:
//     istio: ingress-gateway
//   listeners:
//   - match:
//       context: GATEWAY # will match all gateway listeners
//     patches:
//     - path: '{.filter_chains[*].filters[?(@.name=="envoy.http_connection_manager")]}'
//       operation: ADD
//       value: |
//         idle_timeout: 30s
//         xff_num_trusted_hops: 5
//```
//
package istio.networking.v1alpha3;

option go_package = "istio.io/api/networking/v1alpha3";

message EnvoyFilter {
  // Zero or more labels that indicate a specific set of pods/VMs whose
  // proxies should be configured to use these additional filters.  The
  // scope of label search is platform dependent. On Kubernetes, for
  // example, the scope includes pods running in all reachable
  // namespaces. Omitting the selector applies the filter to all proxies in
  // the mesh.
  map<string, string> workload_labels = 1;

  enum Context {
    // All listeners/routes
    ANY = 0;

    // Inbound listener/route in sidecar
    SIDECAR_INBOUND = 1;

    // Outbound listener/route in sidecar
    SIDECAR_OUTBOUND = 2;

    // Gateway listener/route
    GATEWAY = 3;
  };

  // Select a listener to add the filter to based on the match conditions.
  // All conditions specified in the ListenerMatch must be met for the filter
  // to be applied to a listener.
  message ListenerMatch {
    // The service port/gateway port to which traffic is being
    // sent/received. If not specified, matches all listeners. Even though
    // inbound listeners are generated for the instance/pod ports, only
    // service ports should be used to match listeners.
    uint32 port_number = 1;

    // Instead of using specific port numbers, a set of ports matching a
    // given port name prefix can be selected. E.g., "mongo" selects ports
    // named mongo-port, mongo, mongoDB, MONGO, etc. Matching is case
    // insensitive.
    string port_name_prefix = 2;

    // Deprecated. Use the `context` field instead.
    // $hide_from_docs
    Context listener_type = 3 [deprecated=true];

    // Inbound vs outbound sidecar listener or gateway listener. If
    // not specified, matches all listeners.
    Context context = 6;

    enum ListenerProtocol {
      // All protocols
      ALL = 0;
      // HTTP or HTTPS (with termination) / HTTP2/gRPC
      HTTP = 1;
      // Any non-HTTP listener
      TCP = 2;
    };

    // Selects a class of listeners for the same protocol. Use the protocol
    // selection to select all HTTP listeners (includes HTTP2/gRPC/HTTPS
    // where Envoy terminates TLS) or all TCP listeners (includes HTTPS
    // passthrough using SNI). When adding a HTTP filter, the listenerProtocol
    // should be set to HTTP.
    ListenerProtocol listener_protocol = 4;

    // One or more IP addresses to which the listener is bound. If
    // specified, should match at least one address in the list.
    repeated string address = 5;
  };

  // Indicates the relative index in the filter chain where the filter should be inserted.
  message InsertPosition {

    // Index/position in the filter chain.
    enum Index {
      // Insert first
      FIRST = 0;

      // Insert last
      LAST = 1;

      // Insert before the named filter.
      BEFORE = 2;
      // Insert after the named filter.
      AFTER = 3;
    };

    // Position of this filter in the filter chain.
    Index index = 1;

    // If BEFORE or AFTER position is specified, specify the name of
    // the filter relative to which this filter should be inserted.
    string relative_to = 2;
  };

  // Envoy filters to be added to a network or http filter chain.
  message Filter {
    // Filter will be added to the listener only if the match
    // conditions are true. If not specified, the filters will be
    // applied to all listeners where possible, potentially resulting
    // in invalid configurations. It is recommended to specify the
    // listener match criteria for all filter insertions.
    ListenerMatch listener_match = 1;

    // Insert position in the filter chain. Defaults to FIRST.
    InsertPosition insert_position = 2;

    enum FilterType {
      // placeholder
      INVALID = 0;

      // Http filter
      HTTP = 1;

      // Network filter
      NETWORK = 2;
    };

    // REQUIRED: The type of filter to instantiate.
    FilterType filter_type = 3;

    // REQUIRED: The name of the filter to instantiate or replace. The
    // name must match a supported filter _compiled into_ Envoy.
    // Refer to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/network/well_known_names.h
    // for a list of network filters, and to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/http/well_known_names.h
    // for a list of HTTP filters.
    string filter_name = 4;

    // REQUIRED: Filter specific configuration which depends on the filter being
    // instantiated.
    google.protobuf.Struct filter_config = 5;
  };

  // Conditions specified in ClusterMatch must be met for the patch
  // to be applied to a cluster.
  message ClusterMatch {
    // The service port for which this cluster was generated.  If
    // omitted, applies to clusters for any port.
    uint32 port_number = 1;

    // The FQDN of the service name for this cluster. If omitted,
    // applies to clusters for any service.
    string hostname = 2;

    // The subset associated with the service. If omitted, applies to
    // clusters for any subset of a service.
    string subset = 3;

    // Inbound vs outbound sidecar cluster or gateway outbound
    // cluster. If omitted, applies to all clusters.
    Context context = 4;

    // The exact name of the cluster to match. To match a specific
    // cluster by name, such as the internally generated "Passthrough"
    // cluster, leave all fields in clusterMatch empty, except the
    // name.
    string name = 5;
  };

  // Conditions specified in RouteMatch must be met for the patch
  // to be applied to a route.
  message RouteMatch {
    // The service port number or gateway server port number for which
    // this route was generated.  If omitted, applies to routes for
    // all ports.
    uint32 port_number = 1;

    // The service port name or gateway server port name for which
    // this route was generated.  If omitted, applies to routes for
    // all ports.
    uint32 port_name = 2;

    // Selects either inbound routes, outbound routes in sidecars, or
    // routes on a gateway.
    Context context = 3;

    // The Istio gateway config's namespace/name for which this route
    // was generated. Applies only if the conntext is GATEWAY. Should
    // be in the namespace/name format. Use this field in conjunction
    // with the portNumber and portName to accurately select the RDS
    // generated route for a specific HTTPS server within a gateway
    // config object.
    string gateway = 4;

    // Route name to match on. Can be used to match a specific route
    // by name, such as the internally generated "http_proxy" route
    // for all sidecars.
    string name = 5;
  };

  // Patch specifies the JSON path in the generated proto and the
  // content to merge/remove on the specific path.
  message Patch {
    // A valid JSON Path expression specifying the point in the object
    // graph where the mutation operation should occur. The patch is
    // ignored if there is no object on the specified path. If the
    // path is omitted and the ADD operation is used, the JSON value
    // specified will be added to the object graph.
    string path = 1;

    enum Operation {

      // Overlay the value onto the element selected by the path using
      // json merge semantics. For primitive fields this is equivalent
      // to ADD.
      MERGE = 0;

      // Overlay the value onto the element selected by the path using
      // json merge semantics but only for fields that are set to
      // their default values, or fields that are unset.
      MERGE_UNSET = 1;

      // For arrays this will insert the value before the selected
      // element. It is permitted for the inserted value to also be an
      // array in this case. Appending to an array is indicated using
      // the syntax somearray[-]. For maps this will either add to the
      // map or replace the value for the key.  For fields this will
      // replace the value.
      ADD = 2;

      // Remove the selected elements from their parent. Does not
      // require a value to be specified. When removing fields their
      // values are reset to their intrinsic default.
      REMOVE = 3;
    }

    // Default behavior is MERGE.
    Operation operation = 2;

    // The proto equivalent of JSON Value. This will be merged using
    // json merge semantics with the existing proto in the path.
    google.protobuf.Value value = 3; 
  };

  // Changes to be made to Envoy listeners generated by Pilot.
  message ListenerPatch {
    // Criteria to select a specific listener. If omitted, the patch
    // will be applied to all listeners.
    ListenerMatch match = 1;
    // Patches to apply on the matched listener.
    repeated Patch patches = 2;
  }

  // Changes to be made to Envoy clusters generated by Pilot.
  message ClusterPatch {
    // Criteria to match a specific cluster.
    ClusterMatch match = 1;
    // Patches to apply on the matched cluster.
    repeated Patch patches = 2;
  }

  // Changes to be made to Envoy RDS routes generated by Pilot.
  message RoutePatch {
    // Criteria to match a specific route.
    RouteMatch match = 1;
    // Patches to apply on the matched route.
    repeated Patch patches = 2;
  }

  // REQUIRED: Atleast one of filters, listeners, clusters, or routes
  // should be specified. Envoy network filters/http filters to be
  // added to matching listeners.  When adding network filters to http
  // connections, care should be taken to ensure that the filter is
  // added before envoy.http_connection_manager.
  repeated Filter filters = 2;

  // REQUIRED: Atleast one of filters, listeners, clusters, or routes
  // should be specified. Changes to be applied to one or more Envoy
  // listeners. To add a new listener, use the ADD operation with no
  // match condition, empty path field, and a valid listener as the
  // value in a patch.
  repeated ListenerPatch listener_patches = 3;

  // REQUIRED: Atleast one of filters, listeners, clusters, or routes
  // should be specified. Changes to be applied to one or more Envoy
  // clusters. To add a new listener, use the ADD operation with no
  // match condition, empty path field, and a valid cluster as the
  // value in a patch.
  repeated ClusterPatch cluster_patches = 4;

  // REQUIRED: Atleast one of filters, listeners, clusters, or routes
  // should be specified. Changes to be applied to one or more Envoy
  // routes.
  repeated RoutePatch route_patches = 5;
}
