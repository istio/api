// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/struct.proto";

// $title: Envoy Filter
// $description: Customizing Envoy configuration generated by Istio.
// $location: https://istio.io/docs/reference/config/networking/v1alpha3/envoy-filter.html

// `EnvoyFilter` provides a mechanism to customize the Envoy
// configuration generated by Istio Pilot. Use EnvoyFilter to modify
// values for certain fields, add specific filters, or even add
// entirely new listeners, clusters, etc. This feature must be used
// with care, as incorrect configurations could potentially
// destabilize the entire mesh.
//
// **NOTE 1**: Since this is break glass configuration, there will not be any
// backward compatibility across different Istio releases. In other words,
// this configuration is subject to change based on internal implementation
// of Istio networking subsystem.
//
// **NOTE 2**: The envoy configuration provided through this mechanism
// should be carefully monitored across Istio proxy version upgrades,
// to ensure that deprecated fields are removed and replaced
// appropriately.
//
// **NOTE 3**: When multiple EnvoyFilters are bound to the same
// workload, all filter configurations will be processed sequentially
// in order of creation time.  The behavior is undefined if multiple
// EnvoyFilter configurations conflict with each other.
//
// The following example for Kubernetes enables Envoy's Lua filter for
// all inbound HTTP calls arriving at service port 8080 of the reviews
// service pod with labels "app: reviews". The lua filter calls out to
// an external service internal.org.net:8888 that requires a special
// cluster definition in envoy. The cluster is also added to the
// sidecar as part of this configuration.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
// spec:
//   workloadLabels:
//     app: reviews
//   configPatches:
//     # The first patch adds the lua filter to the listener/http connection manager
//   - match:
//       listener:
//         context: SIDECAR_INBOUND # will match with the inbound listener for reviews:8080
//         portNumber: 8080
//         filterChain:
//           filterName: "envoy.http_connection_manager"
//     patches:
//     - path: '{.http_filters}' # relative to http connection manager
//       operation: ARRAY_INSERT
//       insertPosition:
//         index: BEFORE
//         relativeTo: "envoy.router"
//       value: # lua filter specification
//        name: envoy.lua
//        config:
//          inlineCode: |
//            function envoy_on_request(request_handle)
//              -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
//              local headers, body = request_handle:httpCall(
//               "lua_cluster",
//               {
//                [":method"] = "POST",
//                [":path"] = "/acl",
//                [":authority"] = "internal.org.net"
//               },
//              "authorize call",
//              5000)
//            end
//   # The second patch adds the cluster that is referenced by the lua code
//   - match:
//       cluster:
//         context: SIDECAR_OUTBOUND
//     patches:
//       # omit the path as its not needed to add a cluster
//     - operation: ADD
//       value: # cluster specification
//         name: "lua_cluster"
//         type: STRICT_DNS
//         connect_timeout: 0.5s
//         lb_policy: ROUND_ROBIN
//         hosts:
//         - socket_address:
//             protocol: TCP
//             address: "internal.org.net"
//             port_value: 8888
//
// ```
//
// The following example overwrites certain fields (HTTP idle timeout
// and X-Forward-For trusted hops) in the HTTP connection manager in a
// listener on the ingress gateway for the SNI host app.example.com:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: hcm-tweaks
//   namespace: istio-system
// spec:
//   workloadLabels:
//     istio: ingress-gateway
//   configPatches:
//   - match:
//       listener:
//         context: GATEWAY # will match all gateway listeners
//         filterChain:
//           sni: app.example.com
//           filterName: "envoy.http_connection_manager"
//     patches:
//     - path: '.'
//       operation: MERGE
//       value: |
//         idle_timeout: 30s
//         xff_num_trusted_hops: 5
//```
//
// The following example adds a custom protocol filter on all sidecars
// in the system, for outbound port 9307. The filter should be added
// before the terminating tcp_proxy filter to take effect.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: custom-protocol
// spec:
//   configPatches:
//   - match:
//       listener:
//         context: SIDECAR_OUTBOUND # will match outbound listeners in all sidecars
//         portNumber: 9307
//     patches:
//     - path: '{.filter_chains[*].filters}'
//       operation: ARRAY_INSERT
//       insertPosition:
//         index: BEFORE
//         relativeTo: "envoy.tcp_proxy"
//       value: |
//         name: "envoy.config.filter.network.custom_protocol"
//         config:
//          ...
//```
//
package istio.networking.v1alpha3;

option go_package = "istio.io/api/networking/v1alpha3";

message EnvoyFilter {
  // Zero or more labels that indicate a specific set of pods/VMs whose
  // proxies should be configured to use these additional filters.  The
  // scope of label search is platform dependent. On Kubernetes, for
  // example, the scope includes pods running in all reachable
  // namespaces. Omitting the selector applies the filter to all proxies in
  // the mesh.
  map<string, string> workload_labels = 1;

  enum PatchContext {
    // All listeners/routes/clusters in both sidecars and gateways.
    ANY = 0;

    // Inbound listener/route/cluster in sidecar.
    SIDECAR_INBOUND = 1;

    // Outbound listener/route/cluster in sidecar.
    SIDECAR_OUTBOUND = 2;

    // Gateway listener/route/cluster.
    GATEWAY = 3;
  };

  // Select a listener to add the filter to based on the match conditions.
  // All conditions specified in the ListenerMatch must be met for the filter
  // to be applied to a listener.
  message DeprecatedListenerMatch {
    // The service port/gateway port to which traffic is being
    // sent/received. If not specified, matches all listeners. Even though
    // inbound listeners are generated for the instance/pod ports, only
    // service ports should be used to match listeners.
    uint32 port_number = 1;

    // Instead of using specific port numbers, a set of ports matching a
    // given port name prefix can be selected. E.g., "mongo" selects ports
    // named mongo-port, mongo, mongoDB, MONGO, etc. Matching is case
    // insensitive.
    string port_name_prefix = 2;

    // Deprecated. Use the `context` field instead.
    // $hide_from_docs
    PatchContext listener_type = 3 [deprecated=true];

    // Inbound vs outbound sidecar listener or gateway listener. If
    // not specified, matches all listeners.
    PatchContext context = 6;

    enum ListenerProtocol {
      // All protocols
      ALL = 0;
      // HTTP or HTTPS (with termination) / HTTP2/gRPC
      HTTP = 1;
      // Any non-HTTP listener
      TCP = 2;
    };

    // Selects a class of listeners for the same protocol. Use the protocol
    // selection to select all HTTP listeners (includes HTTP2/gRPC/HTTPS
    // where Envoy terminates TLS) or all TCP listeners (includes HTTPS
    // passthrough using SNI). When adding a HTTP filter, the listenerProtocol
    // should be set to HTTP.
    ListenerProtocol listener_protocol = 4;

    // One or more IP addresses to which the listener is bound. If
    // specified, should match at least one address in the list.
    repeated string address = 5;
  };

  // Indicates the relative index in the filter chain where the filter
  // should be inserted.
  message InsertPosition {

    // Index/position in the filter chain.
    enum Index {
      // Insert first
      FIRST = 0;

      // Insert last
      LAST = 1;

      // Insert before the named filter.
      BEFORE = 2;
      // Insert after the named filter.
      AFTER = 3;
    };

    // Position of this filter in the filter chain.
    Index index = 1;

    // If BEFORE or AFTER position is specified, specify the name of
    // the filter relative to which this filter should be inserted.
    string relative_to = 2;
  };

  // Envoy filters to be added to a network or http filter chain.
  message Filter {
    // Filter will be added to the listener only if the match
    // conditions are true. If not specified, the filters will be
    // applied to all listeners where possible, potentially resulting
    // in invalid configurations. It is recommended to specify the
    // listener match criteria for all filter insertions.
    DeprecatedListenerMatch listener_match = 1;

    // Insert position in the filter chain. Defaults to FIRST.
    InsertPosition insert_position = 2;

    enum FilterType {
      // placeholder
      INVALID = 0;

      // Http filter
      HTTP = 1;

      // Network filter
      NETWORK = 2;
    };

    // REQUIRED: The type of filter to instantiate.
    FilterType filter_type = 3;

    // REQUIRED: The name of the filter to instantiate or replace. The
    // name must match a supported filter _compiled into_ Envoy.
    // Refer to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/network/well_known_names.h
    // for a list of network filters, and to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/http/well_known_names.h
    // for a list of HTTP filters.
    string filter_name = 4;

    // REQUIRED: Filter specific configuration which depends on the filter being
    // instantiated.
    google.protobuf.Struct filter_config = 5;
  };

  // Conditions specified in ClusterMatch must be met for the patch
  // to be applied to a cluster.
  message ClusterMatch {
    // Inbound vs outbound sidecar cluster or gateway outbound
    // cluster. If omitted, applies to all clusters.
    PatchContext context = 1;

    // The service port for which this cluster was generated.  If
    // omitted, applies to clusters for any port.
    uint32 port_number = 2;

    // The FQDN of the service name for this cluster. If omitted,
    // applies to clusters for any service.
    string hostname = 3;

    // The subset associated with the service. If omitted, applies to
    // clusters for any subset of a service.
    string subset = 4;

    // The exact name of the cluster to match. To match a specific
    // cluster by name, such as the internally generated "Passthrough"
    // cluster, leave all fields in clusterMatch empty, except the
    // name.
    string name = 5;
  };

  // Conditions specified in RouteConfigurationMatch must be met for
  // the patch to be applied to a route configuration object or a
  // specific virtual host within the route configuration.
  message RouteConfigurationMatch {
    // Match a specific virtual host inside a route configuration.
    message VirtualHostMatch {
      // The VirtualHosts objects generated by Istio are named as
      // host:port, where the host typically corresponds to the
      // VirtualService's host field or the hostname of a service in the
      // registry. If specified, the patch will be applied to to the
      // virtual host matched and not to the route configuration.
      string host = 1;
    }

    // Selects either inbound route configurations, outbound route
    // configurations in sidecars, or route configurations on a
    // gateway.
    PatchContext context = 1;

    // The service port number or gateway server port number for which
    // this route configuration was generated. If omitted, applies to
    // route configurations for all ports.
    uint32 port_number = 2;

    // The gateway server port name for which this route configuration
    // was generated. Port name is not applicable for sidecar contexts.
    uint32 port_name = 3;

    // The Istio gateway config's namespace/name for which this route
    // configuration was generated. Applies only if the context is
    // GATEWAY. Should be in the namespace/name format. Use this field
    // in conjunction with the portNumber and portName to accurately
    // select the Envoy route configuration for a specific HTTPS
    // server within a gateway config object.
    string gateway = 4;

    // Match a specific virtual host in a route configuration and
    // apply the patch to the virtual host.
    VirtualHostMatch vhost = 5;

    // Route configuration name to match on. Can be used to match a
    // specific route configuration by name, such as the internally
    // generated "http_proxy" route configuration for all sidecars.
    string name = 6;
  };

  // Conditions specified in a listener match must be met for the
  // patch to be applied to a specific listener across all filter
  // chains, or a specific filter chain inside the listener.
  message ListenerMatch {
    // For listeners with multiple filter chains (e.g., inbound
    // listeners on sidecars with permissive mTLS, gateway listeners
    // with multiple SNI matches), the filter chain match can be used to
    // select a specific filter chain to patch.
    message FilterChainMatch {
      // The SNI value used by a filter chain's match condition.  This
      // condition will evaluate to false if the filter chain has no sni
      // match.
      string sni = 1;

      // Applies only to SIDECAR_INBOUND context. If non-empty, a
      // transport protocol to consider when determining a filter
      // chain match.  This value will be compared against the
      // transport protocol of a new connection, when it's detected by
      // one of the listener filters.
      //
      // Accepted values include:
      //
      // * `raw_buffer` - default, used when no transport protocol is detected.
      // * `tls` - set when TLS protocol is detected by the TLS inspector.
      string transport_protocol = 2;

      // The name of a specific filter to apply the patch to. Set this
      // to envoy.http_connection_manager to add a filter or apply a
      // patch to the HTTP connection manager.
      string filter_name = 3;
    };

    // Inbound vs outbound sidecar listener or gateway listener. If
    // not specified, matches all listeners.
    PatchContext context = 1;

    // The service port/gateway port to which traffic is being
    // sent/received. If not specified, matches all listeners. Even though
    // inbound listeners are generated for the instance/pod ports, only
    // service ports should be used to match listeners.
    uint32 port_number = 2;

    // Instead of using specific port numbers, a set of ports matching
    // a given port name can be selected. Matching is case
    // insensitive.
    string port_name = 3;

    // Match a specific filter chain in a listener. If specified, the
    // patch will be applied to the filter chain (and a specific
    // filter if specified) and not to other filter chains in the
    // listener.
    FilterChainMatch filter_chain = 4;

    // Match a specific listener by its name. The listeners generated
    // by Pilot are typically named as IP:Port.
    string name = 5;
  };

  // Patch specifies the JSON path in the generated proto and the
  // content to merge/remove on the specific path.
  message Patch {
    // A valid JSON Path expression relative to the matched section of
    // the config, specifying the point in the object graph where the
    // mutation operation should occur. The patch is ignored if there
    // is no object on the specified path. If the path is omitted and
    // the ADD operation is used, the JSON value specified will be
    // added to the object graph.
    string path = 1;

    enum Operation {

      // Overlay the value onto the element selected by the path using
      // json merge semantics. For primitive fields this is equivalent
      // to ADD.
      MERGE = 0;

      // Overlay the value onto the element selected by the path using
      // json merge semantics but only for fields that are set to
      // their default values, or fields that are unset.
      MERGE_UNSET = 1;

      // For maps this will either add to the map or replace the value
      // for the key.  For fields this will replace the value.
      ADD = 2;

      // Insert operation on an array of named objects. This operation
      // is typically useful only in the context of filters, where the
      // order of filters matter. For clusters and virtual hosts,
      // order of the element in the array does not matter. Use the
      // InsertPosition to specify the location where the element
      // should be inserted.
      ARRAY_INSERT = 4;

      // Remove the selected elements from their parent. Does not
      // require a value to be specified. When removing fields their
      // values are reset to their intrinsic default.
      REMOVE = 4;
    }

    // Default behavior is MERGE.
    Operation operation = 2;

    // REQUIRED if operation is ARRAY_INSERT. The absolute or relative
    // position in the array where the object should be inserted.
    InsertPosition insert_position = 3;

    // The proto equivalent of JSON Value. This will be merged using
    // json merge semantics with the existing proto in the path.
    google.protobuf.Value value = 4;
  };

  message EnvoyConfigObjectMatch {
    oneof object_types {
      ListenerMatch listener = 1;
      RouteConfigurationMatch route_configuration = 3;
      ClusterMatch cluster = 5;
    }
  };

  // Changes to be made to various envoy config objects.
  message EnvoyConfigObjectPatch {
    // Match on listener/route configuration/cluster.  The patch
    // object will be evaluated based on the match type. For example,
    // while generating listeners, patch objects with a listener match
    // condition will be evaluated and applied to patch the generated
    // listeners, while patch objects with other match conditions will
    // be ignored.
    EnvoyConfigObjectMatch match = 1;
    repeated Patch patches = 2;
  }

  // REQUIRED. One or more patches with match conditions.
  repeated EnvoyConfigObjectPatch config_patches = 3;

  // $hide_from_docs
  repeated Filter filters = 2 [deprecated = true];
}
