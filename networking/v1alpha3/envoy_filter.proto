// Copyright 2018 Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

syntax = "proto3";

import "google/protobuf/struct.proto";

// $title: Envoy Filter
// $description: Configuration affecting insertion of custom Envoy filters.
// $location: https://istio.io/docs/reference/config/networking/v1alpha3/envoy-filter.html

// `EnvoyFilter` describes Envoy proxy-specific filters that can be used to
// customize the Envoy proxy configuration generated by Istio networking
// subsystem (Pilot). This feature must be used with care, as incorrect
// configurations could potentially destabilize the entire mesh.
//
// NOTE 1: Since this is break glass configuration, there will not be any
// backward compatibility across different Istio releases. In other words,
// this configuration is subject to change based on internal implementation
// of Istio networking subsystem.
//
// NOTE 2: When multiple EnvoyFilters are bound to the same workload, all filter
// configurations will be processed sequentially in order of creation time.
// The behavior is undefined if multiple EnvoyFilter configurations conflict
// with each other.
//
// NOTE 3: For filters of `filterType: HTTP` you must include a `listenerMatch` section
// with a `listenerProtocol: HTTP` or the filter have no effect.
//
// The following example for Kubernetes enables Envoy's Lua filter for all
// inbound HTTP calls arriving at service port 8080 of the reviews service pod with
// labels "app: reviews".
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
// spec:
//   workloadLabels:
//     app: reviews
//   filters:
//   - listenerMatch:
//       portNumber: 8080
//       context: SIDECAR_INBOUND # will match with the inbound listener for reviews:8080
//       listenerProtocol: HTTP
//     filterName: envoy.lua
//     filterType: HTTP
//     filterConfig:
//       inlineCode: |
//         ... lua code ...
// ```
//
// For a more flexible approach, use Listener/Cluster to specify a
// JSON Path based expression to match in the generated Envoy config
// and a replacement value for the matched section. It can be used to
// arbitrarily modify the generated Envoy config for a sidecar or
// gateway. No guarantee is made with respect to the applicability of
// the generated Envoy config. The following example overwrites
// certain fields (HTTP idle timeout and X-Forward-For trusted hops)
// in the HTTP connection manager in a listener on the ingress gateway
// while leaving the rest as is.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: hcm-tweaks
//   namespace: istio-system
// spec:
//   workloadLabels:
//     istio: ingress-gateway
//   listeners:
//   - match:
//       context: GATEWAY # will match all gateway listeners
//     patches:
//     - path: '{.filter_chains[*].filters[?(@.name=="envoy.http_connection_manager")]}'
//       operation: ADD
//       value: |
//         idle_timeout: 30s
//         xff_num_trusted_hops: 5
//```
//
package istio.networking.v1alpha3;

option go_package = "istio.io/api/networking/v1alpha3";

message EnvoyFilter {
  // Zero or more labels that indicate a specific set of pods/VMs whose
  // proxies should be configured to use these additional filters.  The
  // scope of label search is platform dependent. On Kubernetes, for
  // example, the scope includes pods running in all reachable
  // namespaces. Omitting the selector applies the filter to all proxies in
  // the mesh.
  map<string, string> workload_labels = 1;

  enum PatchContext {
    // All listeners/routes/clusters in both sidecars and gateways.
    ANY = 0;

    // Inbound listener/route/cluster in sidecar.
    SIDECAR_INBOUND = 1;

    // Outbound listener/route/cluster in sidecar.
    SIDECAR_OUTBOUND = 2;

    // Gateway listener/route/cluster.
    GATEWAY = 3;
  };

  // Select a listener to add the filter to based on the match conditions.
  // All conditions specified in the ListenerMatch must be met for the filter
  // to be applied to a listener.
  message ListenerMatch {
    // The service port/gateway port to which traffic is being
    // sent/received. If not specified, matches all listeners. Even though
    // inbound listeners are generated for the instance/pod ports, only
    // service ports should be used to match listeners.
    uint32 port_number = 1;

    // Instead of using specific port numbers, a set of ports matching a
    // given port name prefix can be selected. E.g., "mongo" selects ports
    // named mongo-port, mongo, mongoDB, MONGO, etc. Matching is case
    // insensitive.
    string port_name_prefix = 2;

    // Deprecated. Use the `context` field instead.
    // $hide_from_docs
    PatchContext listener_type = 3 [deprecated=true];

    // Inbound vs outbound sidecar listener or gateway listener. If
    // not specified, matches all listeners.
    PatchContext context = 6;

    enum ListenerProtocol {
      // All protocols
      ALL = 0;
      // HTTP or HTTPS (with termination) / HTTP2/gRPC
      HTTP = 1;
      // Any non-HTTP listener
      TCP = 2;
    };

    // Selects a class of listeners for the same protocol. Use the protocol
    // selection to select all HTTP listeners (includes HTTP2/gRPC/HTTPS
    // where Envoy terminates TLS) or all TCP listeners (includes HTTPS
    // passthrough using SNI). When adding a HTTP filter, the listenerProtocol
    // should be set to HTTP.
    ListenerProtocol listener_protocol = 4;

    // One or more IP addresses to which the listener is bound. If
    // specified, should match at least one address in the list.
    repeated string address = 5;
  };

  // Indicates the relative index in the filter chain where the filter should be inserted.
  message InsertPosition {

    // Index/position in the filter chain.
    enum Index {
      // Insert first
      FIRST = 0;

      // Insert last
      LAST = 1;

      // Insert before the named filter.
      BEFORE = 2;
      // Insert after the named filter.
      AFTER = 3;
    };

    // Position of this filter in the filter chain.
    Index index = 1;

    // If BEFORE or AFTER position is specified, specify the name of
    // the filter relative to which this filter should be inserted.
    string relative_to = 2;
  };

  // Envoy filters to be added to a network or http filter chain.
  message Filter {
    // Filter will be added to the listener only if the match
    // conditions are true. If not specified, the filters will be
    // applied to all listeners where possible, potentially resulting
    // in invalid configurations. It is recommended to specify the
    // listener match criteria for all filter insertions.
    ListenerMatch listener_match = 1;

    // Insert position in the filter chain. Defaults to FIRST.
    InsertPosition insert_position = 2;

    enum FilterType {
      // placeholder
      INVALID = 0;

      // Http filter
      HTTP = 1;

      // Network filter
      NETWORK = 2;
    };

    // REQUIRED: The type of filter to instantiate.
    FilterType filter_type = 3;

    // REQUIRED: The name of the filter to instantiate or replace. The
    // name must match a supported filter _compiled into_ Envoy.
    // Refer to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/network/well_known_names.h
    // for a list of network filters, and to
    // https://github.com/envoyproxy/envoy/blob/master/source/extensions/filters/http/well_known_names.h
    // for a list of HTTP filters.
    string filter_name = 4;

    // REQUIRED: Filter specific configuration which depends on the filter being
    // instantiated.
    google.protobuf.Struct filter_config = 5;
  };

  // Conditions specified in ClusterMatch must be met for the patch
  // to be applied to a cluster.
  message ClusterMatch {
    // The service port for which this cluster was generated.  If
    // omitted, applies to clusters for any port.
    uint32 port_number = 1;

    // The FQDN of the service name for this cluster. If omitted,
    // applies to clusters for any service.
    string hostname = 2;

    // The subset associated with the service. If omitted, applies to
    // clusters for any subset of a service.
    string subset = 3;

    // Inbound vs outbound sidecar cluster or gateway outbound
    // cluster. If omitted, applies to all clusters.
    PatchContext context = 4;

    // The exact name of the cluster to match. To match a specific
    // cluster by name, such as the internally generated "Passthrough"
    // cluster, leave all fields in clusterMatch empty, except the
    // name.
    string name = 5;
  };

  // Conditions specified in RouteConfigurationMatch must be met for
  // the patch to be applied to a route.
  message RouteConfigurationMatch {
    // The service port number or gateway server port number for which
    // this route configuration was generated. If omitted, applies to
    // route configurations for all ports.
    uint32 port_number = 1;

    // The gateway server port name for which this route configuration
    // was generated. Port name is not applicable for sidecar contexts.
    uint32 port_name = 2;

    // Selects either inbound route configurations, outbound route
    // configurations in sidecars, or route configurations on a
    // gateway.
    PatchContext context = 3;

    // The Istio gateway config's namespace/name for which this route
    // configuration was generated. Applies only if the context is
    // GATEWAY. Should be in the namespace/name format. Use this field
    // in conjunction with the portNumber and portName to accurately
    // select the Envoy route configuration for a specific HTTPS
    // server within a gateway config object.
    string gateway = 4;

    // Route configuration name to match on. Can be used to match a
    // specific route configuration by name, such as the internally
    // generated "http_proxy" route configuration for all sidecars.
    string name = 5;
  };

  // Conditions specified in VirtualHostMatch must be met for
  // the patch to be applied to a virtual host object.
  message VirtualHostMatch {
    // Selects either inbound virtual host configurations, outbound
    // virtual host configurations in sidecars, or virtual host
    // configurations on a gateway.
    PatchContext context = 1;

    // Route configuration (RDS) name to match on. Can be used to
    // match a specific route configuration by name, such as the
    // internally generated "http_proxy" route configuration for all
    // sidecars.  If not specified, applies to virtual hosts in any
    // route config object.
    string route_configuration = 2;

    // The VirtualHosts objects generated by Istio are named as
    // host:port, where the host typically corresponds to the
    // VirtualService's host field or the hostname of a service in the
    // registry. Use the host field to match on all VirtualHost objects
    // generated for a specific host.
    string host = 3;

    // The VirtualHosts objects generated by Istio are named as
    // host:port, where the port corresponds to the service's port or
    // the port on which a gateway's Server is listening. If omitted,
    // matches on all ports.
    uint32 port_number = 4;

    // VirtualHost object name to match on. Can be used to match a
    // specific virtual host configuration by name, such as the
    // internally generated "allow_any" or "block_all" virtual host
    // configurations for all sidecars.
    string name = 5;
  }

  // For listeners with multiple filter chains (e.g., inbound
  // listeners on sidecars with permissive mTLS, gateway listeners
  // with multiple SNI matches), the filter chain match can be used to
  // select a specific filter chain to patch.
  message FilterChainMatch {
    // Inbound vs outbound sidecar listener or gateway listener. If
    // not specified, matches all listeners.
    PatchContext context = 1;

    // The SNI value used by a filter chain's match condition.  This
    // condition will evaluate to false if the filter chain has no sni
    // match.
    string sni = 2;

    // The ALPN protocol used by a filter chain's match
    // condition. This condition will evaluate to false if the filter
    // chain has no ApplicationProtocols setting.
    string alpn = 3;
    
    // The specific listener to which this filter chain belongs to.
    string listener_name = 4;
  };

  // Patch specifies the JSON path in the generated proto and the
  // content to merge/remove on the specific path.
  message Patch {
    // A valid JSON Path expression specifying the point in the object
    // graph where the mutation operation should occur. The patch is
    // ignored if there is no object on the specified path. If the
    // path is omitted and the ADD operation is used, the JSON value
    // specified will be added to the object graph.
    string path = 1;

    enum Operation {

      // Overlay the value onto the element selected by the path using
      // json merge semantics. For primitive fields this is equivalent
      // to ADD.
      MERGE = 0;

      // Overlay the value onto the element selected by the path using
      // json merge semantics but only for fields that are set to
      // their default values, or fields that are unset.
      MERGE_UNSET = 1;

      // For arrays this will insert the value before the selected
      // element. It is permitted for the inserted value to also be an
      // array in this case. Appending to an array is indicated using
      // the syntax somearray[-]. For maps this will either add to the
      // map or replace the value for the key.  For fields this will
      // replace the value.
      ADD = 2;

      // Remove the selected elements from their parent. Does not
      // require a value to be specified. When removing fields their
      // values are reset to their intrinsic default.
      REMOVE = 3;
    }

    // Default behavior is MERGE.
    Operation operation = 2;

    // The proto equivalent of JSON Value. This will be merged using
    // json merge semantics with the existing proto in the path.
    google.protobuf.Value value = 3; 
  };

  message EnvoyConfigObjectMatch {
    oneof object_types {
      ListenerMatch listener = 1;
      FilterChainMatch filter_chain = 2;
      RouteConfigurationMatch route_configuration = 3;
      VirtualHostMatch virtual_host = 4;
      ClusterMatch cluster = 5;
    }
  };

  // Changes to be made to various envoy config objects.
  message EnvoyConfigObjectPatch {
    // Match on listener/filter chain/route
    // configuration/vhost/cluster.  The patch object will be
    // evaluated based on the match type. For example, while
    // generating listeners, patch objects with a listener match
    // condition will be evaluated and applied to patch the generated
    // listeners, while patch objects with other match conditions will
    // be ignored.
    EnvoyConfigObjectMatch match = 1;
    repeated Patch patches = 2;
  }

  // REQUIRED. One or more patches with match conditions.
  repeated EnvoyConfigObjectPatch config_patches = 3;

  // // Changes to be made to Envoy listeners generated by Pilot.
  // message ListenerPatch {
  //   // Criteria to select a specific listener. If omitted, the patch
  //   // will be applied to all listeners.
  //   ListenerMatch match = 1;
  //   // Patches to apply on the matched listener.
  //   repeated Patch patches = 2;
  // }

  // // Changes to be made to Envoy clusters generated by Pilot.
  // message ClusterPatch {
  //   // Criteria to match a specific cluster.
  //   ClusterMatch match = 1;
  //   // Patches to apply on the matched cluster.
  //   repeated Patch patches = 2;
  // }

  // // Changes to be made to Envoy RDS routes generated by Pilot.
  // message RouteConfigurationPatch {
  //   // Criteria to match a specific route.
  //   RouteConfigurationMatch match = 1;
  //   // Patches to apply on the matched route.
  //   repeated Patch patches = 2;
  // }

  // REQUIRED: Atleast one of filters, listeners, clusters, or routes
  // should be specified. This field is deprecated. Use the listener
  // patch to add filters to specific listeners.
  // $hide_from_docs
  repeated Filter filters = 2 [deprecated = true];

  // // REQUIRED: Atleast one of listeners, clusters, or routes should be
  // // specified. Changes to be applied to one or more Envoy
  // // listeners. To add a new listener, use the ADD operation with no
  // // match condition, empty path field, and a valid listener as the
  // // value in a patch.
  // repeated ListenerPatch listener_patches = 3;

  // // REQUIRED: Atleast one of listeners, clusters, or routes should be
  // // specified. Changes to be applied to one or more Envoy
  // // clusters. To add a new listener, use the ADD operation with no
  // // match condition, empty path field, and a valid cluster as the
  // // value in a patch.
  // repeated ClusterPatch cluster_patches = 4;

  // // REQUIRED: Atleast one of listeners, clusters, or routes should be
  // // specified. Changes to be applied to one or more Envoy routes.
  // repeated RoutePatch route_patches = 5;
}
