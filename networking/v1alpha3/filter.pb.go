// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/filter.proto

package v1alpha3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ListenerType describes the type of listener to insert the filter
// into.
type SidecarFilterBinding_Match_ListenerType int32

const (
	// The listener is an HTTP listener.  Note that HTTP filters can
	// only be inserted into HTTP listeners. Network filters may also be
	// inserted into HTTP listeners.
	SidecarFilterBinding_Match_HTTP SidecarFilterBinding_Match_ListenerType = 0
	// The listener is a TCP listener. Network filters can be inserted
	// into TCP listeners. HTTP filters may not be inserted into TCP
	// listeners.
	SidecarFilterBinding_Match_TCP SidecarFilterBinding_Match_ListenerType = 1
)

var SidecarFilterBinding_Match_ListenerType_name = map[int32]string{
	0: "HTTP",
	1: "TCP",
}
var SidecarFilterBinding_Match_ListenerType_value = map[string]int32{
	"HTTP": 0,
	"TCP":  1,
}

func (x SidecarFilterBinding_Match_ListenerType) String() string {
	return proto.EnumName(SidecarFilterBinding_Match_ListenerType_name, int32(x))
}
func (SidecarFilterBinding_Match_ListenerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFilter, []int{0, 0, 0}
}

// The position of the filter relative to another or the entire chain.
type FilterOrder_Position int32

const (
	// The filter should be first in the resulting chain.
	FilterOrder_FIRST FilterOrder_Position = 0
	// The filter should be last in the resulting chain.
	FilterOrder_LAST FilterOrder_Position = 1
	// The filter should be immediately before the filter named in the
	// `relative_to` field. If the relative filter is not present, the
	// inserted filter will be last.
	FilterOrder_BEFORE FilterOrder_Position = 2
	// The filter should be immediately after the filter named in the
	// `relative_to` field. If the relative filter is not present, the
	// inserted filter will be last.
	FilterOrder_AFTER FilterOrder_Position = 3
)

var FilterOrder_Position_name = map[int32]string{
	0: "FIRST",
	1: "LAST",
	2: "BEFORE",
	3: "AFTER",
}
var FilterOrder_Position_value = map[string]int32{
	"FIRST":  0,
	"LAST":   1,
	"BEFORE": 2,
	"AFTER":  3,
}

func (x FilterOrder_Position) String() string {
	return proto.EnumName(FilterOrder_Position_name, int32(x))
}
func (FilterOrder_Position) EnumDescriptor() ([]byte, []int) { return fileDescriptorFilter, []int{1, 0} }

//
// # Overview
//
// A `HTTPFilterConfig` and `NetworkFilterConfig` describe filters to insert
// into the processing chain for mesh traffic.  Each consists of the filter's
// name (in Envoy) and the configuration blob.
//
// Pilot creates listeners with different identifiers depending on whether
// it is for a Gateway or Sidecar, and whether the listener is inbound or
// outbound. The listeners created are summarized below.
//
// Direction   | Gateway    | Sidecar
// ------------|------------|--------------------------------------
// Inbound     | None       | per local service & port
// Outbound    | per Server | per HTTP port, per TCP service & port
//
// Filters are inserted into the processing chain in different ways for gateway
// and sidecar proxy listeners.
//
// To insert a filter into a `Gateway` listener, add the `HTTPFilterConfig` or
// `NetworkFilterConfig` to the `Server`. For example, to add the filter defined
// by the `HTTPFilterConfig` "my-filter" as the first filter, you can write the
// following.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: Gateway
// metadata:
//   name: my-ingress
// spec:
//   selector:
//     app: my-ingress-gateway
//   servers:
//   - port:
//       number: 80
//       name: http2
//       protocol: HTTP2
//     hosts:
//     - "*"
//     httpFilters:
//       order:
//         position: FIRST
//       names: ["my-filter"]
// ```
//
// To insert a filter into a sidecar listener, use a `SidecarFilterBinding`
// to select which sidecars and which listeners in the mesh to apply the filter.
// It includes a `match` that selects which listeners to insert
// the filter into, an `order` that specifies where in the filter chain to
// insert it.
//
// A given listener may match multiple `SidecarFilterBinding` objects, in which
// case each filter is inserted, including perhaps inserting the same kind of
// filter multiple times, with different or identical configuration. If multiple
// bindings use the same `Order`, the actual resultant ordering will be
// undefined and may not be stable over the life of the listener. Users are
// strongly encouraged to use `BEFORE` and `AFTER` order directives in cases
// where filter ordering is desired.
//
// The following example configures a Lua filter that authorizes an inbound
// request by calling an external service.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: HTTPFilterConfig
//     metadata:
//       name: reviews-auth
//       namespace: istio-system
//     spec:
//         name: envoy.lua
//         config: |
//          function envoy_on_request(request_handle)
//            -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
//            local headers, body = request_handle:httpCall(
//                                   "outbound||https|internal-auth-server.com",
//                                   {
//                                     [":method"] = "POST",
//                                     [":path"] = "/authorizeMeNow",
//                                     [":authority"] = "internal-auth-server.com"
//                                    },
//                                   "username=scoobydoo", 5000)
//             -- Add information from the HTTP call into the headers that are about to be sent to the next
//             -- filter in the filter chain.
//             request_handle:headers():add("upstream_foo", headers["foo"])
//             request_handle:headers():add("upstream_body_size", #body)
//          end
//
//
// To insert this Lua filter into the reviews service, use the following.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: SidecarFilterBinding
//     metadata:
//       name: reviews-auth
//       namespace: istio-system
//     spec:
//       matches:
//       - inbound:
//           servicePorts:
//             - host: reviews.prod.svc.cluster.local
//               portName: http
//       order:
//         position: BEFORE
//         relativeTo: router
//       httpFilter: "reviews-auth"
//
// and the associated ServiceEntry configuration to add
// internal-auth-server.com to the service registry:
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: ServiceEntry
//     metadata:
//       name: external-svc
//     spec:
//       hosts:
//       - internal-auth-server.com
//       ports:
//       - number: 443
//         name: http
//         protocol: HTTP # not HTTPS.
//       discovery: DNS
//
// and a DestinationRule to initiate TLS connections to the external service.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: DestinationRule
//     metadata:
//       name: tls-example
//     spec:
//       name: internal-auth-server.com
//       trafficPolicy:
//         tls:
//           mode: SIMPLE # initiates HTTPS when talking to internal-auth-server.com
//
//
type SidecarFilterBinding struct {
	// Match criteria for the filter to be inserted. When more than one Match is
	// included, a listener may match any for the filter to be inserted.
	Matches []*SidecarFilterBinding_Match `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	// Where in the filter chain to insert the filter. If omitted the filter
	// will be first in the resulting chain.
	Order *FilterOrder `protobuf:"bytes,2,opt,name=order" json:"order,omitempty"`
	// Name of the filter to insert.  Must be in the same namespace as this
	// SidecarFilterBinding.
	//
	// Types that are valid to be assigned to Filter:
	//	*SidecarFilterBinding_HttpFilter
	//	*SidecarFilterBinding_NetworkFilter
	Filter isSidecarFilterBinding_Filter `protobuf_oneof:"filter"`
}

func (m *SidecarFilterBinding) Reset()                    { *m = SidecarFilterBinding{} }
func (m *SidecarFilterBinding) String() string            { return proto.CompactTextString(m) }
func (*SidecarFilterBinding) ProtoMessage()               {}
func (*SidecarFilterBinding) Descriptor() ([]byte, []int) { return fileDescriptorFilter, []int{0} }

type isSidecarFilterBinding_Filter interface {
	isSidecarFilterBinding_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SidecarFilterBinding_HttpFilter struct {
	HttpFilter string `protobuf:"bytes,3,opt,name=http_filter,json=httpFilter,proto3,oneof"`
}
type SidecarFilterBinding_NetworkFilter struct {
	NetworkFilter string `protobuf:"bytes,4,opt,name=network_filter,json=networkFilter,proto3,oneof"`
}

func (*SidecarFilterBinding_HttpFilter) isSidecarFilterBinding_Filter()    {}
func (*SidecarFilterBinding_NetworkFilter) isSidecarFilterBinding_Filter() {}

func (m *SidecarFilterBinding) GetFilter() isSidecarFilterBinding_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *SidecarFilterBinding) GetMatches() []*SidecarFilterBinding_Match {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *SidecarFilterBinding) GetOrder() *FilterOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *SidecarFilterBinding) GetHttpFilter() string {
	if x, ok := m.GetFilter().(*SidecarFilterBinding_HttpFilter); ok {
		return x.HttpFilter
	}
	return ""
}

func (m *SidecarFilterBinding) GetNetworkFilter() string {
	if x, ok := m.GetFilter().(*SidecarFilterBinding_NetworkFilter); ok {
		return x.NetworkFilter
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SidecarFilterBinding) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SidecarFilterBinding_OneofMarshaler, _SidecarFilterBinding_OneofUnmarshaler, _SidecarFilterBinding_OneofSizer, []interface{}{
		(*SidecarFilterBinding_HttpFilter)(nil),
		(*SidecarFilterBinding_NetworkFilter)(nil),
	}
}

func _SidecarFilterBinding_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SidecarFilterBinding)
	// filter
	switch x := m.Filter.(type) {
	case *SidecarFilterBinding_HttpFilter:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.HttpFilter)
	case *SidecarFilterBinding_NetworkFilter:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.NetworkFilter)
	case nil:
	default:
		return fmt.Errorf("SidecarFilterBinding.Filter has unexpected type %T", x)
	}
	return nil
}

func _SidecarFilterBinding_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SidecarFilterBinding)
	switch tag {
	case 3: // filter.http_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Filter = &SidecarFilterBinding_HttpFilter{x}
		return true, err
	case 4: // filter.network_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Filter = &SidecarFilterBinding_NetworkFilter{x}
		return true, err
	default:
		return false, nil
	}
}

func _SidecarFilterBinding_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SidecarFilterBinding)
	// filter
	switch x := m.Filter.(type) {
	case *SidecarFilterBinding_HttpFilter:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.HttpFilter)))
		n += len(x.HttpFilter)
	case *SidecarFilterBinding_NetworkFilter:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.NetworkFilter)))
		n += len(x.NetworkFilter)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Match describes conditions which a sidecar listener must meet in order
// for the filter to be inserted.  Within a single Match message, if more
// than one field is included, they all must match the listener.
type SidecarFilterBinding_Match struct {
	// Match either inbound listeners, or outbound listeners.
	//
	// Types that are valid to be assigned to DirectionMatch:
	//	*SidecarFilterBinding_Match_Inbound
	//	*SidecarFilterBinding_Match_Outbound
	DirectionMatch isSidecarFilterBinding_Match_DirectionMatch `protobuf_oneof:"direction_match"`
	// Restricts the match to service instances which match the given
	// label selector. If unset, service instances are not restricted by
	// labels.
	ServiceInstanceSelector string `protobuf:"bytes,3,opt,name=service_instance_selector,json=serviceInstanceSelector,proto3" json:"service_instance_selector,omitempty"`
	// The types of listener to match.
	ListenerTypes []SidecarFilterBinding_Match_ListenerType `protobuf:"varint,4,rep,packed,name=listener_types,json=listenerTypes,enum=istio.networking.v1alpha3.SidecarFilterBinding_Match_ListenerType" json:"listener_types,omitempty"`
}

func (m *SidecarFilterBinding_Match) Reset()         { *m = SidecarFilterBinding_Match{} }
func (m *SidecarFilterBinding_Match) String() string { return proto.CompactTextString(m) }
func (*SidecarFilterBinding_Match) ProtoMessage()    {}
func (*SidecarFilterBinding_Match) Descriptor() ([]byte, []int) {
	return fileDescriptorFilter, []int{0, 0}
}

type isSidecarFilterBinding_Match_DirectionMatch interface {
	isSidecarFilterBinding_Match_DirectionMatch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SidecarFilterBinding_Match_Inbound struct {
	Inbound *SidecarFilterBinding_Match_InboundMatch `protobuf:"bytes,1,opt,name=inbound,oneof"`
}
type SidecarFilterBinding_Match_Outbound struct {
	Outbound *SidecarFilterBinding_Match_OutboundMatch `protobuf:"bytes,2,opt,name=outbound,oneof"`
}

func (*SidecarFilterBinding_Match_Inbound) isSidecarFilterBinding_Match_DirectionMatch()  {}
func (*SidecarFilterBinding_Match_Outbound) isSidecarFilterBinding_Match_DirectionMatch() {}

func (m *SidecarFilterBinding_Match) GetDirectionMatch() isSidecarFilterBinding_Match_DirectionMatch {
	if m != nil {
		return m.DirectionMatch
	}
	return nil
}

func (m *SidecarFilterBinding_Match) GetInbound() *SidecarFilterBinding_Match_InboundMatch {
	if x, ok := m.GetDirectionMatch().(*SidecarFilterBinding_Match_Inbound); ok {
		return x.Inbound
	}
	return nil
}

func (m *SidecarFilterBinding_Match) GetOutbound() *SidecarFilterBinding_Match_OutboundMatch {
	if x, ok := m.GetDirectionMatch().(*SidecarFilterBinding_Match_Outbound); ok {
		return x.Outbound
	}
	return nil
}

func (m *SidecarFilterBinding_Match) GetServiceInstanceSelector() string {
	if m != nil {
		return m.ServiceInstanceSelector
	}
	return ""
}

func (m *SidecarFilterBinding_Match) GetListenerTypes() []SidecarFilterBinding_Match_ListenerType {
	if m != nil {
		return m.ListenerTypes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SidecarFilterBinding_Match) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SidecarFilterBinding_Match_OneofMarshaler, _SidecarFilterBinding_Match_OneofUnmarshaler, _SidecarFilterBinding_Match_OneofSizer, []interface{}{
		(*SidecarFilterBinding_Match_Inbound)(nil),
		(*SidecarFilterBinding_Match_Outbound)(nil),
	}
}

func _SidecarFilterBinding_Match_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SidecarFilterBinding_Match)
	// direction_match
	switch x := m.DirectionMatch.(type) {
	case *SidecarFilterBinding_Match_Inbound:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Inbound); err != nil {
			return err
		}
	case *SidecarFilterBinding_Match_Outbound:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Outbound); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SidecarFilterBinding_Match.DirectionMatch has unexpected type %T", x)
	}
	return nil
}

func _SidecarFilterBinding_Match_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SidecarFilterBinding_Match)
	switch tag {
	case 1: // direction_match.inbound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SidecarFilterBinding_Match_InboundMatch)
		err := b.DecodeMessage(msg)
		m.DirectionMatch = &SidecarFilterBinding_Match_Inbound{msg}
		return true, err
	case 2: // direction_match.outbound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SidecarFilterBinding_Match_OutboundMatch)
		err := b.DecodeMessage(msg)
		m.DirectionMatch = &SidecarFilterBinding_Match_Outbound{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SidecarFilterBinding_Match_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SidecarFilterBinding_Match)
	// direction_match
	switch x := m.DirectionMatch.(type) {
	case *SidecarFilterBinding_Match_Inbound:
		s := proto.Size(x.Inbound)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SidecarFilterBinding_Match_Outbound:
		s := proto.Size(x.Outbound)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SidecarFilterBinding_Match_ServicePort struct {
	// The destination hosts to which traffic is being sent. Depending on the
	// platform, short-names can also be used instead of a FQDN (i.e. has no
	// dots in the name). In such a scenario, the FQDN of the host would be
	// derived based on the underlying platform. If omitted it will match
	// any destination.
	//
	// *Note for Kubernetes users*: When short names are used (e.g. "reviews"
	// instead of "reviews.default.svc.cluster.local"), Istio will interpret
	// the short name based on the namespace of the rule, not the service. A
	// rule in the "default" namespace containing a host "reviews will be
	// interpreted as "reviews.default.svc.cluster.local", irrespective of
	// the actual namespace associated with the reviews service. _To avoid
	// potential misconfigurations, it is recommended to always use fully
	// qualified domain names over short names.
	//
	// HTTP service hosts must always be identified by name. TCP service
	// hosts may be identified by (possibly virtual) IP address, if that
	// is how they are identified in the Istio service registry.
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// The name of the port on the service.
	PortName string `protobuf:"bytes,2,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
}

func (m *SidecarFilterBinding_Match_ServicePort) Reset() {
	*m = SidecarFilterBinding_Match_ServicePort{}
}
func (m *SidecarFilterBinding_Match_ServicePort) String() string { return proto.CompactTextString(m) }
func (*SidecarFilterBinding_Match_ServicePort) ProtoMessage()    {}
func (*SidecarFilterBinding_Match_ServicePort) Descriptor() ([]byte, []int) {
	return fileDescriptorFilter, []int{0, 0, 0}
}

func (m *SidecarFilterBinding_Match_ServicePort) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SidecarFilterBinding_Match_ServicePort) GetPortName() string {
	if m != nil {
		return m.PortName
	}
	return ""
}

// Match inbound listeners.  In sidecars, there is one listener per
// local service port.
type SidecarFilterBinding_Match_InboundMatch struct {
	// List of service ports to match listeners for. If more than one
	// entry is listed, any may match the listener for the filter to be
	// added.
	ServicePorts []*SidecarFilterBinding_Match_ServicePort `protobuf:"bytes,1,rep,name=service_ports,json=servicePorts" json:"service_ports,omitempty"`
}

func (m *SidecarFilterBinding_Match_InboundMatch) Reset() {
	*m = SidecarFilterBinding_Match_InboundMatch{}
}
func (m *SidecarFilterBinding_Match_InboundMatch) String() string { return proto.CompactTextString(m) }
func (*SidecarFilterBinding_Match_InboundMatch) ProtoMessage()    {}
func (*SidecarFilterBinding_Match_InboundMatch) Descriptor() ([]byte, []int) {
	return fileDescriptorFilter, []int{0, 0, 1}
}

func (m *SidecarFilterBinding_Match_InboundMatch) GetServicePorts() []*SidecarFilterBinding_Match_ServicePort {
	if m != nil {
		return m.ServicePorts
	}
	return nil
}

// Match outbound listeners. In sidecars, there is one listener per
// numeric port serving HTTP traffic in the mesh, and also one listener
// per service IP and port serving TCP traffic in the mesh. The match
// set is the union of both lists in this message.
type SidecarFilterBinding_Match_OutboundMatch struct {
	// List of numeric HTTP ports to match listeners for. If more than
	// one entry is listed, any may match the listener for the filter
	// to be added. If omitted all listeners are considered to match.
	HttpPorts []uint32 `protobuf:"varint,1,rep,packed,name=http_ports,json=httpPorts" json:"http_ports,omitempty"`
	// List of TCP service ports to match listeners for. If more than
	// one entry is listed, any may match the listener for the filter to
	// be added. If this list is non-empty, the filter MUST be a network
	// filter. HTTP listeners will never match entries in this list. If
	// omitted, and the filter is a network filter, all TCP listeners
	// will match.
	TcpServicePorts []*SidecarFilterBinding_Match_ServicePort `protobuf:"bytes,2,rep,name=tcp_service_ports,json=tcpServicePorts" json:"tcp_service_ports,omitempty"`
}

func (m *SidecarFilterBinding_Match_OutboundMatch) Reset() {
	*m = SidecarFilterBinding_Match_OutboundMatch{}
}
func (m *SidecarFilterBinding_Match_OutboundMatch) String() string { return proto.CompactTextString(m) }
func (*SidecarFilterBinding_Match_OutboundMatch) ProtoMessage()    {}
func (*SidecarFilterBinding_Match_OutboundMatch) Descriptor() ([]byte, []int) {
	return fileDescriptorFilter, []int{0, 0, 2}
}

func (m *SidecarFilterBinding_Match_OutboundMatch) GetHttpPorts() []uint32 {
	if m != nil {
		return m.HttpPorts
	}
	return nil
}

func (m *SidecarFilterBinding_Match_OutboundMatch) GetTcpServicePorts() []*SidecarFilterBinding_Match_ServicePort {
	if m != nil {
		return m.TcpServicePorts
	}
	return nil
}

// FilterOrder describes where in the filter chain to insert the filter.
type FilterOrder struct {
	// Position of this filter relative to another or the entire chain.
	Position FilterOrder_Position `protobuf:"varint,1,opt,name=position,proto3,enum=istio.networking.v1alpha3.FilterOrder_Position" json:"position,omitempty"`
	// Name of the filter the postion is relative to, for `BEFORE` and
	// `AFTER` positions.  Ignored for `FIRST` or `LAST`.
	RelativeTo string `protobuf:"bytes,2,opt,name=relative_to,json=relativeTo,proto3" json:"relative_to,omitempty"`
}

func (m *FilterOrder) Reset()                    { *m = FilterOrder{} }
func (m *FilterOrder) String() string            { return proto.CompactTextString(m) }
func (*FilterOrder) ProtoMessage()               {}
func (*FilterOrder) Descriptor() ([]byte, []int) { return fileDescriptorFilter, []int{1} }

func (m *FilterOrder) GetPosition() FilterOrder_Position {
	if m != nil {
		return m.Position
	}
	return FilterOrder_FIRST
}

func (m *FilterOrder) GetRelativeTo() string {
	if m != nil {
		return m.RelativeTo
	}
	return ""
}

// An HTTPFilter operates on HTTP requests and responses.
type HTTPFilterConfig struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf2.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
}

func (m *HTTPFilterConfig) Reset()                    { *m = HTTPFilterConfig{} }
func (m *HTTPFilterConfig) String() string            { return proto.CompactTextString(m) }
func (*HTTPFilterConfig) ProtoMessage()               {}
func (*HTTPFilterConfig) Descriptor() ([]byte, []int) { return fileDescriptorFilter, []int{2} }

func (m *HTTPFilterConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPFilterConfig) GetConfig() *google_protobuf2.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

// A NetworkFilter operates the the network layer and operates on connections
// and byte streams.
type NetworkFilterConfig struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf2.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
}

func (m *NetworkFilterConfig) Reset()                    { *m = NetworkFilterConfig{} }
func (m *NetworkFilterConfig) String() string            { return proto.CompactTextString(m) }
func (*NetworkFilterConfig) ProtoMessage()               {}
func (*NetworkFilterConfig) Descriptor() ([]byte, []int) { return fileDescriptorFilter, []int{3} }

func (m *NetworkFilterConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkFilterConfig) GetConfig() *google_protobuf2.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*SidecarFilterBinding)(nil), "istio.networking.v1alpha3.SidecarFilterBinding")
	proto.RegisterType((*SidecarFilterBinding_Match)(nil), "istio.networking.v1alpha3.SidecarFilterBinding.Match")
	proto.RegisterType((*SidecarFilterBinding_Match_ServicePort)(nil), "istio.networking.v1alpha3.SidecarFilterBinding.Match.ServicePort")
	proto.RegisterType((*SidecarFilterBinding_Match_InboundMatch)(nil), "istio.networking.v1alpha3.SidecarFilterBinding.Match.InboundMatch")
	proto.RegisterType((*SidecarFilterBinding_Match_OutboundMatch)(nil), "istio.networking.v1alpha3.SidecarFilterBinding.Match.OutboundMatch")
	proto.RegisterType((*FilterOrder)(nil), "istio.networking.v1alpha3.FilterOrder")
	proto.RegisterType((*HTTPFilterConfig)(nil), "istio.networking.v1alpha3.HTTPFilterConfig")
	proto.RegisterType((*NetworkFilterConfig)(nil), "istio.networking.v1alpha3.NetworkFilterConfig")
	proto.RegisterEnum("istio.networking.v1alpha3.SidecarFilterBinding_Match_ListenerType", SidecarFilterBinding_Match_ListenerType_name, SidecarFilterBinding_Match_ListenerType_value)
	proto.RegisterEnum("istio.networking.v1alpha3.FilterOrder_Position", FilterOrder_Position_name, FilterOrder_Position_value)
}
func (m *SidecarFilterBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarFilterBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, msg := range m.Matches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFilter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Order != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Order.Size()))
		n1, err := m.Order.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Filter != nil {
		nn2, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *SidecarFilterBinding_HttpFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintFilter(dAtA, i, uint64(len(m.HttpFilter)))
	i += copy(dAtA[i:], m.HttpFilter)
	return i, nil
}
func (m *SidecarFilterBinding_NetworkFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x22
	i++
	i = encodeVarintFilter(dAtA, i, uint64(len(m.NetworkFilter)))
	i += copy(dAtA[i:], m.NetworkFilter)
	return i, nil
}
func (m *SidecarFilterBinding_Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarFilterBinding_Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DirectionMatch != nil {
		nn3, err := m.DirectionMatch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if len(m.ServiceInstanceSelector) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.ServiceInstanceSelector)))
		i += copy(dAtA[i:], m.ServiceInstanceSelector)
	}
	if len(m.ListenerTypes) > 0 {
		dAtA5 := make([]byte, len(m.ListenerTypes)*10)
		var j4 int
		for _, num := range m.ListenerTypes {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintFilter(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *SidecarFilterBinding_Match_Inbound) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Inbound != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Inbound.Size()))
		n6, err := m.Inbound.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *SidecarFilterBinding_Match_Outbound) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Outbound != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Outbound.Size()))
		n7, err := m.Outbound.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *SidecarFilterBinding_Match_ServicePort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarFilterBinding_Match_ServicePort) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if len(m.PortName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.PortName)))
		i += copy(dAtA[i:], m.PortName)
	}
	return i, nil
}

func (m *SidecarFilterBinding_Match_InboundMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarFilterBinding_Match_InboundMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServicePorts) > 0 {
		for _, msg := range m.ServicePorts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFilter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SidecarFilterBinding_Match_OutboundMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SidecarFilterBinding_Match_OutboundMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HttpPorts) > 0 {
		dAtA9 := make([]byte, len(m.HttpPorts)*10)
		var j8 int
		for _, num := range m.HttpPorts {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilter(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.TcpServicePorts) > 0 {
		for _, msg := range m.TcpServicePorts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFilter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FilterOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Position))
	}
	if len(m.RelativeTo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.RelativeTo)))
		i += copy(dAtA[i:], m.RelativeTo)
	}
	return i, nil
}

func (m *HTTPFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Config.Size()))
		n10, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *NetworkFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilter(dAtA, i, uint64(m.Config.Size()))
		n11, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func encodeVarintFilter(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SidecarFilterBinding) Size() (n int) {
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, e := range m.Matches {
			l = e.Size()
			n += 1 + l + sovFilter(uint64(l))
		}
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovFilter(uint64(l))
	}
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	return n
}

func (m *SidecarFilterBinding_HttpFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.HttpFilter)
	n += 1 + l + sovFilter(uint64(l))
	return n
}
func (m *SidecarFilterBinding_NetworkFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.NetworkFilter)
	n += 1 + l + sovFilter(uint64(l))
	return n
}
func (m *SidecarFilterBinding_Match) Size() (n int) {
	var l int
	_ = l
	if m.DirectionMatch != nil {
		n += m.DirectionMatch.Size()
	}
	l = len(m.ServiceInstanceSelector)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	if len(m.ListenerTypes) > 0 {
		l = 0
		for _, e := range m.ListenerTypes {
			l += sovFilter(uint64(e))
		}
		n += 1 + sovFilter(uint64(l)) + l
	}
	return n
}

func (m *SidecarFilterBinding_Match_Inbound) Size() (n int) {
	var l int
	_ = l
	if m.Inbound != nil {
		l = m.Inbound.Size()
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}
func (m *SidecarFilterBinding_Match_Outbound) Size() (n int) {
	var l int
	_ = l
	if m.Outbound != nil {
		l = m.Outbound.Size()
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}
func (m *SidecarFilterBinding_Match_ServicePort) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	l = len(m.PortName)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}

func (m *SidecarFilterBinding_Match_InboundMatch) Size() (n int) {
	var l int
	_ = l
	if len(m.ServicePorts) > 0 {
		for _, e := range m.ServicePorts {
			l = e.Size()
			n += 1 + l + sovFilter(uint64(l))
		}
	}
	return n
}

func (m *SidecarFilterBinding_Match_OutboundMatch) Size() (n int) {
	var l int
	_ = l
	if len(m.HttpPorts) > 0 {
		l = 0
		for _, e := range m.HttpPorts {
			l += sovFilter(uint64(e))
		}
		n += 1 + sovFilter(uint64(l)) + l
	}
	if len(m.TcpServicePorts) > 0 {
		for _, e := range m.TcpServicePorts {
			l = e.Size()
			n += 1 + l + sovFilter(uint64(l))
		}
	}
	return n
}

func (m *FilterOrder) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovFilter(uint64(m.Position))
	}
	l = len(m.RelativeTo)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}

func (m *HTTPFilterConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}

func (m *NetworkFilterConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFilter(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFilter(uint64(l))
	}
	return n
}

func sovFilter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFilter(x uint64) (n int) {
	return sovFilter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SidecarFilterBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SidecarFilterBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SidecarFilterBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matches = append(m.Matches, &SidecarFilterBinding_Match{})
			if err := m.Matches[len(m.Matches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &FilterOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = &SidecarFilterBinding_HttpFilter{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = &SidecarFilterBinding_NetworkFilter{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarFilterBinding_Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inbound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SidecarFilterBinding_Match_InboundMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DirectionMatch = &SidecarFilterBinding_Match_Inbound{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outbound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SidecarFilterBinding_Match_OutboundMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.DirectionMatch = &SidecarFilterBinding_Match_Outbound{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceInstanceSelector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceInstanceSelector = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v SidecarFilterBinding_Match_ListenerType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (SidecarFilterBinding_Match_ListenerType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ListenerTypes = append(m.ListenerTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFilter
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v SidecarFilterBinding_Match_ListenerType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (SidecarFilterBinding_Match_ListenerType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ListenerTypes = append(m.ListenerTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarFilterBinding_Match_ServicePort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarFilterBinding_Match_InboundMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InboundMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InboundMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePorts = append(m.ServicePorts, &SidecarFilterBinding_Match_ServicePort{})
			if err := m.ServicePorts[len(m.ServicePorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SidecarFilterBinding_Match_OutboundMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OutboundMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OutboundMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.HttpPorts = append(m.HttpPorts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFilter
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.HttpPorts = append(m.HttpPorts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpPorts", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcpServicePorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TcpServicePorts = append(m.TcpServicePorts, &SidecarFilterBinding_Match_ServicePort{})
			if err := m.TcpServicePorts[len(m.TcpServicePorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (FilterOrder_Position(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf2.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilter
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf2.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFilter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFilter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFilter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFilter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFilter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFilter(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFilter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFilter   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("networking/v1alpha3/filter.proto", fileDescriptorFilter) }

var fileDescriptorFilter = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcf, 0x6e, 0xd3, 0x4e,
	0x10, 0x8e, 0x9b, 0xff, 0x93, 0x26, 0x75, 0xf7, 0xf7, 0x93, 0x9a, 0x06, 0x28, 0x69, 0x0e, 0x90,
	0x93, 0x2d, 0x5a, 0xc1, 0x01, 0x21, 0xa4, 0xa6, 0x6a, 0xd4, 0x8a, 0xd2, 0x44, 0x1b, 0x4b, 0x48,
	0x3d, 0x60, 0xb9, 0xce, 0x26, 0x59, 0xe1, 0x78, 0x2d, 0xef, 0x26, 0xa8, 0x0f, 0xc3, 0x53, 0xf0,
	0x12, 0x1c, 0x79, 0x04, 0x94, 0xf7, 0x40, 0x20, 0xef, 0xae, 0x5b, 0x57, 0x2a, 0x08, 0x45, 0xbd,
	0x79, 0x66, 0xbf, 0xf9, 0x66, 0xe6, 0xf3, 0xcc, 0x40, 0x3b, 0x24, 0xe2, 0x33, 0x8b, 0x3f, 0xd1,
	0x70, 0x6a, 0x2f, 0x5f, 0x78, 0x41, 0x34, 0xf3, 0x0e, 0xed, 0x09, 0x0d, 0x04, 0x89, 0xad, 0x28,
	0x66, 0x82, 0xa1, 0x5d, 0xca, 0x05, 0x65, 0xd6, 0x2d, 0xce, 0x4a, 0x71, 0xad, 0xc7, 0x53, 0xc6,
	0xa6, 0x01, 0xb1, 0x25, 0xf0, 0x6a, 0x31, 0xb1, 0xb9, 0x88, 0x17, 0xbe, 0x50, 0x81, 0x9d, 0x9f,
	0x65, 0xf8, 0x7f, 0x44, 0xc7, 0xc4, 0xf7, 0xe2, 0xbe, 0x24, 0xec, 0xd1, 0x70, 0x4c, 0xc3, 0x29,
	0x1a, 0x40, 0x79, 0xee, 0x09, 0x7f, 0x46, 0x78, 0xd3, 0x68, 0xe7, 0xbb, 0xb5, 0x83, 0x97, 0xd6,
	0x1f, 0x73, 0x58, 0xf7, 0x31, 0x58, 0xef, 0x93, 0x70, 0x9c, 0xb2, 0xa0, 0x37, 0x50, 0x64, 0xf1,
	0x98, 0xc4, 0xcd, 0x8d, 0xb6, 0xd1, 0xad, 0x1d, 0x3c, 0xfb, 0x0b, 0x9d, 0xe2, 0x19, 0x24, 0x68,
	0xac, 0x82, 0xd0, 0x3e, 0xd4, 0x66, 0x42, 0x44, 0xae, 0xea, 0xba, 0x99, 0x6f, 0x1b, 0xdd, 0xea,
	0x69, 0x0e, 0x43, 0xe2, 0x54, 0x70, 0xf4, 0x1c, 0x1a, 0x9a, 0x2c, 0x45, 0x15, 0x34, 0xaa, 0xae,
	0xfd, 0x0a, 0xd8, 0xfa, 0x55, 0x84, 0xa2, 0x2c, 0x0e, 0x7d, 0x84, 0x32, 0x0d, 0xaf, 0xd8, 0x22,
	0x1c, 0x37, 0x0d, 0x59, 0x55, 0x6f, 0xad, 0x26, 0xad, 0x33, 0x45, 0x22, 0x8d, 0xd3, 0x1c, 0x4e,
	0x49, 0x91, 0x07, 0x15, 0xb6, 0x10, 0x2a, 0x81, 0x6a, 0xfb, 0x78, 0xbd, 0x04, 0x03, 0xcd, 0x92,
	0x66, 0xb8, 0xa1, 0x45, 0xaf, 0x61, 0x97, 0x93, 0x78, 0x49, 0x7d, 0xe2, 0xd2, 0x90, 0x0b, 0x2f,
	0xf4, 0x89, 0xcb, 0x49, 0x40, 0x7c, 0xc1, 0xb4, 0x4c, 0x78, 0x47, 0x03, 0xce, 0xf4, 0xfb, 0x48,
	0x3f, 0x23, 0x0a, 0x8d, 0x80, 0x72, 0x41, 0x42, 0x12, 0xbb, 0xe2, 0x3a, 0x22, 0xbc, 0x59, 0x68,
	0xe7, 0xbb, 0x8d, 0x75, 0x55, 0x38, 0xd7, 0x5c, 0xce, 0x75, 0x44, 0x70, 0x3d, 0xc8, 0x58, 0xbc,
	0xf5, 0x16, 0x6a, 0x23, 0x55, 0xc5, 0x90, 0xc5, 0x02, 0x21, 0x28, 0xcc, 0x18, 0x17, 0x52, 0xf5,
	0x2a, 0x96, 0xdf, 0xe8, 0x11, 0x54, 0x23, 0x16, 0x0b, 0x37, 0xf4, 0xe6, 0x44, 0xaa, 0x55, 0xc5,
	0x95, 0xc4, 0x71, 0xe1, 0xcd, 0x49, 0x6b, 0x09, 0x9b, 0x59, 0x91, 0xd1, 0x04, 0xea, 0x69, 0xdb,
	0x09, 0x26, 0x1d, 0xd2, 0xa3, 0xf5, 0x2a, 0xcf, 0x94, 0x86, 0x37, 0xf9, 0xad, 0xc1, 0x5b, 0x5f,
	0x0c, 0xa8, 0xdf, 0x11, 0x1f, 0x3d, 0x01, 0x39, 0x74, 0x99, 0xb4, 0x75, 0x5c, 0x4d, 0x3c, 0x32,
	0x00, 0xcd, 0x61, 0x5b, 0xf8, 0x91, 0x7b, 0xb7, 0xb8, 0x8d, 0x87, 0x2a, 0x6e, 0x4b, 0xf8, 0x51,
	0xc6, 0xe6, 0x9d, 0x7d, 0xd8, 0xcc, 0xca, 0x8e, 0x2a, 0x50, 0x38, 0x75, 0x9c, 0xa1, 0x99, 0x43,
	0x65, 0xc8, 0x3b, 0xc7, 0x43, 0xd3, 0xe8, 0x6d, 0xc3, 0xd6, 0x98, 0xc6, 0xc4, 0x17, 0x94, 0x85,
	0xae, 0xdc, 0xc6, 0x5e, 0x05, 0x4a, 0x6a, 0x45, 0x3a, 0x5f, 0x0d, 0xa8, 0x65, 0xd6, 0x0d, 0xbd,
	0x83, 0x4a, 0xc4, 0x38, 0x4d, 0xb0, 0xf2, 0xe7, 0x34, 0x0e, 0xec, 0x7f, 0x5b, 0x54, 0x6b, 0xa8,
	0xc3, 0xf0, 0x0d, 0x01, 0x7a, 0x0a, 0xb5, 0x98, 0x04, 0x9e, 0xa0, 0x4b, 0xe2, 0x0a, 0xa6, 0xff,
	0x29, 0xa4, 0x2e, 0x87, 0x75, 0x5e, 0x41, 0x25, 0x0d, 0x43, 0x55, 0x28, 0xf6, 0xcf, 0xf0, 0xc8,
	0x31, 0x73, 0x49, 0x13, 0xe7, 0x47, 0x23, 0xc7, 0x34, 0x10, 0x40, 0xa9, 0x77, 0xd2, 0x1f, 0xe0,
	0x13, 0x73, 0x23, 0x01, 0x1c, 0xf5, 0x9d, 0x13, 0x6c, 0xe6, 0x3b, 0x1f, 0xc0, 0x4c, 0xba, 0x54,
	0xe9, 0x8f, 0x59, 0x38, 0xa1, 0xd3, 0x64, 0xa4, 0xe4, 0xe4, 0xe8, 0x91, 0x4a, 0xbe, 0x91, 0x0d,
	0x25, 0x5f, 0xbe, 0xea, 0xed, 0xdb, 0xb1, 0xd4, 0x31, 0xb4, 0xd2, 0x63, 0x68, 0x8d, 0xe4, 0x31,
	0xc4, 0x1a, 0xd6, 0xb9, 0x84, 0xff, 0x2e, 0xb2, 0xb7, 0xe2, 0x01, 0xb9, 0x7b, 0xd6, 0xb7, 0xd5,
	0x9e, 0xf1, 0x7d, 0xb5, 0x67, 0xfc, 0x58, 0xed, 0x19, 0x97, 0x6d, 0xa5, 0x2a, 0x65, 0xb6, 0x17,
	0x51, 0xfb, 0x9e, 0x03, 0x7f, 0x55, 0x92, 0x44, 0x87, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x62,
	0x99, 0x32, 0x05, 0xfe, 0x05, 0x00, 0x00,
}
