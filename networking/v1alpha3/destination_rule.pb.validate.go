// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: networking/v1alpha3/destination_rule.proto

package v1alpha3

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/golang/protobuf/ptypes"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = ptypes.DynamicAny{}
)

// Validate checks the field values on DestinationRule with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *DestinationRule) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Host

	if v, ok := interface{}(m.GetTrafficPolicy()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return DestinationRuleValidationError{
				field:  "TrafficPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSubsets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface {
			Validate() error
		}); ok {
			if err := v.Validate(); err != nil {
				return DestinationRuleValidationError{
					field:  fmt.Sprintf("Subsets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// DestinationRuleValidationError is the validation error returned by
// DestinationRule.Validate if the designated constraints aren't met.
type DestinationRuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestinationRuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestinationRuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestinationRuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestinationRuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestinationRuleValidationError) ErrorName() string { return "DestinationRuleValidationError" }

// Error satisfies the builtin error interface
func (e DestinationRuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestinationRule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestinationRuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestinationRuleValidationError{}

// Validate checks the field values on TrafficPolicy with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *TrafficPolicy) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetLoadBalancer()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicyValidationError{
				field:  "LoadBalancer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetConnectionPool()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicyValidationError{
				field:  "ConnectionPool",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetOutlierDetection()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicyValidationError{
				field:  "OutlierDetection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTls()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicyValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPortLevelSettings() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface {
			Validate() error
		}); ok {
			if err := v.Validate(); err != nil {
				return TrafficPolicyValidationError{
					field:  fmt.Sprintf("PortLevelSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// TrafficPolicyValidationError is the validation error returned by
// TrafficPolicy.Validate if the designated constraints aren't met.
type TrafficPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrafficPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrafficPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrafficPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrafficPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrafficPolicyValidationError) ErrorName() string { return "TrafficPolicyValidationError" }

// Error satisfies the builtin error interface
func (e TrafficPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrafficPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrafficPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrafficPolicyValidationError{}

// Validate checks the field values on Subset with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *Subset) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Name

	// no validation rules for Labels

	if v, ok := interface{}(m.GetTrafficPolicy()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return SubsetValidationError{
				field:  "TrafficPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// SubsetValidationError is the validation error returned by Subset.Validate if
// the designated constraints aren't met.
type SubsetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubsetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubsetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubsetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubsetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubsetValidationError) ErrorName() string { return "SubsetValidationError" }

// Error satisfies the builtin error interface
func (e SubsetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubsetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubsetValidationError{}

// Validate checks the field values on LoadBalancerSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *LoadBalancerSettings) Validate() error {
	if m == nil {
		return nil
	}

	switch m.LbPolicy.(type) {

	case *LoadBalancerSettings_Simple:
		// no validation rules for Simple

	case *LoadBalancerSettings_ConsistentHash:

		if v, ok := interface{}(m.GetConsistentHash()).(interface {
			Validate() error
		}); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerSettingsValidationError{
					field:  "ConsistentHash",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	return nil
}

// LoadBalancerSettingsValidationError is the validation error returned by
// LoadBalancerSettings.Validate if the designated constraints aren't met.
type LoadBalancerSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancerSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancerSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerSettingsValidationError) ErrorName() string {
	return "LoadBalancerSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e LoadBalancerSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancerSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerSettingsValidationError{}

// Validate checks the field values on ConnectionPoolSettings with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ConnectionPoolSettings) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetTcp()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return ConnectionPoolSettingsValidationError{
				field:  "Tcp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetHttp()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return ConnectionPoolSettingsValidationError{
				field:  "Http",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ConnectionPoolSettingsValidationError is the validation error returned by
// ConnectionPoolSettings.Validate if the designated constraints aren't met.
type ConnectionPoolSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionPoolSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionPoolSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionPoolSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionPoolSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionPoolSettingsValidationError) ErrorName() string {
	return "ConnectionPoolSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionPoolSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionPoolSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionPoolSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionPoolSettingsValidationError{}

// Validate checks the field values on OutlierDetection with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *OutlierDetection) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for ConsecutiveErrors

	if v, ok := interface{}(m.GetInterval()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetBaseEjectionTime()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return OutlierDetectionValidationError{
				field:  "BaseEjectionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxEjectionPercent

	return nil
}

// OutlierDetectionValidationError is the validation error returned by
// OutlierDetection.Validate if the designated constraints aren't met.
type OutlierDetectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutlierDetectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutlierDetectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutlierDetectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutlierDetectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutlierDetectionValidationError) ErrorName() string { return "OutlierDetectionValidationError" }

// Error satisfies the builtin error interface
func (e OutlierDetectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutlierDetection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutlierDetectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutlierDetectionValidationError{}

// Validate checks the field values on TLSSettings with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *TLSSettings) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Mode

	// no validation rules for ClientCertificate

	// no validation rules for PrivateKey

	// no validation rules for CaCertificates

	// no validation rules for Sni

	return nil
}

// TLSSettingsValidationError is the validation error returned by
// TLSSettings.Validate if the designated constraints aren't met.
type TLSSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TLSSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TLSSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TLSSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TLSSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TLSSettingsValidationError) ErrorName() string { return "TLSSettingsValidationError" }

// Error satisfies the builtin error interface
func (e TLSSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTLSSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TLSSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TLSSettingsValidationError{}

// Validate checks the field values on TrafficPolicy_PortTrafficPolicy with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *TrafficPolicy_PortTrafficPolicy) Validate() error {
	if m == nil {
		return nil
	}

	if v, ok := interface{}(m.GetPort()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicy_PortTrafficPolicyValidationError{
				field:  "Port",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetLoadBalancer()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicy_PortTrafficPolicyValidationError{
				field:  "LoadBalancer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetConnectionPool()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicy_PortTrafficPolicyValidationError{
				field:  "ConnectionPool",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetOutlierDetection()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicy_PortTrafficPolicyValidationError{
				field:  "OutlierDetection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if v, ok := interface{}(m.GetTls()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return TrafficPolicy_PortTrafficPolicyValidationError{
				field:  "Tls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// TrafficPolicy_PortTrafficPolicyValidationError is the validation error
// returned by TrafficPolicy_PortTrafficPolicy.Validate if the designated
// constraints aren't met.
type TrafficPolicy_PortTrafficPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrafficPolicy_PortTrafficPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrafficPolicy_PortTrafficPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrafficPolicy_PortTrafficPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrafficPolicy_PortTrafficPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrafficPolicy_PortTrafficPolicyValidationError) ErrorName() string {
	return "TrafficPolicy_PortTrafficPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e TrafficPolicy_PortTrafficPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrafficPolicy_PortTrafficPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrafficPolicy_PortTrafficPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrafficPolicy_PortTrafficPolicyValidationError{}

// Validate checks the field values on LoadBalancerSettings_ConsistentHashLB
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *LoadBalancerSettings_ConsistentHashLB) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for MinimumRingSize

	switch m.HashKey.(type) {

	case *LoadBalancerSettings_ConsistentHashLB_HttpHeaderName:
		// no validation rules for HttpHeaderName

	case *LoadBalancerSettings_ConsistentHashLB_HttpCookie:

		if v, ok := interface{}(m.GetHttpCookie()).(interface {
			Validate() error
		}); ok {
			if err := v.Validate(); err != nil {
				return LoadBalancerSettings_ConsistentHashLBValidationError{
					field:  "HttpCookie",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *LoadBalancerSettings_ConsistentHashLB_UseSourceIp:
		// no validation rules for UseSourceIp

	}

	return nil
}

// LoadBalancerSettings_ConsistentHashLBValidationError is the validation error
// returned by LoadBalancerSettings_ConsistentHashLB.Validate if the
// designated constraints aren't met.
type LoadBalancerSettings_ConsistentHashLBValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerSettings_ConsistentHashLBValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoadBalancerSettings_ConsistentHashLBValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoadBalancerSettings_ConsistentHashLBValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerSettings_ConsistentHashLBValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerSettings_ConsistentHashLBValidationError) ErrorName() string {
	return "LoadBalancerSettings_ConsistentHashLBValidationError"
}

// Error satisfies the builtin error interface
func (e LoadBalancerSettings_ConsistentHashLBValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancerSettings_ConsistentHashLB.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerSettings_ConsistentHashLBValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerSettings_ConsistentHashLBValidationError{}

// Validate checks the field values on
// LoadBalancerSettings_ConsistentHashLB_HTTPCookie with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *LoadBalancerSettings_ConsistentHashLB_HTTPCookie) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Name

	// no validation rules for Path

	if v, ok := interface{}(m.GetTtl()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError{
				field:  "Ttl",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError is the
// validation error returned by
// LoadBalancerSettings_ConsistentHashLB_HTTPCookie.Validate if the designated
// constraints aren't met.
type LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) ErrorName() string {
	return "LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError"
}

// Error satisfies the builtin error interface
func (e LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoadBalancerSettings_ConsistentHashLB_HTTPCookie.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoadBalancerSettings_ConsistentHashLB_HTTPCookieValidationError{}

// Validate checks the field values on ConnectionPoolSettings_TCPSettings with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *ConnectionPoolSettings_TCPSettings) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for MaxConnections

	if v, ok := interface{}(m.GetConnectTimeout()).(interface {
		Validate() error
	}); ok {
		if err := v.Validate(); err != nil {
			return ConnectionPoolSettings_TCPSettingsValidationError{
				field:  "ConnectTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	return nil
}

// ConnectionPoolSettings_TCPSettingsValidationError is the validation error
// returned by ConnectionPoolSettings_TCPSettings.Validate if the designated
// constraints aren't met.
type ConnectionPoolSettings_TCPSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionPoolSettings_TCPSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionPoolSettings_TCPSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionPoolSettings_TCPSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionPoolSettings_TCPSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionPoolSettings_TCPSettingsValidationError) ErrorName() string {
	return "ConnectionPoolSettings_TCPSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionPoolSettings_TCPSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionPoolSettings_TCPSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionPoolSettings_TCPSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionPoolSettings_TCPSettingsValidationError{}

// Validate checks the field values on ConnectionPoolSettings_HTTPSettings with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned.
func (m *ConnectionPoolSettings_HTTPSettings) Validate() error {
	if m == nil {
		return nil
	}

	// no validation rules for Http1MaxPendingRequests

	// no validation rules for Http2MaxRequests

	// no validation rules for MaxRequestsPerConnection

	// no validation rules for MaxRetries

	return nil
}

// ConnectionPoolSettings_HTTPSettingsValidationError is the validation error
// returned by ConnectionPoolSettings_HTTPSettings.Validate if the designated
// constraints aren't met.
type ConnectionPoolSettings_HTTPSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionPoolSettings_HTTPSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionPoolSettings_HTTPSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionPoolSettings_HTTPSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionPoolSettings_HTTPSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionPoolSettings_HTTPSettingsValidationError) ErrorName() string {
	return "ConnectionPoolSettings_HTTPSettingsValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionPoolSettings_HTTPSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionPoolSettings_HTTPSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionPoolSettings_HTTPSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionPoolSettings_HTTPSettingsValidationError{}
