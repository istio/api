// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/service_dependency.proto

package v1alpha3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ConfigScope defines the visibility of an Istio configuration artifact in
// a namespace when the namespace is imported.  By default all
// configuration artifacts are public. Configurations with private scope
// will not be imported when the namespace containing the configuration is
// imported in a ServiceDependency.
type ConfigScope int32

const (
	// Config with this scope are visible to all workloads in the mesh
	ConfigScope_PUBLIC ConfigScope = 0
	// Configs with this scope are visible to only workloads in the same
	// namespace as the configuration resource.
	ConfigScope_PRIVATE ConfigScope = 1
)

var ConfigScope_name = map[int32]string{
	0: "PUBLIC",
	1: "PRIVATE",
}
var ConfigScope_value = map[string]int32{
	"PUBLIC":  0,
	"PRIVATE": 1,
}

func (x ConfigScope) String() string {
	return proto.EnumName(ConfigScope_name, int32(x))
}
func (ConfigScope) EnumDescriptor() ([]byte, []int) { return fileDescriptorServiceDependency, []int{0} }

// `ServiceDependency` describes the set of services that a workload depends on
// for its operation. In other words, it describes the properties of
// outgoing traffic from a given workload. By default, the service mesh
// established by Istio will have a full mesh connectivity - i.e. every
// workload will have proxy configuration required to reach every other
// workload in the mesh. However most connectivity graphs are sparse in
// practice. The ServiceDependency provides a way to declare the service
// dependencies associated with each workload such that the amount of
// configuration sent to the sidecars can be scoped to the requisite
// dependencies.
//
// Services and configuration in a mesh are organized into one or more
// namespaces (e.g., a Kubernetes namespace or a CF org/space).  Workloads
// in a namespace have an implicit dependency on other workloads in the
// same namespace. In addition, to declare dependencies on workloads in
// other namespaces, a ServiceDependency resource has to be specified in the
// current namespace. *_Each namespace MUST have only one ServiceDependency
// resource named "default"_*. The behavior of the system is undefined if
// more than one ServiceDependency resource exists in a given namespace. The set
// of dependencies specified in a ServiceDependency resource will be used to
// compute the sidecar configuration for every workload in the namespace.
//
// NOTE 1: If workloads in the mesh depend only on other workloads in the
// same namespace, set defaultServiceDependency.importMode to SAME_NAMESPACE
// in the mesh global config map (in values.yaml).
//
// NOTE 2: To facilitate incremental pruning of the the sidecar
// configuration, the default import mode for the mesh is set to
// ALL_NAMESPACES. In other words, every workload will be able to reach
// every other workload. Adding a ServiceDependency resource in a namespace will
// automatically prune the configuration for the workloads in that
// namespace.
//
// The following examples illustrate a few specific use cases of ServiceDependency.
//
// The example below delcares a ServiceDependency resource in the prod-us1
// namespace that specifies that workloads in the namespace will be able to
// reach the services in the prod-apis namespace only.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceDependency
// metadata:
//   name: default
//   namespace: prod-us1
// spec:
//   dependencies:
//   - imports:
//     - namespace: prod-apis
// ```
//
// In a mesh where the default service dependency is set to SAME_NAMESPACE
// only, if one or more workloads need to be able to reach every other
// service in the mesh (e.g., metrics collection server), the following
// ServiceDependency resource can be used to specify such a dependency:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: ServiceDependency
// metadata:
//   name: default
//   namespace: metrics-collection
// spec:
//   dependencies:
//   - imports:
//     - namespace: '*'
// ```
//
// The configuration above will allow workloads in the metrics-collection
// namespace to access service in any namespace while workloads in other
// namespaces will be configured for namespace local access as per the
// global default service dependency (SAME_NAMESPACE).
//
type ServiceDependency struct {
	// REQUIRED. The set of services that workloads in this namespace are
	// expected to talk to, in addition to other workloads in the same
	// namespace. Dependencies describe the properties of outbound traffic from
	// a given workload.
	Dependencies []*ServiceDependency_Dependency `protobuf:"bytes,1,rep,name=dependencies" json:"dependencies,omitempty"`
}

func (m *ServiceDependency) Reset()         { *m = ServiceDependency{} }
func (m *ServiceDependency) String() string { return proto.CompactTextString(m) }
func (*ServiceDependency) ProtoMessage()    {}
func (*ServiceDependency) Descriptor() ([]byte, []int) {
	return fileDescriptorServiceDependency, []int{0}
}

func (m *ServiceDependency) GetDependencies() []*ServiceDependency_Dependency {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

// Import describes the set of namespaces whose exported services
// (real/virtual) will be accessed by workloads in a given namespace. The
// sidecars attached to the workloads will be configured with information
// required to reach the imported services only. The gateways in the
// current namespace will only honor imported VirtualServices instead of
// every VirtualService that binds itself to the gateway.
//
// Importing a service from a namespace will automatically import the
// exported configuration artifacts associated with the service, such as
// VirtualService, DestinationRule, etc. The service in a namespace can be
// a service in the service registry (e.g., a kubernetes or cloud foundry
// service) or a service specified via ServiceEntry configuration.
//
// NOTE: Only exported services and configuration artifacts from a
// namespace can be imported. Private services/configuration will not be
// imported. See the scope setting associated with VirtualService,
// DestinationRule, ServiceEntry, etc.
type ServiceDependency_Import struct {
	// The configuration namespace whose services need to be imported.
	// Specify * to import all namespaces. The import can be scoped further
	// by specifying individual hosts.
	Namespace string `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// A FQDN or wildcard prefixed DNS name of the host to import from the
	// specified namespace. The hostnames include names of services from the
	// service registry as well as those specified in a VirtualService.
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
}

func (m *ServiceDependency_Import) Reset()         { *m = ServiceDependency_Import{} }
func (m *ServiceDependency_Import) String() string { return proto.CompactTextString(m) }
func (*ServiceDependency_Import) ProtoMessage()    {}
func (*ServiceDependency_Import) Descriptor() ([]byte, []int) {
	return fileDescriptorServiceDependency, []int{0, 0}
}

func (m *ServiceDependency_Import) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ServiceDependency_Import) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

// Dependency describes a workload and the set of service dependencies
// for the workload.
type ServiceDependency_Dependency struct {
	// [#not-implemented-hide:]
	// One or more labels that indicate a specific set of pods/VMs on which
	// this dependency configuration should be applied.  The scope of label
	// search is platform dependent.  On Kubernetes, for example, the scope
	// includes pods running in the namespace in which the ServiceDependency
	// resource is present.  If the sourceWorkloadLabels are omitted, the
	// imports specified will be applicable to all workloads in the current
	// configuration namespace.
	// NOTE: source_workload_labels are currently not supported.
	SourceWorkloadLabels map[string]string `protobuf:"bytes,1,rep,name=source_workload_labels,json=sourceWorkloadLabels" json:"source_workload_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// REQUIRED: Import describes the set of namespaces whose exported
	// services will be accessed by the workloads selected by the
	// sourceWorkloadLabels. The sidecars attached to the workloads will be
	// configured with information required to reach other services in the
	// same namespace and the imported services. In addition to the
	// explicitly specified namespaces, namespaces specified in the global
	// mesh config (through defaultServiceDependency.importNamespaces) will also be
	// imported.
	Imports []*ServiceDependency_Import `protobuf:"bytes,2,rep,name=imports" json:"imports,omitempty"`
}

func (m *ServiceDependency_Dependency) Reset()         { *m = ServiceDependency_Dependency{} }
func (m *ServiceDependency_Dependency) String() string { return proto.CompactTextString(m) }
func (*ServiceDependency_Dependency) ProtoMessage()    {}
func (*ServiceDependency_Dependency) Descriptor() ([]byte, []int) {
	return fileDescriptorServiceDependency, []int{0, 1}
}

func (m *ServiceDependency_Dependency) GetSourceWorkloadLabels() map[string]string {
	if m != nil {
		return m.SourceWorkloadLabels
	}
	return nil
}

func (m *ServiceDependency_Dependency) GetImports() []*ServiceDependency_Import {
	if m != nil {
		return m.Imports
	}
	return nil
}

func init() {
	proto.RegisterType((*ServiceDependency)(nil), "istio.networking.v1alpha3.ServiceDependency")
	proto.RegisterType((*ServiceDependency_Import)(nil), "istio.networking.v1alpha3.ServiceDependency.Import")
	proto.RegisterType((*ServiceDependency_Dependency)(nil), "istio.networking.v1alpha3.ServiceDependency.Dependency")
	proto.RegisterEnum("istio.networking.v1alpha3.ConfigScope", ConfigScope_name, ConfigScope_value)
}
func (m *ServiceDependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDependency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for _, msg := range m.Dependencies {
			dAtA[i] = 0xa
			i++
			i = encodeVarintServiceDependency(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ServiceDependency_Import) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDependency_Import) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Namespace) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintServiceDependency(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.Host) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintServiceDependency(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	return i, nil
}

func (m *ServiceDependency_Dependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceDependency_Dependency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceWorkloadLabels) > 0 {
		for k, _ := range m.SourceWorkloadLabels {
			dAtA[i] = 0xa
			i++
			v := m.SourceWorkloadLabels[k]
			mapSize := 1 + len(k) + sovServiceDependency(uint64(len(k))) + 1 + len(v) + sovServiceDependency(uint64(len(v)))
			i = encodeVarintServiceDependency(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintServiceDependency(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintServiceDependency(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Imports) > 0 {
		for _, msg := range m.Imports {
			dAtA[i] = 0x12
			i++
			i = encodeVarintServiceDependency(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintServiceDependency(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ServiceDependency) Size() (n int) {
	var l int
	_ = l
	if len(m.Dependencies) > 0 {
		for _, e := range m.Dependencies {
			l = e.Size()
			n += 1 + l + sovServiceDependency(uint64(l))
		}
	}
	return n
}

func (m *ServiceDependency_Import) Size() (n int) {
	var l int
	_ = l
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovServiceDependency(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovServiceDependency(uint64(l))
	}
	return n
}

func (m *ServiceDependency_Dependency) Size() (n int) {
	var l int
	_ = l
	if len(m.SourceWorkloadLabels) > 0 {
		for k, v := range m.SourceWorkloadLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovServiceDependency(uint64(len(k))) + 1 + len(v) + sovServiceDependency(uint64(len(v)))
			n += mapEntrySize + 1 + sovServiceDependency(uint64(mapEntrySize))
		}
	}
	if len(m.Imports) > 0 {
		for _, e := range m.Imports {
			l = e.Size()
			n += 1 + l + sovServiceDependency(uint64(l))
		}
	}
	return n
}

func sovServiceDependency(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozServiceDependency(x uint64) (n int) {
	return sovServiceDependency(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceDependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDependency
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceDependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceDependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dependencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDependency
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dependencies = append(m.Dependencies, &ServiceDependency_Dependency{})
			if err := m.Dependencies[len(m.Dependencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDependency(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDependency
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDependency_Import) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDependency
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Import: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Import: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDependency
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServiceDependency
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDependency(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDependency
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceDependency_Dependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServiceDependency
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceWorkloadLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDependency
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceWorkloadLabels == nil {
				m.SourceWorkloadLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowServiceDependency
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDependency
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthServiceDependency
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowServiceDependency
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthServiceDependency
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipServiceDependency(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthServiceDependency
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.SourceWorkloadLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServiceDependency
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imports = append(m.Imports, &ServiceDependency_Import{})
			if err := m.Imports[len(m.Imports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServiceDependency(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServiceDependency
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServiceDependency(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServiceDependency
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServiceDependency
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthServiceDependency
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServiceDependency
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServiceDependency(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServiceDependency = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServiceDependency   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("networking/v1alpha3/service_dependency.proto", fileDescriptorServiceDependency)
}

var fileDescriptorServiceDependency = []byte{
	// 357 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xd2, 0xc9, 0x4b, 0x2d, 0x29,
	0xcf, 0x2f, 0xca, 0xce, 0xcc, 0x4b, 0xd7, 0x2f, 0x33, 0x4c, 0xcc, 0x29, 0xc8, 0x48, 0x34, 0xd6,
	0x2f, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0x8d, 0x4f, 0x49, 0x2d, 0x48, 0xcd, 0x4b, 0x49, 0xcd,
	0x4b, 0xae, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x92, 0xcc, 0x2c, 0x2e, 0xc9, 0xcc, 0xd7,
	0x43, 0xe8, 0xd1, 0x83, 0xe9, 0x51, 0xba, 0xcb, 0xcc, 0x25, 0x18, 0x0c, 0xd1, 0xe7, 0x02, 0xd7,
	0x26, 0x14, 0xcd, 0xc5, 0x03, 0x37, 0x24, 0x33, 0xb5, 0x58, 0x82, 0x51, 0x81, 0x59, 0x83, 0xdb,
	0xc8, 0x5c, 0x0f, 0xa7, 0x39, 0x7a, 0x18, 0x66, 0xe8, 0x21, 0x98, 0x41, 0x28, 0x86, 0x49, 0x59,
	0x71, 0xb1, 0x79, 0xe6, 0x16, 0xe4, 0x17, 0x95, 0x08, 0xc9, 0x70, 0x71, 0xe6, 0x25, 0xe6, 0xa6,
	0x16, 0x17, 0x24, 0x26, 0xa7, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0x70, 0x06, 0x21, 0x04, 0x84, 0x84,
	0xb8, 0x58, 0x32, 0xf2, 0x8b, 0x4b, 0x24, 0x98, 0xc0, 0x12, 0x60, 0xb6, 0xd4, 0x3a, 0x26, 0x2e,
	0x2e, 0x24, 0x77, 0xb6, 0x33, 0x72, 0x89, 0x15, 0xe7, 0x97, 0x16, 0x25, 0xa7, 0xc6, 0x83, 0x5c,
	0x94, 0x93, 0x9f, 0x98, 0x12, 0x9f, 0x93, 0x98, 0x94, 0x9a, 0x03, 0x73, 0x72, 0x20, 0x99, 0x4e,
	0xd6, 0x0b, 0x06, 0x9b, 0x1a, 0x0e, 0x35, 0xd4, 0x07, 0x6c, 0xa6, 0x6b, 0x5e, 0x49, 0x51, 0x65,
	0x90, 0x48, 0x31, 0x16, 0x29, 0x21, 0x5f, 0x2e, 0xf6, 0x4c, 0xb0, 0xa7, 0x8a, 0x25, 0x98, 0xc0,
	0x36, 0x1b, 0x93, 0x64, 0x33, 0x24, 0x40, 0x82, 0x60, 0x66, 0x48, 0xb9, 0x73, 0x49, 0xe2, 0x74,
	0x81, 0x90, 0x00, 0x17, 0x73, 0x76, 0x6a, 0x25, 0x34, 0xc0, 0x40, 0x4c, 0x21, 0x11, 0x2e, 0xd6,
	0xb2, 0xc4, 0x9c, 0xd2, 0x54, 0x68, 0x58, 0x41, 0x38, 0x56, 0x4c, 0x16, 0x8c, 0x5a, 0x6a, 0x5c,
	0xdc, 0xce, 0xf9, 0x79, 0x69, 0x99, 0xe9, 0xc1, 0xc9, 0xf9, 0x05, 0xa9, 0x42, 0x5c, 0x5c, 0x6c,
	0x01, 0xa1, 0x4e, 0x3e, 0x9e, 0xce, 0x02, 0x0c, 0x42, 0xdc, 0x5c, 0xec, 0x01, 0x41, 0x9e, 0x61,
	0x8e, 0x21, 0xae, 0x02, 0x8c, 0x4e, 0x7a, 0x27, 0x1e, 0xc9, 0x31, 0x5e, 0x78, 0x24, 0xc7, 0xf8,
	0xe0, 0x91, 0x1c, 0x63, 0x94, 0x02, 0xc4, 0xed, 0x99, 0xf9, 0xfa, 0x89, 0x05, 0x99, 0xfa, 0x58,
	0xd2, 0x5a, 0x12, 0x1b, 0x38, 0x65, 0x19, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0x1e, 0x25, 0xbe,
	0xb4, 0x89, 0x02, 0x00, 0x00,
}
