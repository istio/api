{
  "openapi": "3.0.1",
  "info": {
    "title": "Configuration affecting load balancing, outlier detection, etc.",
    "version": "v1alpha3"
  },
  "components": {
    "schemas": {
      "istio.networking.v1alpha3.ConnectionPoolSettings": {
        "description": "Connection pool settings for an upstream host. The settings apply to each individual host in the upstream service. See Envoy's [circuit breaker](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking) for more details. Connection pool settings can be applied at the TCP level as well as at HTTP level.",
        "properties": {
          "http": {
            "description": "HTTP connection pool settings.",
            "properties": {
              "h2_upgrade_policy": {
                "description": "Specify if http1.1 connection should be upgraded to http2 for the associated destination.",
                "enum": [
                  [
                    "DEFAULT",
                    "DO_NOT_UPGRADE",
                    "UPGRADE"
                  ]
                ],
                "type": "string"
              },
              "http1_max_pending_requests": {
                "description": "Maximum number of pending HTTP requests to a destination. Default 1024.",
                "format": "int32",
                "type": "integer"
              },
              "http2_max_requests": {
                "description": "Maximum number of requests to a backend. Default 1024.",
                "format": "int32",
                "type": "integer"
              },
              "idle_timeout": {
                "description": "The idle timeout for upstream connection pool connections. The idle timeout is defined as the period in which there are no active requests. If not set, there is no idle timeout. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.",
                "properties": {
                  "nanos": {
                    "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                    "format": "int32",
                    "type": "integer"
                  },
                  "seconds": {
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                    "format": "int64",
                    "type": "integer"
                  }
                },
                "type": "object"
              },
              "max_requests_per_connection": {
                "description": "Maximum number of requests per connection to a backend. Setting this parameter to 1 disables keep alive. Default 0, meaning \"unlimited\", up to 2^29.",
                "format": "int32",
                "type": "integer"
              },
              "max_retries": {
                "description": "Maximum number of retries that can be outstanding to all hosts in a cluster at a given time. Defaults to 1024.",
                "format": "int32",
                "type": "integer"
              }
            },
            "type": "object"
          },
          "tcp": {
            "description": "Settings common to both HTTP and TCP upstream connections.",
            "properties": {
              "connect_timeout": {
                "description": "TCP connection timeout.",
                "properties": {
                  "nanos": {
                    "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                    "format": "int32",
                    "type": "integer"
                  },
                  "seconds": {
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                    "format": "int64",
                    "type": "integer"
                  }
                },
                "type": "object"
              },
              "max_connections": {
                "description": "Maximum number of HTTP1 /TCP connections to a destination host. Default 1024.",
                "format": "int32",
                "type": "integer"
              },
              "tcp_keepalive": {
                "description": "If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.",
                "properties": {
                  "interval": {
                    "description": "The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)",
                    "properties": {
                      "nanos": {
                        "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                        "format": "int32",
                        "type": "integer"
                      },
                      "seconds": {
                        "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                        "format": "int64",
                        "type": "integer"
                      }
                    },
                    "type": "object"
                  },
                  "probes": {
                    "description": "Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)",
                    "format": "int32",
                    "type": "integer"
                  },
                  "time": {
                    "description": "The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)",
                    "properties": {
                      "nanos": {
                        "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                        "format": "int32",
                        "type": "integer"
                      },
                      "seconds": {
                        "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                        "format": "int64",
                        "type": "integer"
                      }
                    },
                    "type": "object"
                  }
                },
                "type": "object"
              }
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.DestinationRule": {
        "properties": {
          "export_to": {
            "description": "A list of namespaces to which this destination rule is exported. The resolution of a destination rule to apply to a service occurs in the context of a hierarchy of namespaces. Exporting a destination rule allows it to be included in the resolution hierarchy for services in other namespaces. This feature provides a mechanism for service owners and mesh administrators to control the visibility of destination rules across namespace boundaries.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "host": {
            "description": "REQUIRED. The name of a service from the service registry. Service names are looked up from the platform's service registry (e.g., Kubernetes services, Consul services, etc.) and from the hosts declared by [ServiceEntries](https://istio.io/docs/reference/config/networking/v1alpha3/service-entry/#ServiceEntry). Rules defined for services that do not exist in the service registry will be ignored.",
            "type": "string"
          },
          "subsets": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.Subset"
          },
          "traffic_policy": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TrafficPolicy"
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.LoadBalancerSettings": {
        "description": "Load balancing policies to apply for a specific destination. See Envoy's load balancing [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing) for more details.",
        "properties": {
          "lb_policy": {
            "oneOf": [
              {
                "enum": [
                  [
                    "ROUND_ROBIN",
                    "LEAST_CONN",
                    "RANDOM",
                    "PASSTHROUGH"
                  ]
                ],
                "type": "string"
              },
              {
                "properties": {
                  "hash_key": {
                    "oneOf": [
                      {
                        "description": "Hash based on a specific HTTP header.",
                        "type": "string"
                      },
                      {
                        "description": "Hash based on HTTP cookie.",
                        "properties": {
                          "name": {
                            "description": "REQUIRED. Name of the cookie.",
                            "type": "string"
                          },
                          "path": {
                            "description": "Path to set for the cookie.",
                            "type": "string"
                          },
                          "ttl": {
                            "description": "REQUIRED. Lifetime of the cookie.",
                            "properties": {
                              "nanos": {
                                "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                                "format": "int32",
                                "type": "integer"
                              },
                              "seconds": {
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                                "format": "int64",
                                "type": "integer"
                              }
                            },
                            "type": "object"
                          }
                        },
                        "type": "object"
                      },
                      {
                        "description": "Hash based on the source IP address.",
                        "type": "boolean"
                      }
                    ]
                  },
                  "minimum_ring_size": {
                    "description": "The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.",
                    "format": "int64",
                    "type": "integer"
                  }
                },
                "type": "object"
              }
            ]
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.OutlierDetection": {
        "description": "A Circuit breaker implementation that tracks the status of each individual host in the upstream service. Applicable to both HTTP and TCP services. For HTTP services, hosts that continually return 5xx errors for API calls are ejected from the pool for a pre-defined period of time. For TCP services, connection timeouts or connection failures to a given host counts as an error when measuring the consecutive errors metric. See Envoy's [outlier detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier) for more details.",
        "properties": {
          "base_ejection_time": {
            "description": "Minimum ejection duration. A host will remain ejected for a period equal to the product of minimum ejection duration and the number of times the host has been ejected. This technique allows the system to automatically increase the ejection period for unhealthy upstream servers. format: 1h/1m/1s/1ms. MUST BE \u003e=1ms. Default is 30s.",
            "properties": {
              "nanos": {
                "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                "format": "int32",
                "type": "integer"
              },
              "seconds": {
                "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                "format": "int64",
                "type": "integer"
              }
            },
            "type": "object"
          },
          "consecutive_errors": {
            "description": "Number of errors before a host is ejected from the connection pool. Defaults to 5. When the upstream host is accessed over HTTP, a 502, 503 or 504 return code qualifies as an error. When the upstream host is accessed over an opaque TCP connection, connect timeouts and connection error/failure events qualify as an error.",
            "format": "int32",
            "type": "integer"
          },
          "interval": {
            "description": "Time interval between ejection sweep analysis. format: 1h/1m/1s/1ms. MUST BE \u003e=1ms. Default is 10s.",
            "properties": {
              "nanos": {
                "description": "Signed fractions of a second at nanosecond resolution of the span of time. Durations less than one second are represented with a 0 `seconds` field and a positive or negative `nanos` field. For durations of one second or more, a non-zero value for the `nanos` field must be of the same sign as the `seconds` field. Must be from -999,999,999 to +999,999,999 inclusive.",
                "format": "int32",
                "type": "integer"
              },
              "seconds": {
                "description": "Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years",
                "format": "int64",
                "type": "integer"
              }
            },
            "type": "object"
          },
          "max_ejection_percent": {
            "description": "Maximum % of hosts in the load balancing pool for the upstream service that can be ejected. Defaults to 10%.",
            "format": "int32",
            "type": "integer"
          },
          "min_health_percent": {
            "description": "Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode. When the percentage of healthy hosts in the load balancing pool drops below this threshold, outlier detection will be disabled and the proxy will load balance across all hosts in the pool (healthy and unhealthy). The default is 50%.",
            "format": "int32",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.Subset": {
        "description": "A subset of endpoints of a service. Subsets can be used for scenarios like A/B testing, or routing to a specific version of a service. Refer to [VirtualService](https://istio.io/docs/reference/config/networking/v1alpha3/virtual-service/#VirtualService) documentation for examples of using subsets in these scenarios. In addition, traffic policies defined at the service-level can be overridden at a subset-level. The following rule uses a round robin load balancing policy for all traffic going to a subset named testversion that is composed of endpoints (e.g., pods) with labels (version:v3).",
        "properties": {
          "labels": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Labels apply a filter over the endpoints of a service in the service registry. See route rules for examples of usage.",
            "type": "object"
          },
          "name": {
            "description": "REQUIRED. Name of the subset. The service name and the subset name can be used for traffic splitting in a route rule.",
            "type": "string"
          },
          "traffic_policy": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TrafficPolicy"
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.TLSSettings": {
        "description": "SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/auth/cert.proto.html) for more details. These settings are common to both HTTP and TCP upstreams.",
        "properties": {
          "ca_certificates": {
            "description": "OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "client_certificate": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "mode": {
            "description": "REQUIRED: Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.",
            "enum": [
              [
                "DISABLE",
                "SIMPLE",
                "MUTUAL",
                "ISTIO_MUTUAL"
              ]
            ],
            "type": "string"
          },
          "private_key": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "sni": {
            "description": "SNI string to present to the server during TLS handshake.",
            "type": "string"
          },
          "subject_alt_names": {
            "description": "A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "istio.networking.v1alpha3.TrafficPolicy": {
        "description": "Traffic policies to apply for a specific destination, across all destination ports. See DestinationRule for examples.",
        "properties": {
          "connection_pool": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings"
          },
          "load_balancer": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings"
          },
          "outlier_detection": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.OutlierDetection"
          },
          "port_level_settings": {
            "description": "Traffic policies specific to individual ports. Note that port level settings will override the destination-level settings. Traffic settings specified at the destination-level will not be inherited when overridden by port-level settings, i.e. default values will be applied to fields omitted in port-level traffic policies.",
            "items": {
              "description": "Traffic policies that apply to specific ports of the service",
              "properties": {
                "connection_pool": {
                  "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings"
                },
                "load_balancer": {
                  "$ref": "#/components/schemas/istio.networking.v1alpha3.LoadBalancerSettings"
                },
                "outlier_detection": {
                  "$ref": "#/components/schemas/istio.networking.v1alpha3.OutlierDetection"
                },
                "port": {
                  "description": "Specifies the port name or number of a port on the destination service on which this policy is being applied.",
                  "properties": {
                    "port": {
                      "oneOf": [
                        {
                          "description": "Valid port number",
                          "format": "int32",
                          "type": "integer"
                        },
                        {
                          "type": "string"
                        }
                      ]
                    }
                  },
                  "type": "object"
                },
                "tls": {
                  "$ref": "#/components/schemas/istio.networking.v1alpha3.TLSSettings"
                }
              },
              "type": "object"
            },
            "type": "array"
          },
          "tls": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.TLSSettings"
          }
        },
        "type": "object"
      }
    }
  }
}