// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/filter_augment.proto

package v1alpha3

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf2 "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ListenerType describes the type of listener to insert the filter
// into.
type FilterAugment_Match_ListenerType int32

const (
	// The listener is an HTTP listener.  Note that HTTP filters can
	// only be inserted into HTTP listeners.
	FilterAugment_Match_HTTP FilterAugment_Match_ListenerType = 0
	// The listener is a TCP listener. Network filters can be inserted
	// into either HTTP or TCP listeners.
	FilterAugment_Match_TCP FilterAugment_Match_ListenerType = 1
)

var FilterAugment_Match_ListenerType_name = map[int32]string{
	0: "HTTP",
	1: "TCP",
}
var FilterAugment_Match_ListenerType_value = map[string]int32{
	"HTTP": 0,
	"TCP":  1,
}

func (x FilterAugment_Match_ListenerType) String() string {
	return proto.EnumName(FilterAugment_Match_ListenerType_name, int32(x))
}
func (FilterAugment_Match_ListenerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFilterAugment, []int{0, 0, 0}
}

// The Direction is which way traffic flows through the listener. This
// only applies to sidecar proxies.
type FilterAugment_Match_Direction int32

const (
	// The upstream service instance is local, and the downstream client
	// is remote.
	FilterAugment_Match_INBOUND FilterAugment_Match_Direction = 0
	// The upstream service instance is remote, and the downstream
	// client is local.
	FilterAugment_Match_OUTBOUND FilterAugment_Match_Direction = 1
)

var FilterAugment_Match_Direction_name = map[int32]string{
	0: "INBOUND",
	1: "OUTBOUND",
}
var FilterAugment_Match_Direction_value = map[string]int32{
	"INBOUND":  0,
	"OUTBOUND": 1,
}

func (x FilterAugment_Match_Direction) String() string {
	return proto.EnumName(FilterAugment_Match_Direction_name, int32(x))
}
func (FilterAugment_Match_Direction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFilterAugment, []int{0, 0, 1}
}

// The position of the filter relative to another or the entire chain.
type FilterAugment_Order_Position int32

const (
	// The filter should be first in the resulting chain.
	FilterAugment_Order_FIRST FilterAugment_Order_Position = 0
	// The filter should be last in the resulting chain.
	FilterAugment_Order_LAST FilterAugment_Order_Position = 1
	// The filter should be immediately before the filter named in the
	// `relative_to` field. If the relative filter is not present, the
	// inserted filter will be last.
	FilterAugment_Order_BEFORE FilterAugment_Order_Position = 2
	// The filter should be immediately after the filter named in the
	// `relative_to` field. If the relative filter is not present, the
	// inserted filter will be last.
	FilterAugment_Order_AFTER FilterAugment_Order_Position = 3
)

var FilterAugment_Order_Position_name = map[int32]string{
	0: "FIRST",
	1: "LAST",
	2: "BEFORE",
	3: "AFTER",
}
var FilterAugment_Order_Position_value = map[string]int32{
	"FIRST":  0,
	"LAST":   1,
	"BEFORE": 2,
	"AFTER":  3,
}

func (x FilterAugment_Order_Position) String() string {
	return proto.EnumName(FilterAugment_Order_Position_name, int32(x))
}
func (FilterAugment_Order_Position) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorFilterAugment, []int{0, 1, 0}
}

//
// # Overview
//
// A `FilterAugment` describes a filter to insert into the processing chain for
// mesh traffic. It includes a `match` that selects which listeners to insert
// the filter into, an `order` that specifies where in the filter chain to
// insert it, and the filter configuration itself.
//
// A given listener may match multiple `FilterAugment` objects, in which case
// each filter is inserted, including perhaps inserting the same kind of filter
// multiple times, with different or identical configuration. If multiple
// filters use the same `Order`, the actual resultant ordering will be undefined
// and may not be stable over the life of the listener. Users are strongly
// encouraged to use `BEFORE` and `AFTER` order directives in cases where
// filter ordering is desired.
//
// The following example configures a Lua filter that authorizes an inbound
// request by calling an external service.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: FilterAugment
//     metadata:
//       name: reviews-route
//     spec:
//       matches:
//       - hosts: [reviews.prod.svc.cluster.local]
//         directions: [INBOUND]
//       order:
//         position: BEFORE
//         relativeTo: router
//       httpFilter:
//         name: envoy.lua
//         config: |
//          function envoy_on_request(request_handle)
//            -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
//            local headers, body = request_handle:httpCall(
//                                   "outbound||https|internal-auth-server.com",
//                                   {
//                                     [":method"] = "POST",
//                                     [":path"] = "/authorizeMeNow",
//                                     [":authority"] = "internal-auth-server.com"
//                                    },
//                                   "username=scoobydoo", 5000)
//             -- Add information from the HTTP call into the headers that are about to be sent to the next
//             -- filter in the filter chain.
//             request_handle:headers():add("upstream_foo", headers["foo"])
//             request_handle:headers():add("upstream_body_size", #body)
//          end
//
// and the associated ServiceEntry configuration to add
// internal-auth-server.com to the service registry:
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: ServiceEntry
//     metadata:
//       name: external-svc
//     spec:
//       hosts:
//       - internal-auth-server.com
//       ports:
//       - number: 443
//         name: http
//         protocol: HTTP # not HTTPS.
//       discovery: DNS
//
// and a DestinationRule to initiate TLS connections to the external service.
//
//     apiVersion: networking.istio.io/v1alpha3
//     kind: DestinationRule
//     metadata:
//       name: tls-example
//     spec:
//       name: internal-auth-server.com
//       trafficPolicy:
//         tls:
//           mode: SIMPLE # initiates HTTPS when talking to internal-auth-server.com
//
//
type FilterAugment struct {
	// Match criteria for the filter to be inserted. When more than one Match is
	// included, a listener may match any for the filter to be inserted.
	Matches []*FilterAugment_Match `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	// Where in the filter chain to insert the filter. If omitted the filter
	// will be first in the resulting chain.
	Order *FilterAugment_Order `protobuf:"bytes,2,opt,name=order" json:"order,omitempty"`
	// Types that are valid to be assigned to Filter:
	//	*FilterAugment_HttpFilter
	//	*FilterAugment_NetworkFilter
	Filter isFilterAugment_Filter `protobuf_oneof:"filter"`
}

func (m *FilterAugment) Reset()                    { *m = FilterAugment{} }
func (m *FilterAugment) String() string            { return proto.CompactTextString(m) }
func (*FilterAugment) ProtoMessage()               {}
func (*FilterAugment) Descriptor() ([]byte, []int) { return fileDescriptorFilterAugment, []int{0} }

type isFilterAugment_Filter interface {
	isFilterAugment_Filter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FilterAugment_HttpFilter struct {
	HttpFilter *HTTPFilter `protobuf:"bytes,3,opt,name=http_filter,json=httpFilter,oneof"`
}
type FilterAugment_NetworkFilter struct {
	NetworkFilter *NetworkFilter `protobuf:"bytes,4,opt,name=network_filter,json=networkFilter,oneof"`
}

func (*FilterAugment_HttpFilter) isFilterAugment_Filter()    {}
func (*FilterAugment_NetworkFilter) isFilterAugment_Filter() {}

func (m *FilterAugment) GetFilter() isFilterAugment_Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *FilterAugment) GetMatches() []*FilterAugment_Match {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *FilterAugment) GetOrder() *FilterAugment_Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *FilterAugment) GetHttpFilter() *HTTPFilter {
	if x, ok := m.GetFilter().(*FilterAugment_HttpFilter); ok {
		return x.HttpFilter
	}
	return nil
}

func (m *FilterAugment) GetNetworkFilter() *NetworkFilter {
	if x, ok := m.GetFilter().(*FilterAugment_NetworkFilter); ok {
		return x.NetworkFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FilterAugment) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FilterAugment_OneofMarshaler, _FilterAugment_OneofUnmarshaler, _FilterAugment_OneofSizer, []interface{}{
		(*FilterAugment_HttpFilter)(nil),
		(*FilterAugment_NetworkFilter)(nil),
	}
}

func _FilterAugment_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FilterAugment)
	// filter
	switch x := m.Filter.(type) {
	case *FilterAugment_HttpFilter:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpFilter); err != nil {
			return err
		}
	case *FilterAugment_NetworkFilter:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NetworkFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FilterAugment.Filter has unexpected type %T", x)
	}
	return nil
}

func _FilterAugment_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FilterAugment)
	switch tag {
	case 3: // filter.http_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HTTPFilter)
		err := b.DecodeMessage(msg)
		m.Filter = &FilterAugment_HttpFilter{msg}
		return true, err
	case 4: // filter.network_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NetworkFilter)
		err := b.DecodeMessage(msg)
		m.Filter = &FilterAugment_NetworkFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FilterAugment_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FilterAugment)
	// filter
	switch x := m.Filter.(type) {
	case *FilterAugment_HttpFilter:
		s := proto.Size(x.HttpFilter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FilterAugment_NetworkFilter:
		s := proto.Size(x.NetworkFilter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Match describes conditions which a listener must meet in order for the
// filter to be inserted.  Within a single Match message, if more than one
// field is included, they all must match the listener. If a field is
// repeated, the listener can match any of the listed values. For example,
// a match
//
//     match:
//     - gateways: [my-gateway, mesh]
//       listenerTypes: [TCP]
//
// will TCP listeners on the gateway "my-gateway", and also TCP listeners on
// sidecars in the service mesh.
type FilterAugment_Match struct {
	// The destination hosts to which traffic is being sent. Could be a DNS
	// name with wildcard prefix or an IP address.  Depending on the
	// platform, short-names can also be used instead of a FQDN (i.e. has no
	// dots in the name). In such a scenario, the FQDN of the host would be
	// derived based on the underlying platform. If omitted it will match
	// any destination.
	//
	// *Note for Kubernetes users*: When short names are used (e.g. "reviews"
	// instead of "reviews.default.svc.cluster.local"), Istio will interpret
	// the short name based on the namespace of the rule, not the service. A
	// rule in the "default" namespace containing a host "reviews will be
	// interpreted as "reviews.default.svc.cluster.local", irrespective of
	// the actual namespace associated with the reviews service. _To avoid
	// potential misconfigurations, it is recommended to always use fully
	// qualified domain names over short names._
	//
	// The hosts field applies to both HTTP and TCP services. Service inside
	// the mesh, i.e., those found in the service registry, must always be
	// referred to using their alphanumeric names. IP addresses are allowed
	// only for services defined via the Gateway.
	Hosts []string `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	// The names of gateways and sidecars to match. The reserved word `mesh`
	// is used to imply all the sidecars in the mesh. When this field is
	// omitted, it will match all gateways and sidecars. If a list of
	// gateway names is provided, the rules will apply only to the gateways.
	// To apply the configuration to both gateways and sidecars, specify
	// `mesh` as one of the gateway names.
	Gateways []string `protobuf:"bytes,2,rep,name=gateways" json:"gateways,omitempty"`
	// The types of listener to match.
	ListenerTypes []FilterAugment_Match_ListenerType `protobuf:"varint,3,rep,packed,name=listener_types,json=listenerTypes,enum=istio.networking.v1alpha3.FilterAugment_Match_ListenerType" json:"listener_types,omitempty"`
	// The listener directions to match. Only applies to sidecar proxies.
	Directions []FilterAugment_Match_Direction `protobuf:"varint,4,rep,packed,name=directions,enum=istio.networking.v1alpha3.FilterAugment_Match_Direction" json:"directions,omitempty"`
}

func (m *FilterAugment_Match) Reset()         { *m = FilterAugment_Match{} }
func (m *FilterAugment_Match) String() string { return proto.CompactTextString(m) }
func (*FilterAugment_Match) ProtoMessage()    {}
func (*FilterAugment_Match) Descriptor() ([]byte, []int) {
	return fileDescriptorFilterAugment, []int{0, 0}
}

func (m *FilterAugment_Match) GetHosts() []string {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *FilterAugment_Match) GetGateways() []string {
	if m != nil {
		return m.Gateways
	}
	return nil
}

func (m *FilterAugment_Match) GetListenerTypes() []FilterAugment_Match_ListenerType {
	if m != nil {
		return m.ListenerTypes
	}
	return nil
}

func (m *FilterAugment_Match) GetDirections() []FilterAugment_Match_Direction {
	if m != nil {
		return m.Directions
	}
	return nil
}

// Order describes where in the filter chain to insert the filter.
type FilterAugment_Order struct {
	// Position of this filter relative to another or the entire chain.
	Position FilterAugment_Order_Position `protobuf:"varint,1,opt,name=position,proto3,enum=istio.networking.v1alpha3.FilterAugment_Order_Position" json:"position,omitempty"`
	// Name of the filter the postion is relative to, for `BEFORE` and
	// `AFTER` positions.  Ignored for `FIRST` or `LAST`.
	RelativeTo string `protobuf:"bytes,2,opt,name=relative_to,json=relativeTo,proto3" json:"relative_to,omitempty"`
}

func (m *FilterAugment_Order) Reset()         { *m = FilterAugment_Order{} }
func (m *FilterAugment_Order) String() string { return proto.CompactTextString(m) }
func (*FilterAugment_Order) ProtoMessage()    {}
func (*FilterAugment_Order) Descriptor() ([]byte, []int) {
	return fileDescriptorFilterAugment, []int{0, 1}
}

func (m *FilterAugment_Order) GetPosition() FilterAugment_Order_Position {
	if m != nil {
		return m.Position
	}
	return FilterAugment_Order_FIRST
}

func (m *FilterAugment_Order) GetRelativeTo() string {
	if m != nil {
		return m.RelativeTo
	}
	return ""
}

// An HTTPFilter operates on HTTP requests and responses.
type HTTPFilter struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf2.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
}

func (m *HTTPFilter) Reset()                    { *m = HTTPFilter{} }
func (m *HTTPFilter) String() string            { return proto.CompactTextString(m) }
func (*HTTPFilter) ProtoMessage()               {}
func (*HTTPFilter) Descriptor() ([]byte, []int) { return fileDescriptorFilterAugment, []int{1} }

func (m *HTTPFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPFilter) GetConfig() *google_protobuf2.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

// A NetworkFilter operates the the network layer and operates on connections
// and byte streams.
type NetworkFilter struct {
	// The name of the filter to instantiate. The name must match a supported
	// filter.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Filter specific configuration which depends on the filter being
	// instantiated. See the supported filters for further documentation.
	Config *google_protobuf2.Struct `protobuf:"bytes,2,opt,name=config" json:"config,omitempty"`
}

func (m *NetworkFilter) Reset()                    { *m = NetworkFilter{} }
func (m *NetworkFilter) String() string            { return proto.CompactTextString(m) }
func (*NetworkFilter) ProtoMessage()               {}
func (*NetworkFilter) Descriptor() ([]byte, []int) { return fileDescriptorFilterAugment, []int{2} }

func (m *NetworkFilter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NetworkFilter) GetConfig() *google_protobuf2.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*FilterAugment)(nil), "istio.networking.v1alpha3.FilterAugment")
	proto.RegisterType((*FilterAugment_Match)(nil), "istio.networking.v1alpha3.FilterAugment.Match")
	proto.RegisterType((*FilterAugment_Order)(nil), "istio.networking.v1alpha3.FilterAugment.Order")
	proto.RegisterType((*HTTPFilter)(nil), "istio.networking.v1alpha3.HTTPFilter")
	proto.RegisterType((*NetworkFilter)(nil), "istio.networking.v1alpha3.NetworkFilter")
	proto.RegisterEnum("istio.networking.v1alpha3.FilterAugment_Match_ListenerType", FilterAugment_Match_ListenerType_name, FilterAugment_Match_ListenerType_value)
	proto.RegisterEnum("istio.networking.v1alpha3.FilterAugment_Match_Direction", FilterAugment_Match_Direction_name, FilterAugment_Match_Direction_value)
	proto.RegisterEnum("istio.networking.v1alpha3.FilterAugment_Order_Position", FilterAugment_Order_Position_name, FilterAugment_Order_Position_value)
}
func (m *FilterAugment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterAugment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, msg := range m.Matches {
			dAtA[i] = 0xa
			i++
			i = encodeVarintFilterAugment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Order != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.Order.Size()))
		n1, err := m.Order.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Filter != nil {
		nn2, err := m.Filter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *FilterAugment_HttpFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.HttpFilter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.HttpFilter.Size()))
		n3, err := m.HttpFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *FilterAugment_NetworkFilter) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NetworkFilter != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.NetworkFilter.Size()))
		n4, err := m.NetworkFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *FilterAugment_Match) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterAugment_Match) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Gateways) > 0 {
		for _, s := range m.Gateways {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ListenerTypes) > 0 {
		dAtA6 := make([]byte, len(m.ListenerTypes)*10)
		var j5 int
		for _, num := range m.ListenerTypes {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.Directions) > 0 {
		dAtA8 := make([]byte, len(m.Directions)*10)
		var j7 int
		for _, num := range m.Directions {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *FilterAugment_Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FilterAugment_Order) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Position != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.Position))
	}
	if len(m.RelativeTo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(len(m.RelativeTo)))
		i += copy(dAtA[i:], m.RelativeTo)
	}
	return i, nil
}

func (m *HTTPFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.Config.Size()))
		n9, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *NetworkFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Config != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFilterAugment(dAtA, i, uint64(m.Config.Size()))
		n10, err := m.Config.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func encodeVarintFilterAugment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FilterAugment) Size() (n int) {
	var l int
	_ = l
	if len(m.Matches) > 0 {
		for _, e := range m.Matches {
			l = e.Size()
			n += 1 + l + sovFilterAugment(uint64(l))
		}
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	if m.Filter != nil {
		n += m.Filter.Size()
	}
	return n
}

func (m *FilterAugment_HttpFilter) Size() (n int) {
	var l int
	_ = l
	if m.HttpFilter != nil {
		l = m.HttpFilter.Size()
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	return n
}
func (m *FilterAugment_NetworkFilter) Size() (n int) {
	var l int
	_ = l
	if m.NetworkFilter != nil {
		l = m.NetworkFilter.Size()
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	return n
}
func (m *FilterAugment_Match) Size() (n int) {
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovFilterAugment(uint64(l))
		}
	}
	if len(m.Gateways) > 0 {
		for _, s := range m.Gateways {
			l = len(s)
			n += 1 + l + sovFilterAugment(uint64(l))
		}
	}
	if len(m.ListenerTypes) > 0 {
		l = 0
		for _, e := range m.ListenerTypes {
			l += sovFilterAugment(uint64(e))
		}
		n += 1 + sovFilterAugment(uint64(l)) + l
	}
	if len(m.Directions) > 0 {
		l = 0
		for _, e := range m.Directions {
			l += sovFilterAugment(uint64(e))
		}
		n += 1 + sovFilterAugment(uint64(l)) + l
	}
	return n
}

func (m *FilterAugment_Order) Size() (n int) {
	var l int
	_ = l
	if m.Position != 0 {
		n += 1 + sovFilterAugment(uint64(m.Position))
	}
	l = len(m.RelativeTo)
	if l > 0 {
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	return n
}

func (m *HTTPFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	return n
}

func (m *NetworkFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovFilterAugment(uint64(l))
	}
	return n
}

func sovFilterAugment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFilterAugment(x uint64) (n int) {
	return sovFilterAugment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FilterAugment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterAugment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterAugment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matches = append(m.Matches, &FilterAugment_Match{})
			if err := m.Matches[len(m.Matches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &FilterAugment_Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HTTPFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &FilterAugment_HttpFilter{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NetworkFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Filter = &FilterAugment_NetworkFilter{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilterAugment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilterAugment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterAugment_Match) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Match: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Match: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateways", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateways = append(m.Gateways, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v FilterAugment_Match_ListenerType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilterAugment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (FilterAugment_Match_ListenerType(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ListenerTypes = append(m.ListenerTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilterAugment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFilterAugment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v FilterAugment_Match_ListenerType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFilterAugment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (FilterAugment_Match_ListenerType(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ListenerTypes = append(m.ListenerTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerTypes", wireType)
			}
		case 4:
			if wireType == 0 {
				var v FilterAugment_Match_Direction
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilterAugment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (FilterAugment_Match_Direction(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Directions = append(m.Directions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFilterAugment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFilterAugment
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v FilterAugment_Match_Direction
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFilterAugment
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (FilterAugment_Match_Direction(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Directions = append(m.Directions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Directions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFilterAugment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilterAugment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilterAugment_Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (FilterAugment_Order_Position(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilterAugment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilterAugment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf2.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilterAugment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilterAugment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NetworkFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFilterAugment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &google_protobuf2.Struct{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFilterAugment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFilterAugment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFilterAugment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFilterAugment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFilterAugment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthFilterAugment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFilterAugment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFilterAugment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFilterAugment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFilterAugment   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("networking/v1alpha3/filter_augment.proto", fileDescriptorFilterAugment)
}

var fileDescriptorFilterAugment = []byte{
	// 546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0x51, 0x8b, 0xda, 0x40,
	0x10, 0x80, 0x8d, 0x51, 0x2f, 0x8e, 0xa7, 0x84, 0xa5, 0xd0, 0x54, 0xca, 0xd5, 0x06, 0x5a, 0x7c,
	0xda, 0xd0, 0x3b, 0x68, 0x0b, 0x7d, 0x3a, 0xab, 0xe2, 0xc1, 0x55, 0xbd, 0x35, 0x07, 0xa5, 0x2f,
	0x12, 0xbd, 0x35, 0x2e, 0x8d, 0xd9, 0x90, 0xac, 0x77, 0xf8, 0xc3, 0xfa, 0x07, 0xda, 0x97, 0x3e,
	0xf6, 0x27, 0x14, 0x7f, 0x49, 0xc9, 0x6e, 0xe2, 0x79, 0xd0, 0x1e, 0x08, 0x7d, 0x73, 0xc6, 0xf9,
	0xbe, 0x30, 0x93, 0x99, 0x40, 0x3b, 0xa4, 0xe2, 0x8e, 0xc7, 0x5f, 0x59, 0xe8, 0x3b, 0xb7, 0x6f,
	0xbc, 0x20, 0x5a, 0x7a, 0x67, 0xce, 0x82, 0x05, 0x82, 0xc6, 0x53, 0x6f, 0xed, 0xaf, 0x68, 0x28,
	0x70, 0x14, 0x73, 0xc1, 0xd1, 0x33, 0x96, 0x08, 0xc6, 0xf1, 0x7d, 0x3d, 0xce, 0xeb, 0x9b, 0xcf,
	0x7d, 0xce, 0xfd, 0x80, 0x3a, 0xb2, 0x70, 0xb6, 0x5e, 0x38, 0x89, 0x88, 0xd7, 0xf3, 0x0c, 0xb4,
	0x7f, 0x54, 0xa0, 0xde, 0x97, 0xc6, 0x73, 0x25, 0x44, 0x03, 0x38, 0x5a, 0x79, 0x62, 0xbe, 0xa4,
	0x89, 0xa5, 0xb5, 0xf4, 0x76, 0xed, 0x14, 0xe3, 0x7f, 0xca, 0xf1, 0x03, 0x14, 0x7f, 0x4a, 0x39,
	0x92, 0xe3, 0xa8, 0x0b, 0x65, 0x1e, 0xdf, 0xd0, 0xd8, 0x2a, 0xb6, 0xb4, 0x83, 0x3c, 0xa3, 0x94,
	0x22, 0x0a, 0x46, 0x03, 0xa8, 0x2d, 0x85, 0x88, 0xa6, 0xaa, 0x6f, 0x4b, 0x97, 0xae, 0x57, 0x8f,
	0xb8, 0x06, 0xae, 0x3b, 0x56, 0xbe, 0x41, 0x81, 0x40, 0xca, 0xaa, 0x08, 0x5d, 0x41, 0x23, 0xab,
	0xcf, 0x65, 0x25, 0x29, 0x6b, 0x3f, 0x22, 0x1b, 0xaa, 0xdc, 0xce, 0x57, 0x0f, 0xf7, 0x13, 0xcd,
	0xef, 0x45, 0x28, 0xcb, 0xae, 0xd1, 0x13, 0x28, 0x2f, 0x79, 0x22, 0xd4, 0xd0, 0xaa, 0x44, 0x05,
	0xa8, 0x09, 0x86, 0xef, 0x09, 0x7a, 0xe7, 0x6d, 0x12, 0xab, 0x28, 0xff, 0xd8, 0xc5, 0x68, 0x06,
	0x8d, 0x80, 0x25, 0x82, 0x86, 0x34, 0x9e, 0x8a, 0x4d, 0x44, 0x13, 0x4b, 0x6f, 0xe9, 0xed, 0xc6,
	0xe9, 0x87, 0xc3, 0xe6, 0x8d, 0x2f, 0x33, 0x89, 0xbb, 0x89, 0x28, 0xa9, 0x07, 0x7b, 0x51, 0x82,
	0x3e, 0x03, 0xdc, 0xb0, 0x98, 0xce, 0x05, 0xe3, 0x61, 0x62, 0x95, 0xa4, 0xff, 0xfd, 0x81, 0xfe,
	0x6e, 0x2e, 0x20, 0x7b, 0x2e, 0xfb, 0x25, 0x1c, 0xef, 0x3f, 0x18, 0x19, 0x50, 0x4a, 0x07, 0x6f,
	0x16, 0xd0, 0x11, 0xe8, 0xee, 0xc7, 0xb1, 0xa9, 0xd9, 0xaf, 0xa1, 0xba, 0x63, 0x51, 0x0d, 0x8e,
	0x2e, 0x86, 0x9d, 0xd1, 0xf5, 0xb0, 0x6b, 0x16, 0xd0, 0x31, 0x18, 0xa3, 0x6b, 0x57, 0x45, 0x5a,
	0xf3, 0x9b, 0x06, 0x65, 0xf9, 0xca, 0xd1, 0x04, 0x8c, 0x88, 0x27, 0x2c, 0x05, 0x2c, 0xad, 0xa5,
	0xb5, 0x1b, 0xa7, 0xef, 0x0e, 0x5b, 0x1a, 0x3c, 0xce, 0x70, 0xb2, 0x13, 0xa1, 0x17, 0x50, 0x8b,
	0x69, 0xe0, 0x09, 0x76, 0x4b, 0xa7, 0x82, 0xcb, 0x65, 0xac, 0x12, 0xc8, 0x53, 0x2e, 0xb7, 0xdf,
	0x82, 0x91, 0x63, 0xa8, 0x0a, 0xe5, 0xfe, 0x05, 0x99, 0xb8, 0x66, 0x21, 0xed, 0xe8, 0xf2, 0x7c,
	0xe2, 0x9a, 0x1a, 0x02, 0xa8, 0x74, 0x7a, 0xfd, 0x11, 0xe9, 0x99, 0xc5, 0xb4, 0xe0, 0xbc, 0xef,
	0xf6, 0x88, 0xa9, 0x77, 0x0c, 0xa8, 0xa8, 0x3d, 0xb2, 0xaf, 0x00, 0xee, 0xb7, 0x0e, 0x21, 0x28,
	0x85, 0xde, 0x8a, 0xca, 0x0e, 0xaa, 0x44, 0xfe, 0x46, 0x0e, 0x54, 0xe6, 0x3c, 0x5c, 0x30, 0x3f,
	0x3b, 0x86, 0xa7, 0x58, 0x9d, 0x25, 0xce, 0xcf, 0x12, 0x4f, 0xe4, 0x59, 0x92, 0xac, 0xcc, 0x76,
	0xa1, 0xfe, 0x60, 0xf7, 0xfe, 0x8b, 0xb5, 0x83, 0x7f, 0x6e, 0x4f, 0xb4, 0x5f, 0xdb, 0x13, 0xed,
	0xf7, 0xf6, 0x44, 0xfb, 0xd2, 0x52, 0xb3, 0x65, 0xdc, 0xf1, 0x22, 0xe6, 0xfc, 0xe5, 0x63, 0x33,
	0xab, 0x48, 0xd1, 0xd9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x9f, 0x2f, 0x4d, 0x8a, 0x04,
	0x00, 0x00,
}
