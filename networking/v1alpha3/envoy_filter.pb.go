// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: networking/v1alpha3/envoy_filter.proto

// `EnvoyFilter` provides a mechanism to customize the Envoy
// configuration generated by Istio Pilot. Use EnvoyFilter to modify
// values for certain fields, add specific filters, or even add
// entirely new listeners, clusters, etc. This feature must be used
// with care, as incorrect configurations could potentially
// destabilize the entire mesh. Unlike other Istio networking objects,
// EnvoyFilters are additively applied. Any number of EnvoyFilters can
// exist for a given workload in a specific namespace. The order of
// application of these EnvoyFilters is as follows: all EnvoyFilters
// in the config [root
// namespace](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig),
// followed by all matching EnvoyFilters in the workload's namespace.
//
// **NOTE 1**: Since this is break glass configuration, there will not
// be any backward compatibility across different Istio releases. In
// other words, this configuration is subject to change based on
// internal implementation of Istio networking subsystem.
//
// **NOTE 2**: The envoy configuration provided through this mechanism
// should be carefully monitored across Istio proxy version upgrades,
// to ensure that deprecated fields are removed and replaced
// appropriately.
//
// **NOTE 3**: When multiple EnvoyFilters are bound to the same
// workload in a given namespace, all patches will be processed
// sequentially in order of creation time.  The behavior is undefined
// if multiple EnvoyFilter configurations conflict with each other.
//
// **NOTE 4**: *_To apply an EnvoyFilter resource to all workloads
// (sidecars and gateways) in the system, define the resource in the
// config [root
// namespace](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig),
// without a workloadSelector.
//
// The example below declares a global default EnvoyFilter resource in
// the root namespace called `istio-config`, that adds a custom
// protocol filter on all sidecars in the system, for outbound port
// 9307. The filter should be added before the terminating tcp_proxy
// filter to take effect. In addition, it sets a 30s idle timeout for
// all HTTP connections in both gateays and sidecars.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: custom-protocol
//   namespace: istio-config # as defined in meshConfig resource.
// spec:
//   configPatches:
//   - applyTo: NETWORK_FILTER
//     match:
//       context: SIDECAR_OUTBOUND # will match outbound listeners in all sidecars
//       lds:
//         listener:
//           portNumber: 9307
//           filterChain:
//             filter:
//               name: "envoy.tcp_proxy"
//     patch:
//       operation: INSERT_BEFORE
//       value: |
//         name: "envoy.config.filter.network.custom_protocol"
//         config:
//          ...
//   - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
//     match:
//       # context omitted so that this applies to both sidecars and gateways
//       lds:
//         listener:
//           filterChain:
//             filter:
//               name: "envoy.http_connection_manager"
//     patch:
//       operation: MERGE
//       value: |
//         idle_timeout: 30s
//```
//
// The following example enables Envoy's Lua filter for all inbound
// HTTP calls arriving at service port 8080 of the reviews service pod
// with labels "app: reviews", in the bookinfo namespace. The lua
// filter calls out to an external service internal.org.net:8888 that
// requires a special cluster definition in envoy. The cluster is also
// added to the sidecar as part of this configuration.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
//   namespace: bookinfo
// spec:
//   workloadSelector:
//     app: reviews
//   configPatches:
//     # The first patch adds the lua filter to the listener/http connection manager
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//       listener:
//         portNumber: 8080
//         filterChain:
//           filter:
//             name: "envoy.http_connection_manager"
//             subFilter:
//               name: "envoy.router"
//     patch:
//       operation: INSERT_BEFORE
//       value: # lua filter specification
//        name: envoy.lua
//        config:
//          inlineCode: |
//            function envoy_on_request(request_handle)
//              -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
//              local headers, body = request_handle:httpCall(
//               "lua_cluster",
//               {
//                [":method"] = "POST",
//                [":path"] = "/acl",
//                [":authority"] = "internal.org.net"
//               },
//              "authorize call",
//              5000)
//            end
//   # The second patch adds the cluster that is referenced by the lua code
//   # cds match is omitted as a new cluster is being added
//   - applyTo: CLUSTER
//     match:
//       context: SIDECAR_OUTBOUND
//     patch:
//       operation: ADD
//       value: # cluster specification
//         name: "lua_cluster"
//         type: STRICT_DNS
//         connect_timeout: 0.5s
//         lb_policy: ROUND_ROBIN
//         hosts:
//         - socket_address:
//             protocol: TCP
//             address: "internal.org.net"
//             port_value: 8888
//
// ```
//
// The following example overwrites certain fields (HTTP idle timeout
// and X-Forward-For trusted hops) in the HTTP connection manager in a
// listener on the ingress gateway in istio-system namespace for the
// SNI host app.example.com:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: hcm-tweaks
//   namespace: istio-system
// spec:
//   workloadSelector:
//     istio: ingress-gateway
//   configPatches:
//   - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
//     match:
//       context: GATEWAY
//       listener:
//         filterChain:
//           sni: app.example.com
//           filter:
//             name: "envoy.http_connection_manager"
//     patch:
//       operation: MERGE
//       value: |
//         idle_timeout: 30s
//         xff_num_trusted_hops: 5
//```
//

package v1alpha3

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ApplyTo specifies where in the Envoy configuration, the given patch should be applied.
type EnvoyFilter_ApplyTo int32

const (
	EnvoyFilter_INVALID EnvoyFilter_ApplyTo = 0
	// Applies the patch to the listener.
	EnvoyFilter_LISTENER EnvoyFilter_ApplyTo = 1
	// Applies the patch to the filter chain match condition.
	EnvoyFilter_FILTER_CHAIN_MATCH EnvoyFilter_ApplyTo = 2
	// Applies the patch to the network filter chain, to modify an
	// existing filter or add a new filter.
	EnvoyFilter_NETWORK_FILTER EnvoyFilter_ApplyTo = 3
	// Applies the patch to the HTTP filter chain in the http
	// connection manager, to modify an existing filter or add a new
	// filter.
	EnvoyFilter_HTTP_FILTER EnvoyFilter_ApplyTo = 4
	// Applies the patch to the Route configuration (rds output) inside a HTTP
	// connection manager. This does not apply to the virtual host.
	EnvoyFilter_ROUTE_CONFIGURATION EnvoyFilter_ApplyTo = 5
	// Applies the patch to a virtual host inside a route configuration.
	EnvoyFilter_VIRTUAL_HOST EnvoyFilter_ApplyTo = 6
	// Applies the patch to a cluster in a CDS output. Also used to add new clusters.
	EnvoyFilter_CLUSTER EnvoyFilter_ApplyTo = 7
)

var EnvoyFilter_ApplyTo_name = map[int32]string{
	0: "INVALID",
	1: "LISTENER",
	2: "FILTER_CHAIN_MATCH",
	3: "NETWORK_FILTER",
	4: "HTTP_FILTER",
	5: "ROUTE_CONFIGURATION",
	6: "VIRTUAL_HOST",
	7: "CLUSTER",
}

var EnvoyFilter_ApplyTo_value = map[string]int32{
	"INVALID":             0,
	"LISTENER":            1,
	"FILTER_CHAIN_MATCH":  2,
	"NETWORK_FILTER":      3,
	"HTTP_FILTER":         4,
	"ROUTE_CONFIGURATION": 5,
	"VIRTUAL_HOST":        6,
	"CLUSTER":             7,
}

func (x EnvoyFilter_ApplyTo) String() string {
	return proto.EnumName(EnvoyFilter_ApplyTo_name, int32(x))
}

func (EnvoyFilter_ApplyTo) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0}
}

// PatchContext selects a class of configurations based on the
// traffic flow direction and workload type.
type EnvoyFilter_PatchContext int32

const (
	// All listeners/routes/clusters in both sidecars and gateways.
	EnvoyFilter_ANY EnvoyFilter_PatchContext = 0
	// Inbound listener/route/cluster in sidecar.
	EnvoyFilter_SIDECAR_INBOUND EnvoyFilter_PatchContext = 1
	// Outbound listener/route/cluster in sidecar.
	EnvoyFilter_SIDECAR_OUTBOUND EnvoyFilter_PatchContext = 2
	// Gateway listener/route/cluster.
	EnvoyFilter_GATEWAY EnvoyFilter_PatchContext = 3
)

var EnvoyFilter_PatchContext_name = map[int32]string{
	0: "ANY",
	1: "SIDECAR_INBOUND",
	2: "SIDECAR_OUTBOUND",
	3: "GATEWAY",
}

var EnvoyFilter_PatchContext_value = map[string]int32{
	"ANY":              0,
	"SIDECAR_INBOUND":  1,
	"SIDECAR_OUTBOUND": 2,
	"GATEWAY":          3,
}

func (x EnvoyFilter_PatchContext) String() string {
	return proto.EnumName(EnvoyFilter_PatchContext_name, int32(x))
}

func (EnvoyFilter_PatchContext) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 1}
}

type EnvoyFilter_DeprecatedListenerMatch_ListenerType int32

const (
	// All listeners
	EnvoyFilter_DeprecatedListenerMatch_ANY EnvoyFilter_DeprecatedListenerMatch_ListenerType = 0
	// Inbound listener in sidecar
	EnvoyFilter_DeprecatedListenerMatch_SIDECAR_INBOUND EnvoyFilter_DeprecatedListenerMatch_ListenerType = 1
	// Outbound listener in sidecar
	EnvoyFilter_DeprecatedListenerMatch_SIDECAR_OUTBOUND EnvoyFilter_DeprecatedListenerMatch_ListenerType = 2
	// Gateway listener
	EnvoyFilter_DeprecatedListenerMatch_GATEWAY EnvoyFilter_DeprecatedListenerMatch_ListenerType = 3
)

var EnvoyFilter_DeprecatedListenerMatch_ListenerType_name = map[int32]string{
	0: "ANY",
	1: "SIDECAR_INBOUND",
	2: "SIDECAR_OUTBOUND",
	3: "GATEWAY",
}

var EnvoyFilter_DeprecatedListenerMatch_ListenerType_value = map[string]int32{
	"ANY":              0,
	"SIDECAR_INBOUND":  1,
	"SIDECAR_OUTBOUND": 2,
	"GATEWAY":          3,
}

func (x EnvoyFilter_DeprecatedListenerMatch_ListenerType) String() string {
	return proto.EnumName(EnvoyFilter_DeprecatedListenerMatch_ListenerType_name, int32(x))
}

func (EnvoyFilter_DeprecatedListenerMatch_ListenerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0, 0}
}

type EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol int32

const (
	// All protocols
	EnvoyFilter_DeprecatedListenerMatch_ALL EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol = 0
	// HTTP or HTTPS (with termination) / HTTP2/gRPC
	EnvoyFilter_DeprecatedListenerMatch_HTTP EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol = 1
	// Any non-HTTP listener
	EnvoyFilter_DeprecatedListenerMatch_TCP EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol = 2
)

var EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol_name = map[int32]string{
	0: "ALL",
	1: "HTTP",
	2: "TCP",
}

var EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol_value = map[string]int32{
	"ALL":  0,
	"HTTP": 1,
	"TCP":  2,
}

func (x EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol) String() string {
	return proto.EnumName(EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol_name, int32(x))
}

func (EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0, 1}
}

// Index/position in the filter chain.
type EnvoyFilter_InsertPosition_Index int32

const (
	// Insert first
	EnvoyFilter_InsertPosition_FIRST EnvoyFilter_InsertPosition_Index = 0
	// Insert last
	EnvoyFilter_InsertPosition_LAST EnvoyFilter_InsertPosition_Index = 1
	// Insert before the named filter.
	EnvoyFilter_InsertPosition_BEFORE EnvoyFilter_InsertPosition_Index = 2
	// Insert after the named filter.
	EnvoyFilter_InsertPosition_AFTER EnvoyFilter_InsertPosition_Index = 3
)

var EnvoyFilter_InsertPosition_Index_name = map[int32]string{
	0: "FIRST",
	1: "LAST",
	2: "BEFORE",
	3: "AFTER",
}

var EnvoyFilter_InsertPosition_Index_value = map[string]int32{
	"FIRST":  0,
	"LAST":   1,
	"BEFORE": 2,
	"AFTER":  3,
}

func (x EnvoyFilter_InsertPosition_Index) String() string {
	return proto.EnumName(EnvoyFilter_InsertPosition_Index_name, int32(x))
}

func (EnvoyFilter_InsertPosition_Index) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 1, 0}
}

type EnvoyFilter_Filter_FilterType int32

const (
	// placeholder
	EnvoyFilter_Filter_INVALID EnvoyFilter_Filter_FilterType = 0
	// Http filter
	EnvoyFilter_Filter_HTTP EnvoyFilter_Filter_FilterType = 1
	// Network filter
	EnvoyFilter_Filter_NETWORK EnvoyFilter_Filter_FilterType = 2
)

var EnvoyFilter_Filter_FilterType_name = map[int32]string{
	0: "INVALID",
	1: "HTTP",
	2: "NETWORK",
}

var EnvoyFilter_Filter_FilterType_value = map[string]int32{
	"INVALID": 0,
	"HTTP":    1,
	"NETWORK": 2,
}

func (x EnvoyFilter_Filter_FilterType) String() string {
	return proto.EnumName(EnvoyFilter_Filter_FilterType_name, int32(x))
}

func (EnvoyFilter_Filter_FilterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2, 0}
}

// Operation denotes how the patch should be applied to the selected
// configuration.
type EnvoyFilter_Patch_Operation int32

const (
	EnvoyFilter_Patch_INVALID EnvoyFilter_Patch_Operation = 0
	// Overlay the value onto the element selected by the path using
	// json merge semantics. For primitive fields this is equivalent
	// to ADD.
	EnvoyFilter_Patch_MERGE EnvoyFilter_Patch_Operation = 1
	// For maps this will either add to the map or replace the value
	// for the key. For fields this will replace the value.
	EnvoyFilter_Patch_ADD EnvoyFilter_Patch_Operation = 2
	// Remove the selected elements from their parent. Does not
	// require a value to be specified. When removing fields their
	// values are reset to their intrinsic default.
	EnvoyFilter_Patch_REMOVE EnvoyFilter_Patch_Operation = 3
	// Insert operation on an array of named objects. This operation
	// is typically useful only in the context of filters, where the
	// order of filters matter. For clusters and virtual hosts,
	// order of the element in the array does not matter. Insert at
	// the front of the list.
	EnvoyFilter_Patch_INSERT_FIRST EnvoyFilter_Patch_Operation = 4
	// Insert at the end of the list.
	EnvoyFilter_Patch_INSERT_LAST EnvoyFilter_Patch_Operation = 5
	// Insert before the selected filter or sub filter.
	EnvoyFilter_Patch_INSERT_BEFORE EnvoyFilter_Patch_Operation = 6
	// Insert after the selected filter or sub filter.
	EnvoyFilter_Patch_INSERT_AFTER EnvoyFilter_Patch_Operation = 7
)

var EnvoyFilter_Patch_Operation_name = map[int32]string{
	0: "INVALID",
	1: "MERGE",
	2: "ADD",
	3: "REMOVE",
	4: "INSERT_FIRST",
	5: "INSERT_LAST",
	6: "INSERT_BEFORE",
	7: "INSERT_AFTER",
}

var EnvoyFilter_Patch_Operation_value = map[string]int32{
	"INVALID":       0,
	"MERGE":         1,
	"ADD":           2,
	"REMOVE":        3,
	"INSERT_FIRST":  4,
	"INSERT_LAST":   5,
	"INSERT_BEFORE": 6,
	"INSERT_AFTER":  7,
}

func (x EnvoyFilter_Patch_Operation) String() string {
	return proto.EnumName(EnvoyFilter_Patch_Operation_name, int32(x))
}

func (EnvoyFilter_Patch_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 6, 0}
}

type EnvoyFilter struct {
	// Deprecated. Use workload_selector instead.
	// $hide_from_docs
	WorkloadLabels map[string]string `protobuf:"bytes,1,rep,name=workload_labels,json=workloadLabels,proto3" json:"workload_labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` // Deprecated: Do not use.
	// $hide_from_docs
	Filters []*EnvoyFilter_Filter `protobuf:"bytes,2,rep,name=filters,proto3" json:"filters,omitempty"` // Deprecated: Do not use.
	// Zero or more labels that indicate a specific set of sidecars or
	// gateways whose envoy configurations need to be customized. The
	// scope of label search is restricted to the configuration
	// namespace in which the the resource is present. In other words,
	// the EnvoyFilter resource must reside in the same namespace as the
	// gateway/sidecar. If omitted, the EnvoyFilter patches will be
	// applied to all workloads in the same namespace. If the
	// EnvoyFilter is present in the config root namespace, it will be
	// applied to all applicable workloads in any namespace.
	WorkloadSelector map[string]string `protobuf:"bytes,3,rep,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// REQUIRED. One or more patches with match conditions.
	ConfigPatches        []*EnvoyFilter_EnvoyConfigObjectPatch `protobuf:"bytes,4,rep,name=config_patches,json=configPatches,proto3" json:"config_patches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *EnvoyFilter) Reset()         { *m = EnvoyFilter{} }
func (m *EnvoyFilter) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter) ProtoMessage()    {}
func (*EnvoyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0}
}
func (m *EnvoyFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter.Merge(m, src)
}
func (m *EnvoyFilter) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *EnvoyFilter) GetWorkloadLabels() map[string]string {
	if m != nil {
		return m.WorkloadLabels
	}
	return nil
}

// Deprecated: Do not use.
func (m *EnvoyFilter) GetFilters() []*EnvoyFilter_Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *EnvoyFilter) GetWorkloadSelector() map[string]string {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *EnvoyFilter) GetConfigPatches() []*EnvoyFilter_EnvoyConfigObjectPatch {
	if m != nil {
		return m.ConfigPatches
	}
	return nil
}

// Deprecated.
// Select a listener to add the filter to based on the match conditions.
// All conditions specified in the ListenerMatch must be met for the filter
// to be applied to a listener.
// $hide_from_docs
type EnvoyFilter_DeprecatedListenerMatch struct {
	// The service port/gateway port to which traffic is being
	// sent/received. If not specified, matches all listeners. Even though
	// inbound listeners are generated for the instance/pod ports, only
	// service ports should be used to match listeners.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// Instead of using specific port numbers, a set of ports matching a
	// given port name prefix can be selected. E.g., "mongo" selects ports
	// named mongo-port, mongo, mongoDB, MONGO, etc. Matching is case
	// insensitive.
	PortNamePrefix string `protobuf:"bytes,2,opt,name=port_name_prefix,json=portNamePrefix,proto3" json:"port_name_prefix,omitempty"`
	// Inbound vs outbound sidecar listener or gateway listener. If not specified,
	// matches all listeners.
	ListenerType EnvoyFilter_DeprecatedListenerMatch_ListenerType `protobuf:"varint,3,opt,name=listener_type,json=listenerType,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_DeprecatedListenerMatch_ListenerType" json:"listener_type,omitempty"`
	// Selects a class of listeners for the same protocol. Use the protocol
	// selection to select all HTTP listeners (includes HTTP2/gRPC/HTTPS
	// where Envoy terminates TLS) or all TCP listeners (includes HTTPS
	// passthrough using SNI). When adding a HTTP filter, the listenerProtocol
	// should be set to HTTP.
	ListenerProtocol EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol `protobuf:"varint,4,opt,name=listener_protocol,json=listenerProtocol,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol" json:"listener_protocol,omitempty"`
	// One or more IP addresses to which the listener is bound. If
	// specified, should match at least one address in the list.
	Address              []string `protobuf:"bytes,5,rep,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_DeprecatedListenerMatch) Reset()         { *m = EnvoyFilter_DeprecatedListenerMatch{} }
func (m *EnvoyFilter_DeprecatedListenerMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_DeprecatedListenerMatch) ProtoMessage()    {}
func (*EnvoyFilter_DeprecatedListenerMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0}
}
func (m *EnvoyFilter_DeprecatedListenerMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_DeprecatedListenerMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_DeprecatedListenerMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_DeprecatedListenerMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_DeprecatedListenerMatch.Merge(m, src)
}
func (m *EnvoyFilter_DeprecatedListenerMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_DeprecatedListenerMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_DeprecatedListenerMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_DeprecatedListenerMatch proto.InternalMessageInfo

func (m *EnvoyFilter_DeprecatedListenerMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_DeprecatedListenerMatch) GetPortNamePrefix() string {
	if m != nil {
		return m.PortNamePrefix
	}
	return ""
}

func (m *EnvoyFilter_DeprecatedListenerMatch) GetListenerType() EnvoyFilter_DeprecatedListenerMatch_ListenerType {
	if m != nil {
		return m.ListenerType
	}
	return EnvoyFilter_DeprecatedListenerMatch_ANY
}

func (m *EnvoyFilter_DeprecatedListenerMatch) GetListenerProtocol() EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol {
	if m != nil {
		return m.ListenerProtocol
	}
	return EnvoyFilter_DeprecatedListenerMatch_ALL
}

func (m *EnvoyFilter_DeprecatedListenerMatch) GetAddress() []string {
	if m != nil {
		return m.Address
	}
	return nil
}

// Deprecated.
// Indicates the relative index in the filter chain where the filter should be inserted.
// $hide_from_docs
type EnvoyFilter_InsertPosition struct {
	// Position of this filter in the filter chain.
	Index EnvoyFilter_InsertPosition_Index `protobuf:"varint,1,opt,name=index,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_InsertPosition_Index" json:"index,omitempty"`
	// If BEFORE or AFTER position is specified, specify the name of the
	// filter relative to which this filter should be inserted.
	RelativeTo           string   `protobuf:"bytes,2,opt,name=relative_to,json=relativeTo,proto3" json:"relative_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_InsertPosition) Reset()         { *m = EnvoyFilter_InsertPosition{} }
func (m *EnvoyFilter_InsertPosition) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_InsertPosition) ProtoMessage()    {}
func (*EnvoyFilter_InsertPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 1}
}
func (m *EnvoyFilter_InsertPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_InsertPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_InsertPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_InsertPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_InsertPosition.Merge(m, src)
}
func (m *EnvoyFilter_InsertPosition) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_InsertPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_InsertPosition.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_InsertPosition proto.InternalMessageInfo

func (m *EnvoyFilter_InsertPosition) GetIndex() EnvoyFilter_InsertPosition_Index {
	if m != nil {
		return m.Index
	}
	return EnvoyFilter_InsertPosition_FIRST
}

func (m *EnvoyFilter_InsertPosition) GetRelativeTo() string {
	if m != nil {
		return m.RelativeTo
	}
	return ""
}

// Deprecated.
// Envoy filters to be added to a network or http filter chain.
// $hide_from_docs
type EnvoyFilter_Filter struct {
	// Filter will be added to the listener only if the match
	// conditions are true.  If not specified, the filters will be
	// applied to all listeners where possible, potentially resulting
	// in invalid configurations. It is recommended to specify the
	// listener match criteria for all filter insertions.
	ListenerMatch *EnvoyFilter_ListenerMatch `protobuf:"bytes,1,opt,name=listener_match,json=listenerMatch,proto3" json:"listener_match,omitempty"`
	// Insert position in the filter chain. Defaults to FIRST
	InsertPosition *EnvoyFilter_InsertPosition `protobuf:"bytes,2,opt,name=insert_position,json=insertPosition,proto3" json:"insert_position,omitempty"`
	// REQUIRED: The type of filter to instantiate.
	FilterType EnvoyFilter_Filter_FilterType `protobuf:"varint,3,opt,name=filter_type,json=filterType,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_Filter_FilterType" json:"filter_type,omitempty"`
	// REQUIRED: The name of the filter to instantiate. The name must match a supported
	// filter _compiled into_ Envoy.
	FilterName string `protobuf:"bytes,4,opt,name=filter_name,json=filterName,proto3" json:"filter_name,omitempty"`
	// REQUIRED: Filter specific configuration which depends on the filter being
	// instantiated.
	FilterConfig         *types.Struct `protobuf:"bytes,5,opt,name=filter_config,json=filterConfig,proto3" json:"filter_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *EnvoyFilter_Filter) Reset()         { *m = EnvoyFilter_Filter{} }
func (m *EnvoyFilter_Filter) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_Filter) ProtoMessage()    {}
func (*EnvoyFilter_Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2}
}
func (m *EnvoyFilter_Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_Filter.Merge(m, src)
}
func (m *EnvoyFilter_Filter) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_Filter proto.InternalMessageInfo

func (m *EnvoyFilter_Filter) GetListenerMatch() *EnvoyFilter_ListenerMatch {
	if m != nil {
		return m.ListenerMatch
	}
	return nil
}

func (m *EnvoyFilter_Filter) GetInsertPosition() *EnvoyFilter_InsertPosition {
	if m != nil {
		return m.InsertPosition
	}
	return nil
}

func (m *EnvoyFilter_Filter) GetFilterType() EnvoyFilter_Filter_FilterType {
	if m != nil {
		return m.FilterType
	}
	return EnvoyFilter_Filter_INVALID
}

func (m *EnvoyFilter_Filter) GetFilterName() string {
	if m != nil {
		return m.FilterName
	}
	return ""
}

func (m *EnvoyFilter_Filter) GetFilterConfig() *types.Struct {
	if m != nil {
		return m.FilterConfig
	}
	return nil
}

// Conditions specified in ClusterMatch must be met for the patch
// to be applied to a cluster.
type EnvoyFilter_ClusterMatch struct {
	// The service port for which this cluster was generated.  If
	// omitted, applies to clusters for any port.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// The FQDN of the service name for this cluster. If omitted,
	// applies to clusters for any service.
	Hostname string `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// The subset associated with the service. If omitted, applies to
	// clusters for any subset of a service.
	Subset string `protobuf:"bytes,3,opt,name=subset,proto3" json:"subset,omitempty"`
	// The exact name of the cluster to match. To match a specific
	// cluster by name, such as the internally generated "Passthrough"
	// cluster, leave all fields in clusterMatch empty, except the
	// name.
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ClusterMatch) Reset()         { *m = EnvoyFilter_ClusterMatch{} }
func (m *EnvoyFilter_ClusterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ClusterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ClusterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 3}
}
func (m *EnvoyFilter_ClusterMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_ClusterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_ClusterMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_ClusterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ClusterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ClusterMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_ClusterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ClusterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ClusterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ClusterMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_ClusterMatch) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *EnvoyFilter_ClusterMatch) GetSubset() string {
	if m != nil {
		return m.Subset
	}
	return ""
}

func (m *EnvoyFilter_ClusterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Conditions specified in RouteConfigurationMatch must be met for
// the patch to be applied to a route configuration object or a
// specific virtual host within the route configuration.
type EnvoyFilter_RouteConfigurationMatch struct {
	// The service port number or gateway server port number for which
	// this route configuration was generated. If omitted, applies to
	// route configurations for all ports.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// The gateway server port name for which this route configuration
	// was generated. Port name is not applicable for sidecar contexts.
	GatewayServerPortName uint32 `protobuf:"varint,2,opt,name=gateway_server_port_name,json=gatewayServerPortName,proto3" json:"gateway_server_port_name,omitempty"`
	// The Istio gateway config's namespace/name for which this route
	// configuration was generated. Applies only if the context is
	// GATEWAY. Should be in the namespace/name format. Use this field
	// in conjunction with the portNumber and portName to accurately
	// select the Envoy route configuration for a specific HTTPS
	// server within a gateway config object.
	Gateway string `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Match a specific virtual host in a route configuration and
	// apply the patch to the virtual host.
	Vhost *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch `protobuf:"bytes,4,opt,name=vhost,proto3" json:"vhost,omitempty"`
	// Route configuration name to match on. Can be used to match a
	// specific route configuration by name, such as the internally
	// generated "http_proxy" route configuration for all sidecars.
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_RouteConfigurationMatch) Reset()         { *m = EnvoyFilter_RouteConfigurationMatch{} }
func (m *EnvoyFilter_RouteConfigurationMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_RouteConfigurationMatch) ProtoMessage()    {}
func (*EnvoyFilter_RouteConfigurationMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 4}
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Merge(m, src)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch proto.InternalMessageInfo

func (m *EnvoyFilter_RouteConfigurationMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetGatewayServerPortName() uint32 {
	if m != nil {
		return m.GatewayServerPortName
	}
	return 0
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetVhost() *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch {
	if m != nil {
		return m.Vhost
	}
	return nil
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Match a specific virtual host inside a route configuration.
type EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch struct {
	// The VirtualHosts objects generated by Istio are named as
	// host:port, where the host typically corresponds to the
	// VirtualService's host field or the hostname of a service in the
	// registry.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Reset() {
	*m = EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch{}
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) String() string {
	return proto.CompactTextString(m)
}
func (*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) ProtoMessage() {}
func (*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 4, 0}
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Merge(m, src)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch proto.InternalMessageInfo

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Conditions specified in a listener match must be met for the
// patch to be applied to a specific listener across all filter
// chains, or a specific filter chain inside the listener.
type EnvoyFilter_ListenerMatch struct {
	// The service port/gateway port to which traffic is being
	// sent/received. If not specified, matches all listeners. Even though
	// inbound listeners are generated for the instance/pod ports, only
	// service ports should be used to match listeners.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// Instead of using specific port numbers, a set of ports matching
	// a given service's port name can be selected. Matching is case
	// insensitive.
	ServicePortName string `protobuf:"bytes,2,opt,name=service_port_name,json=servicePortName,proto3" json:"service_port_name,omitempty"`
	// Match a specific filter chain in a listener. If specified, the
	// patch will be applied to the filter chain (and a specific
	// filter if specified) and not to other filter chains in the
	// listener.
	FilterChain *EnvoyFilter_ListenerMatch_FilterChainMatch `protobuf:"bytes,3,opt,name=filter_chain,json=filterChain,proto3" json:"filter_chain,omitempty"`
	// Match a specific listener by its name. The listeners generated
	// by Pilot are typically named as IP:Port.
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch) Reset()         { *m = EnvoyFilter_ListenerMatch{} }
func (m *EnvoyFilter_ListenerMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 5}
}
func (m *EnvoyFilter_ListenerMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_ListenerMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_ListenerMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_ListenerMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_ListenerMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_ListenerMatch) GetServicePortName() string {
	if m != nil {
		return m.ServicePortName
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch) GetFilterChain() *EnvoyFilter_ListenerMatch_FilterChainMatch {
	if m != nil {
		return m.FilterChain
	}
	return nil
}

func (m *EnvoyFilter_ListenerMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// For listeners with multiple filter chains (e.g., inbound
// listeners on sidecars with permissive mTLS, gateway listeners
// with multiple SNI matches), the filter chain match can be used
// to select a specific filter chain to patch.
type EnvoyFilter_ListenerMatch_FilterChainMatch struct {
	// The SNI value used by a filter chain's match condition.  This
	// condition will evaluate to false if the filter chain has no
	// sni match.
	Sni string `protobuf:"bytes,1,opt,name=sni,proto3" json:"sni,omitempty"`
	// Applies only to SIDECAR_INBOUND context. If non-empty, a
	// transport protocol to consider when determining a filter
	// chain match.  This value will be compared against the
	// transport protocol of a new connection, when it's detected by
	// one of the listener filters.
	//
	// Accepted values include:
	//
	// * `raw_buffer` - default, used when no transport protocol is detected.
	// * `tls` - set when TLS protocol is detected by the TLS inspector.
	TransportProtocol string `protobuf:"bytes,2,opt,name=transport_protocol,json=transportProtocol,proto3" json:"transport_protocol,omitempty"`
	// The name of a specific filter to apply the patch to. Set this
	// to envoy.http_connection_manager to add a filter or apply a
	// patch to the HTTP connection manager.
	Filter               *EnvoyFilter_ListenerMatch_FilterMatch `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) Reset() {
	*m = EnvoyFilter_ListenerMatch_FilterChainMatch{}
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) String() string {
	return proto.CompactTextString(m)
}
func (*EnvoyFilter_ListenerMatch_FilterChainMatch) ProtoMessage() {}
func (*EnvoyFilter_ListenerMatch_FilterChainMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 5, 0}
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetSni() string {
	if m != nil {
		return m.Sni
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetTransportProtocol() string {
	if m != nil {
		return m.TransportProtocol
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetFilter() *EnvoyFilter_ListenerMatch_FilterMatch {
	if m != nil {
		return m.Filter
	}
	return nil
}

// Conditions to match a specific filter within a filter chain.
type EnvoyFilter_ListenerMatch_FilterMatch struct {
	// The filter name to match on.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The next level filter within this filter to match
	// upon. Typically used for HTTP Connection Manager filters and
	// Thrift filters. This field is REQUIRED when the apply to is
	// HTTP_FILTER.
	SubFilter            *EnvoyFilter_ListenerMatch_SubFilterMatch `protobuf:"bytes,2,opt,name=sub_filter,json=subFilter,proto3" json:"sub_filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) Reset()         { *m = EnvoyFilter_ListenerMatch_FilterMatch{} }
func (m *EnvoyFilter_ListenerMatch_FilterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch_FilterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch_FilterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 5, 1}
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_FilterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) GetSubFilter() *EnvoyFilter_ListenerMatch_SubFilterMatch {
	if m != nil {
		return m.SubFilter
	}
	return nil
}

// Conditions to match a specific filter within another
// filter. This field is typically useful to match a HTTP filter
// inside the envoy.http_connection_manager network filter. This
// could also be applicable for thrift filters.
type EnvoyFilter_ListenerMatch_SubFilterMatch struct {
	// The filter name to match on.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) Reset() {
	*m = EnvoyFilter_ListenerMatch_SubFilterMatch{}
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch_SubFilterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch_SubFilterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 5, 2}
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Patch specifies the JSON path in the generated proto and the
// content to merge/remove on the specific path.
type EnvoyFilter_Patch struct {
	// Determines how the patch should be applied.
	Operation EnvoyFilter_Patch_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_Patch_Operation" json:"operation,omitempty"`
	// The proto equivalent of JSON Value. This will be merged using
	// json merge semantics with the existing proto in the path.
	Value                *types.Value `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *EnvoyFilter_Patch) Reset()         { *m = EnvoyFilter_Patch{} }
func (m *EnvoyFilter_Patch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_Patch) ProtoMessage()    {}
func (*EnvoyFilter_Patch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 6}
}
func (m *EnvoyFilter_Patch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_Patch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_Patch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_Patch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_Patch.Merge(m, src)
}
func (m *EnvoyFilter_Patch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_Patch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_Patch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_Patch proto.InternalMessageInfo

func (m *EnvoyFilter_Patch) GetOperation() EnvoyFilter_Patch_Operation {
	if m != nil {
		return m.Operation
	}
	return EnvoyFilter_Patch_INVALID
}

func (m *EnvoyFilter_Patch) GetValue() *types.Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type EnvoyFilter_EnvoyConfigObjectMatch struct {
	// Types that are valid to be assigned to ObjectTypes:
	//	*EnvoyFilter_EnvoyConfigObjectMatch_Listener
	//	*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration
	//	*EnvoyFilter_EnvoyConfigObjectMatch_Cluster
	ObjectTypes          isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes `protobuf_oneof:"object_types"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) Reset()         { *m = EnvoyFilter_EnvoyConfigObjectMatch{} }
func (m *EnvoyFilter_EnvoyConfigObjectMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_EnvoyConfigObjectMatch) ProtoMessage()    {}
func (*EnvoyFilter_EnvoyConfigObjectMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 7}
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Merge(m, src)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch proto.InternalMessageInfo

type isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes interface {
	isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EnvoyFilter_EnvoyConfigObjectMatch_Listener struct {
	Listener *EnvoyFilter_ListenerMatch `protobuf:"bytes,1,opt,name=listener,proto3,oneof"`
}
type EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration struct {
	RouteConfiguration *EnvoyFilter_RouteConfigurationMatch `protobuf:"bytes,3,opt,name=route_configuration,json=routeConfiguration,proto3,oneof"`
}
type EnvoyFilter_EnvoyConfigObjectMatch_Cluster struct {
	Cluster *EnvoyFilter_ClusterMatch `protobuf:"bytes,5,opt,name=cluster,proto3,oneof"`
}

func (*EnvoyFilter_EnvoyConfigObjectMatch_Listener) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}
func (*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}
func (*EnvoyFilter_EnvoyConfigObjectMatch_Cluster) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetObjectTypes() isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes {
	if m != nil {
		return m.ObjectTypes
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetListener() *EnvoyFilter_ListenerMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_Listener); ok {
		return x.Listener
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetRouteConfiguration() *EnvoyFilter_RouteConfigurationMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration); ok {
		return x.RouteConfiguration
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetCluster() *EnvoyFilter_ClusterMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_Cluster); ok {
		return x.Cluster
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*EnvoyFilter_EnvoyConfigObjectMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _EnvoyFilter_EnvoyConfigObjectMatch_OneofMarshaler, _EnvoyFilter_EnvoyConfigObjectMatch_OneofUnmarshaler, _EnvoyFilter_EnvoyConfigObjectMatch_OneofSizer, []interface{}{
		(*EnvoyFilter_EnvoyConfigObjectMatch_Listener)(nil),
		(*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration)(nil),
		(*EnvoyFilter_EnvoyConfigObjectMatch_Cluster)(nil),
	}
}

func _EnvoyFilter_EnvoyConfigObjectMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*EnvoyFilter_EnvoyConfigObjectMatch)
	// object_types
	switch x := m.ObjectTypes.(type) {
	case *EnvoyFilter_EnvoyConfigObjectMatch_Listener:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Listener); err != nil {
			return err
		}
	case *EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteConfiguration); err != nil {
			return err
		}
	case *EnvoyFilter_EnvoyConfigObjectMatch_Cluster:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("EnvoyFilter_EnvoyConfigObjectMatch.ObjectTypes has unexpected type %T", x)
	}
	return nil
}

func _EnvoyFilter_EnvoyConfigObjectMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*EnvoyFilter_EnvoyConfigObjectMatch)
	switch tag {
	case 1: // object_types.listener
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EnvoyFilter_ListenerMatch)
		err := b.DecodeMessage(msg)
		m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_Listener{msg}
		return true, err
	case 3: // object_types.route_configuration
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EnvoyFilter_RouteConfigurationMatch)
		err := b.DecodeMessage(msg)
		m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration{msg}
		return true, err
	case 5: // object_types.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EnvoyFilter_ClusterMatch)
		err := b.DecodeMessage(msg)
		m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_Cluster{msg}
		return true, err
	default:
		return false, nil
	}
}

func _EnvoyFilter_EnvoyConfigObjectMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*EnvoyFilter_EnvoyConfigObjectMatch)
	// object_types
	switch x := m.ObjectTypes.(type) {
	case *EnvoyFilter_EnvoyConfigObjectMatch_Listener:
		s := proto.Size(x.Listener)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration:
		s := proto.Size(x.RouteConfiguration)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *EnvoyFilter_EnvoyConfigObjectMatch_Cluster:
		s := proto.Size(x.Cluster)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Match conditions for selecting an object to patch.
type EnvoyFilter_EnvoyFilterMatchCondition struct {
	Context              EnvoyFilter_PatchContext            `protobuf:"varint,1,opt,name=context,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_PatchContext" json:"context,omitempty"`
	Match                *EnvoyFilter_EnvoyConfigObjectMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *EnvoyFilter_EnvoyFilterMatchCondition) Reset()         { *m = EnvoyFilter_EnvoyFilterMatchCondition{} }
func (m *EnvoyFilter_EnvoyFilterMatchCondition) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_EnvoyFilterMatchCondition) ProtoMessage()    {}
func (*EnvoyFilter_EnvoyFilterMatchCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 8}
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_EnvoyFilterMatchCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_EnvoyFilterMatchCondition.Merge(m, src)
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_EnvoyFilterMatchCondition.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_EnvoyFilterMatchCondition proto.InternalMessageInfo

func (m *EnvoyFilter_EnvoyFilterMatchCondition) GetContext() EnvoyFilter_PatchContext {
	if m != nil {
		return m.Context
	}
	return EnvoyFilter_ANY
}

func (m *EnvoyFilter_EnvoyFilterMatchCondition) GetMatch() *EnvoyFilter_EnvoyConfigObjectMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

// Changes to be made to various envoy config objects.
type EnvoyFilter_EnvoyConfigObjectPatch struct {
	// Specifies where in the Envoy configuration, the patch should be
	// applied.  The match is expected to select the appropriate
	// object based on applyTo.  For example, an applyTo with
	// HTTP_FILTER is expected to have a match condition on the
	// listeners, with a network filter selection on
	// envoy.http_connection_manager and a sub filter selection on the
	// HTTP filter relative to which the insertion should be
	// performed.
	ApplyTo EnvoyFilter_ApplyTo `protobuf:"varint,1,opt,name=apply_to,json=applyTo,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_ApplyTo" json:"apply_to,omitempty"`
	// Match on listener/route configuration/cluster.
	Match *EnvoyFilter_EnvoyConfigObjectMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// The patch to apply along with the operation.
	Patch                *EnvoyFilter_Patch `protobuf:"bytes,3,opt,name=patch,proto3" json:"patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) Reset()         { *m = EnvoyFilter_EnvoyConfigObjectPatch{} }
func (m *EnvoyFilter_EnvoyConfigObjectPatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_EnvoyConfigObjectPatch) ProtoMessage()    {}
func (*EnvoyFilter_EnvoyConfigObjectPatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 9}
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Merge(m, src)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Size() int {
	return m.Size()
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch proto.InternalMessageInfo

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetApplyTo() EnvoyFilter_ApplyTo {
	if m != nil {
		return m.ApplyTo
	}
	return EnvoyFilter_INVALID
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetMatch() *EnvoyFilter_EnvoyConfigObjectMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetPatch() *EnvoyFilter_Patch {
	if m != nil {
		return m.Patch
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_ApplyTo", EnvoyFilter_ApplyTo_name, EnvoyFilter_ApplyTo_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_PatchContext", EnvoyFilter_PatchContext_name, EnvoyFilter_PatchContext_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_DeprecatedListenerMatch_ListenerType", EnvoyFilter_DeprecatedListenerMatch_ListenerType_name, EnvoyFilter_DeprecatedListenerMatch_ListenerType_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol", EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol_name, EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_InsertPosition_Index", EnvoyFilter_InsertPosition_Index_name, EnvoyFilter_InsertPosition_Index_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_Filter_FilterType", EnvoyFilter_Filter_FilterType_name, EnvoyFilter_Filter_FilterType_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_Patch_Operation", EnvoyFilter_Patch_Operation_name, EnvoyFilter_Patch_Operation_value)
	proto.RegisterType((*EnvoyFilter)(nil), "istio.networking.v1alpha3.EnvoyFilter")
	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.EnvoyFilter.WorkloadLabelsEntry")
	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.EnvoyFilter.WorkloadSelectorEntry")
	proto.RegisterType((*EnvoyFilter_DeprecatedListenerMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.DeprecatedListenerMatch")
	proto.RegisterType((*EnvoyFilter_InsertPosition)(nil), "istio.networking.v1alpha3.EnvoyFilter.InsertPosition")
	proto.RegisterType((*EnvoyFilter_Filter)(nil), "istio.networking.v1alpha3.EnvoyFilter.Filter")
	proto.RegisterType((*EnvoyFilter_ClusterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ClusterMatch")
	proto.RegisterType((*EnvoyFilter_RouteConfigurationMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch")
	proto.RegisterType((*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.VirtualHostMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_FilterChainMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterChainMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_FilterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_SubFilterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.SubFilterMatch")
	proto.RegisterType((*EnvoyFilter_Patch)(nil), "istio.networking.v1alpha3.EnvoyFilter.Patch")
	proto.RegisterType((*EnvoyFilter_EnvoyConfigObjectMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectMatch")
	proto.RegisterType((*EnvoyFilter_EnvoyFilterMatchCondition)(nil), "istio.networking.v1alpha3.EnvoyFilter.EnvoyFilterMatchCondition")
	proto.RegisterType((*EnvoyFilter_EnvoyConfigObjectPatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectPatch")
}

func init() {
	proto.RegisterFile("networking/v1alpha3/envoy_filter.proto", fileDescriptor_16d9b2922bd3e4a9)
}

var fileDescriptor_16d9b2922bd3e4a9 = []byte{
	// 1469 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0xaf, 0x93, 0x26, 0x69, 0x5e, 0xd2, 0xd4, 0x9d, 0xee, 0xb6, 0xd9, 0x08, 0x95, 0xaa, 0x42,
	0xab, 0x0a, 0xed, 0xba, 0xd0, 0xf2, 0x67, 0xb5, 0x2c, 0x88, 0x34, 0x75, 0x37, 0xd6, 0xa6, 0x49,
	0x98, 0xb8, 0x5d, 0x16, 0x24, 0x2c, 0x27, 0x9d, 0xb6, 0x66, 0x5d, 0xdb, 0xd8, 0x93, 0x76, 0x23,
	0x71, 0xe0, 0xc2, 0x95, 0x3b, 0x1f, 0x02, 0x09, 0x6e, 0x70, 0x82, 0x23, 0x47, 0x3e, 0x02, 0xda,
	0x0b, 0x47, 0xbe, 0x00, 0x07, 0x34, 0x7f, 0xec, 0x75, 0xba, 0x5d, 0x29, 0x6d, 0xe1, 0x64, 0xcf,
	0x9b, 0x37, 0xbf, 0x79, 0xef, 0xf9, 0x37, 0xbf, 0x37, 0x86, 0xdb, 0x1e, 0xa1, 0x67, 0x7e, 0xf8,
	0xd4, 0xf1, 0x8e, 0xd6, 0x4f, 0xdf, 0xb6, 0xdd, 0xe0, 0xd8, 0xde, 0x5c, 0x27, 0xde, 0xa9, 0x3f,
	0xb2, 0x0e, 0x1d, 0x97, 0x92, 0x50, 0x0b, 0x42, 0x9f, 0xfa, 0xe8, 0x96, 0x13, 0x51, 0xc7, 0xd7,
	0x5e, 0x78, 0x6b, 0xb1, 0x77, 0xed, 0xb5, 0x23, 0xdf, 0x3f, 0x72, 0xc9, 0x3a, 0x77, 0xec, 0x0f,
	0x0f, 0xd7, 0x23, 0x1a, 0x0e, 0x07, 0x54, 0x2c, 0x5c, 0xfd, 0x6b, 0x19, 0x4a, 0x3a, 0xc3, 0xdb,
	0xe1, 0x70, 0xe8, 0x08, 0xe6, 0x18, 0x82, 0xeb, 0xdb, 0x07, 0x96, 0x6b, 0xf7, 0x89, 0x1b, 0x55,
	0x95, 0x95, 0xec, 0x5a, 0x69, 0xe3, 0xbe, 0xf6, 0xca, 0x2d, 0xb4, 0x14, 0x80, 0xf6, 0x58, 0xae,
	0x6e, 0xf1, 0xc5, 0xba, 0x47, 0xc3, 0xd1, 0x56, 0xa6, 0xaa, 0xe0, 0xca, 0xd9, 0xd8, 0x04, 0x7a,
	0x04, 0x05, 0x91, 0x41, 0x54, 0xcd, 0xf0, 0x0d, 0xee, 0x4e, 0xb8, 0x81, 0x78, 0x70, 0xcc, 0x18,
	0x01, 0x39, 0x30, 0x9f, 0x44, 0x1d, 0x11, 0x97, 0x0c, 0xa8, 0x1f, 0x56, 0xb3, 0x1c, 0xf6, 0xc1,
	0x25, 0xe3, 0xee, 0xc9, 0xe5, 0x3c, 0x72, 0xac, 0x9e, 0x9d, 0x33, 0xa3, 0x03, 0xa8, 0x0c, 0x7c,
	0xef, 0xd0, 0x39, 0xb2, 0x02, 0x9b, 0x0e, 0x8e, 0x49, 0x54, 0x9d, 0xe6, 0xfb, 0x7c, 0x38, 0xe1,
	0x3e, 0xfc, 0xbd, 0xc1, 0x11, 0x3a, 0xfd, 0x2f, 0xc9, 0x80, 0x76, 0x19, 0x0c, 0x9e, 0x15, 0xa0,
	0x5d, 0x81, 0x59, 0xfb, 0x3b, 0x0b, 0x4b, 0xdb, 0x24, 0x08, 0xc9, 0xc0, 0xa6, 0xe4, 0xa0, 0xe5,
	0x44, 0x94, 0x78, 0x24, 0xdc, 0x65, 0xb3, 0xe8, 0x75, 0x28, 0x05, 0x7e, 0x48, 0x2d, 0x6f, 0x78,
	0xd2, 0x27, 0x61, 0x55, 0x59, 0x51, 0xd6, 0x66, 0x31, 0x30, 0x53, 0x9b, 0x5b, 0xd0, 0x1a, 0xa8,
	0xc2, 0xc1, 0x3e, 0x21, 0x56, 0x10, 0x92, 0x43, 0xe7, 0x59, 0x35, 0xb3, 0xa2, 0xac, 0x15, 0x71,
	0x85, 0x7b, 0xd9, 0x27, 0xa4, 0xcb, 0xad, 0x28, 0x80, 0x59, 0x57, 0x62, 0x5b, 0x74, 0x14, 0x90,
	0x6a, 0x76, 0x45, 0x59, 0xab, 0x6c, 0x3c, 0x9a, 0x30, 0x97, 0x57, 0x44, 0xa8, 0xc5, 0x23, 0x73,
	0x14, 0x10, 0x5c, 0x76, 0x53, 0x23, 0xf4, 0x35, 0xcc, 0x27, 0x3b, 0x72, 0x06, 0x0e, 0x7c, 0xb7,
	0x3a, 0xcd, 0x77, 0xed, 0xfc, 0x47, 0xbb, 0x76, 0x25, 0x2c, 0x56, 0xdd, 0x73, 0x16, 0x54, 0x85,
	0x82, 0x7d, 0x70, 0x10, 0x92, 0x28, 0xaa, 0xe6, 0x56, 0xb2, 0x6b, 0x45, 0x1c, 0x0f, 0x57, 0x3b,
	0x50, 0x4e, 0x47, 0x8d, 0x0a, 0x90, 0xad, 0xb7, 0x9f, 0xa8, 0x53, 0x68, 0x01, 0xe6, 0x7a, 0xc6,
	0xb6, 0xde, 0xa8, 0x63, 0xcb, 0x68, 0x6f, 0x75, 0xf6, 0xda, 0xdb, 0xaa, 0x82, 0x6e, 0x80, 0x1a,
	0x1b, 0x3b, 0x7b, 0xa6, 0xb0, 0x66, 0x50, 0x09, 0x0a, 0x0f, 0xeb, 0xa6, 0xfe, 0xb8, 0xfe, 0x44,
	0xcd, 0xae, 0x6a, 0xa0, 0x9e, 0x0f, 0x88, 0x83, 0xb6, 0x5a, 0xea, 0x14, 0x9a, 0x81, 0xe9, 0xa6,
	0x69, 0x76, 0x55, 0x85, 0x99, 0xcc, 0x46, 0x57, 0xcd, 0xd4, 0x7e, 0x51, 0xa0, 0x62, 0x78, 0x11,
	0x09, 0x69, 0xd7, 0x8f, 0x1c, 0xea, 0xf8, 0x1e, 0xfa, 0x04, 0x72, 0x8e, 0x77, 0x40, 0x9e, 0xf1,
	0x4f, 0x5c, 0xd9, 0xf8, 0x60, 0xc2, 0xfa, 0x8c, 0xa3, 0x68, 0x06, 0x83, 0xc0, 0x02, 0x89, 0x71,
	0x27, 0x24, 0xae, 0x4d, 0x9d, 0x53, 0x62, 0x51, 0x5f, 0xb2, 0x02, 0x62, 0x93, 0xe9, 0xaf, 0x6e,
	0x42, 0x8e, 0x2f, 0x40, 0x45, 0xc8, 0xed, 0x18, 0xb8, 0x67, 0x8a, 0x68, 0x5b, 0xf5, 0x9e, 0xa9,
	0x2a, 0x08, 0x20, 0xbf, 0xa5, 0xef, 0x74, 0xb0, 0xae, 0x66, 0x98, 0x43, 0x7d, 0xc7, 0xd4, 0xb1,
	0x9a, 0xad, 0xfd, 0x94, 0x85, 0xbc, 0xd4, 0x8f, 0xcf, 0xa1, 0x92, 0x7c, 0xdf, 0x13, 0xf6, 0x59,
	0x78, 0xf0, 0xa5, 0x8d, 0x77, 0x26, 0x0c, 0x7e, 0xec, 0x93, 0xe2, 0x84, 0x9d, 0x82, 0xf9, 0x5f,
	0xc0, 0x9c, 0xc3, 0x93, 0xb3, 0x02, 0x99, 0x1d, 0xcf, 0xa0, 0xb4, 0xf1, 0xee, 0x95, 0x4a, 0x83,
	0x2b, 0xce, 0x78, 0xc1, 0x9f, 0x40, 0x49, 0x28, 0x4a, 0xfa, 0x30, 0xdc, 0xbb, 0x94, 0x2e, 0xc9,
	0x07, 0x67, 0x3e, 0x1c, 0x26, 0xef, 0xac, 0xf0, 0x12, 0x9a, 0x9d, 0x4a, 0xce, 0xf8, 0x62, 0xec,
	0xc0, 0x0e, 0x24, 0x7a, 0x00, 0xb3, 0xd2, 0x41, 0x28, 0x41, 0x35, 0xc7, 0x33, 0x5b, 0xd2, 0x84,
	0x7c, 0x6b, 0xb1, 0x7c, 0x6b, 0x3d, 0x2e, 0xdf, 0xb8, 0x2c, 0xbc, 0x85, 0x92, 0xac, 0xbe, 0x05,
	0xf0, 0x62, 0x63, 0x46, 0x44, 0xa3, 0xbd, 0x5f, 0x6f, 0x19, 0xdb, 0x63, 0x5c, 0x2b, 0x41, 0xa1,
	0xad, 0x9b, 0x8f, 0x3b, 0xf8, 0x91, 0x9a, 0xa9, 0x9d, 0x41, 0xb9, 0xe1, 0x0e, 0x23, 0x3a, 0xb1,
	0xaa, 0xd4, 0x60, 0xe6, 0xd8, 0x8f, 0x28, 0x0f, 0x5f, 0xf0, 0x26, 0x19, 0xa3, 0x45, 0xc8, 0x47,
	0xc3, 0x7e, 0x44, 0x28, 0xaf, 0x59, 0x11, 0xcb, 0x11, 0x42, 0x30, 0x9d, 0x4a, 0x97, 0xbf, 0xd7,
	0x7e, 0xcc, 0xc0, 0x12, 0xf6, 0x87, 0x94, 0x88, 0xd0, 0x87, 0xa1, 0xcd, 0x6a, 0x3f, 0x61, 0x10,
	0xef, 0x43, 0xf5, 0xc8, 0xa6, 0xe4, 0xcc, 0x1e, 0x59, 0x11, 0x09, 0x4f, 0x99, 0x88, 0xc4, 0x4a,
	0xc7, 0x83, 0x9a, 0xc5, 0x37, 0xe5, 0x7c, 0x8f, 0x4f, 0x77, 0xa5, 0xde, 0xb1, 0x93, 0x2f, 0x27,
	0x64, 0x88, 0xf1, 0x10, 0x11, 0xc8, 0x9d, 0xb2, 0x44, 0x78, 0x90, 0xa5, 0x89, 0x55, 0xe8, 0x15,
	0x29, 0x68, 0xfb, 0x4e, 0x48, 0x87, 0xb6, 0xdb, 0xf4, 0x23, 0x2a, 0x38, 0x2c, 0xd0, 0x93, 0x52,
	0xe4, 0x52, 0xa5, 0xb8, 0x0d, 0xea, 0x79, 0xf7, 0xc4, 0x4f, 0x49, 0xf9, 0xfd, 0x3c, 0x0d, 0xb3,
	0x97, 0xec, 0x01, 0x6f, 0xc2, 0x3c, 0x2b, 0x90, 0x33, 0x20, 0xe7, 0x2a, 0x54, 0xc4, 0x73, 0x72,
	0x22, 0xa9, 0xcd, 0x31, 0x94, 0x63, 0xea, 0x1d, 0xdb, 0x8e, 0xc7, 0x0b, 0x54, 0xda, 0xd0, 0xaf,
	0x72, 0x62, 0x25, 0xfd, 0x1b, 0x0c, 0x47, 0xa4, 0x2f, 0x69, 0xcf, 0x2d, 0x17, 0xf2, 0xe1, 0x07,
	0x05, 0xd4, 0xf3, 0xab, 0x90, 0x0a, 0xd9, 0xc8, 0x73, 0x64, 0x11, 0xd8, 0x2b, 0xba, 0x0b, 0x88,
	0x86, 0xb6, 0x17, 0xf1, 0x6c, 0x92, 0xce, 0x21, 0x32, 0x9a, 0x4f, 0x66, 0x12, 0xa9, 0xfd, 0x14,
	0xf2, 0x62, 0x63, 0x99, 0xcd, 0xc7, 0xd7, 0xc8, 0x46, 0x24, 0x22, 0xf1, 0x6a, 0xdf, 0x2a, 0x50,
	0x4a, 0xd9, 0x2f, 0xfa, 0x60, 0xa8, 0x0f, 0x10, 0x0d, 0xfb, 0xf2, 0x8a, 0x26, 0x35, 0xaa, 0x71,
	0xa5, 0x08, 0x7a, 0xc3, 0x7e, 0x3a, 0x88, 0x62, 0x14, 0x8f, 0x6b, 0x6f, 0x40, 0x65, 0x7c, 0xf2,
	0x42, 0xea, 0x7c, 0x97, 0x81, 0x1c, 0xbf, 0x54, 0x20, 0x13, 0x8a, 0x7e, 0x40, 0x04, 0x55, 0x65,
	0x47, 0x79, 0x6f, 0xc2, 0x90, 0x38, 0x80, 0xd6, 0x89, 0x57, 0xe3, 0x17, 0x40, 0xe8, 0x0e, 0xe4,
	0x4e, 0x6d, 0x77, 0x48, 0x64, 0x92, 0x8b, 0x2f, 0xc9, 0xd5, 0x3e, 0x9b, 0xc5, 0xc2, 0x69, 0xf5,
	0x1b, 0x05, 0x8a, 0x09, 0xcc, 0xb8, 0x4c, 0x15, 0x21, 0xb7, 0xab, 0xe3, 0x87, 0xba, 0xe8, 0x89,
	0xf5, 0x6d, 0xd6, 0x50, 0x01, 0xf2, 0x58, 0xdf, 0xed, 0xec, 0xeb, 0x6a, 0x16, 0xa9, 0x50, 0x36,
	0xda, 0x3d, 0x1d, 0x9b, 0x96, 0x68, 0x4b, 0xd3, 0x68, 0x0e, 0x4a, 0xd2, 0xc2, 0xbb, 0x53, 0x0e,
	0xcd, 0xc3, 0xac, 0x34, 0xc8, 0x26, 0x95, 0x4f, 0xad, 0x12, 0xbd, 0xaa, 0x50, 0xfb, 0x2d, 0x03,
	0x8b, 0x2f, 0xdd, 0xc1, 0x44, 0xfd, 0x30, 0xcc, 0xc4, 0xfd, 0xe6, 0x3a, 0x5d, 0xab, 0x39, 0x85,
	0x13, 0x1c, 0xf4, 0x15, 0x2c, 0x84, 0x4c, 0x29, 0xa4, 0xaa, 0x4b, 0xa9, 0x90, 0xa4, 0xfc, 0xe8,
	0x7a, 0x5a, 0xd3, 0x9c, 0xc2, 0x28, 0x7c, 0x69, 0x0a, 0x75, 0xa0, 0x30, 0x10, 0xca, 0x2e, 0x7b,
	0xc8, 0xe6, 0x84, 0xdb, 0xa4, 0xfb, 0x41, 0x73, 0x0a, 0xc7, 0x28, 0x5b, 0x15, 0x28, 0xfb, 0xbc,
	0x4c, 0xbc, 0x2d, 0x46, 0xb5, 0x5f, 0x15, 0xb8, 0x95, 0x5a, 0xc7, 0xfd, 0x1b, 0xbe, 0x77, 0x20,
	0x9a, 0xe8, 0x2e, 0x14, 0x06, 0xbe, 0x47, 0xc9, 0x33, 0x2a, 0x59, 0xb6, 0x79, 0x19, 0x96, 0x35,
	0xc4, 0x52, 0x1c, 0x63, 0xa0, 0x1e, 0xe4, 0xc4, 0x3d, 0x42, 0x10, 0xec, 0xca, 0xd7, 0x6c, 0x29,
	0xc6, 0x1c, 0xab, 0xf6, 0x8f, 0x72, 0x01, 0x09, 0xc4, 0x31, 0x31, 0x60, 0xc6, 0x0e, 0x02, 0x77,
	0xc4, 0xae, 0x47, 0x22, 0x7e, 0x6d, 0xc2, 0x2d, 0xeb, 0x6c, 0x99, 0xe9, 0xe3, 0x82, 0x2d, 0x5e,
	0xfe, 0x97, 0xd0, 0xd1, 0x16, 0xe4, 0xf8, 0x8f, 0x87, 0xa4, 0xd0, 0x9d, 0xcb, 0x14, 0x17, 0x8b,
	0xa5, 0xb5, 0x3a, 0x2c, 0x5c, 0xf0, 0x9b, 0xc6, 0x44, 0xf7, 0x29, 0x19, 0xc5, 0xa2, 0xfb, 0x94,
	0x8c, 0xd0, 0x8d, 0xf4, 0xe9, 0x2e, 0xca, 0x53, 0x7c, 0x3f, 0x73, 0x4f, 0xa9, 0x35, 0xe0, 0xe6,
	0x85, 0x7f, 0x4c, 0x97, 0x01, 0x59, 0xfd, 0x5e, 0x81, 0x82, 0xac, 0xda, 0xb8, 0x18, 0x94, 0x61,
	0xa6, 0x65, 0xf4, 0x4c, 0xbd, 0xad, 0x63, 0x55, 0x41, 0x8b, 0x80, 0x76, 0x8c, 0x96, 0xa9, 0x63,
	0xab, 0xd1, 0xac, 0x1b, 0x6d, 0x6b, 0xb7, 0x6e, 0x36, 0x9a, 0x6a, 0x06, 0x21, 0xa8, 0xc8, 0xfb,
	0x8c, 0x25, 0xe6, 0xd5, 0x2c, 0x13, 0x05, 0x76, 0xdb, 0x89, 0x0d, 0xd3, 0x68, 0x09, 0x16, 0x70,
	0x67, 0xcf, 0xd4, 0xad, 0x46, 0xa7, 0xbd, 0x63, 0x3c, 0xdc, 0xc3, 0x75, 0xd3, 0xe8, 0xb4, 0xd5,
	0x1c, 0x93, 0x86, 0x7d, 0x03, 0x9b, 0x7b, 0xf5, 0x96, 0xd5, 0xec, 0xf4, 0x4c, 0x35, 0xcf, 0x42,
	0x68, 0xb4, 0xf6, 0x7a, 0x5c, 0x27, 0xd8, 0x0f, 0x41, 0x9a, 0x90, 0xd7, 0xfe, 0x21, 0xd8, 0xd2,
	0x7e, 0x7f, 0xbe, 0xac, 0xfc, 0xf1, 0x7c, 0x59, 0xf9, 0xf3, 0xf9, 0xb2, 0xf2, 0xd9, 0x8a, 0xf8,
	0x6c, 0x8e, 0xbf, 0x6e, 0x07, 0xce, 0xfa, 0x05, 0x7f, 0xf9, 0xfd, 0x3c, 0x97, 0xd0, 0xcd, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x99, 0xa0, 0x73, 0x98, 0x03, 0x10, 0x00, 0x00,
}

func (m *EnvoyFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkloadLabels) > 0 {
		for k, _ := range m.WorkloadLabels {
			dAtA[i] = 0xa
			i++
			v := m.WorkloadLabels[k]
			mapSize := 1 + len(k) + sovEnvoyFilter(uint64(len(k))) + 1 + len(v) + sovEnvoyFilter(uint64(len(v)))
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Filters) > 0 {
		for _, msg := range m.Filters {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WorkloadSelector) > 0 {
		for k, _ := range m.WorkloadSelector {
			dAtA[i] = 0x1a
			i++
			v := m.WorkloadSelector[k]
			mapSize := 1 + len(k) + sovEnvoyFilter(uint64(len(k))) + 1 + len(v) + sovEnvoyFilter(uint64(len(v)))
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.ConfigPatches) > 0 {
		for _, msg := range m.ConfigPatches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintEnvoyFilter(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_DeprecatedListenerMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_DeprecatedListenerMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.PortNumber))
	}
	if len(m.PortNamePrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.PortNamePrefix)))
		i += copy(dAtA[i:], m.PortNamePrefix)
	}
	if m.ListenerType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.ListenerType))
	}
	if m.ListenerProtocol != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.ListenerProtocol))
	}
	if len(m.Address) > 0 {
		for _, s := range m.Address {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_InsertPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_InsertPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Index))
	}
	if len(m.RelativeTo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.RelativeTo)))
		i += copy(dAtA[i:], m.RelativeTo)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_Filter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ListenerMatch != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.ListenerMatch.Size()))
		n1, err1 := m.ListenerMatch.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.InsertPosition != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.InsertPosition.Size()))
		n2, err2 := m.InsertPosition.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.FilterType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.FilterType))
	}
	if len(m.FilterName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.FilterName)))
		i += copy(dAtA[i:], m.FilterName)
	}
	if m.FilterConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.FilterConfig.Size()))
		n3, err3 := m.FilterConfig.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_ClusterMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_ClusterMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.PortNumber))
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if len(m.Subset) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Subset)))
		i += copy(dAtA[i:], m.Subset)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_RouteConfigurationMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_RouteConfigurationMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.PortNumber))
	}
	if m.GatewayServerPortName != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.GatewayServerPortName))
	}
	if len(m.Gateway) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Gateway)))
		i += copy(dAtA[i:], m.Gateway)
	}
	if m.Vhost != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Vhost.Size()))
		n4, err4 := m.Vhost.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_ListenerMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_ListenerMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PortNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.PortNumber))
	}
	if len(m.ServicePortName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.ServicePortName)))
		i += copy(dAtA[i:], m.ServicePortName)
	}
	if m.FilterChain != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.FilterChain.Size()))
		n5, err5 := m.FilterChain.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sni) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Sni)))
		i += copy(dAtA[i:], m.Sni)
	}
	if len(m.TransportProtocol) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.TransportProtocol)))
		i += copy(dAtA[i:], m.TransportProtocol)
	}
	if m.Filter != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Filter.Size()))
		n6, err6 := m.Filter.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.SubFilter != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.SubFilter.Size()))
		n7, err7 := m.SubFilter.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_Patch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_Patch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operation != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Operation))
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Value.Size()))
		n8, err8 := m.Value.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectTypes != nil {
		nn9, err9 := m.ObjectTypes.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += nn9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch_Listener) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Listener != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Listener.Size()))
		n10, err10 := m.Listener.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RouteConfiguration != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.RouteConfiguration.Size()))
		n11, err11 := m.RouteConfiguration.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch_Cluster) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Cluster != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Cluster.Size()))
		n12, err12 := m.Cluster.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_EnvoyFilterMatchCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Context))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Match.Size()))
		n13, err13 := m.Match.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApplyTo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.ApplyTo))
	}
	if m.Match != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Match.Size()))
		n14, err14 := m.Match.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if m.Patch != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintEnvoyFilter(dAtA, i, uint64(m.Patch.Size()))
		n15, err15 := m.Patch.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintEnvoyFilter(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *EnvoyFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WorkloadLabels) > 0 {
		for k, v := range m.WorkloadLabels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEnvoyFilter(uint64(len(k))) + 1 + len(v) + sovEnvoyFilter(uint64(len(v)))
			n += mapEntrySize + 1 + sovEnvoyFilter(uint64(mapEntrySize))
		}
	}
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovEnvoyFilter(uint64(l))
		}
	}
	if len(m.WorkloadSelector) > 0 {
		for k, v := range m.WorkloadSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovEnvoyFilter(uint64(len(k))) + 1 + len(v) + sovEnvoyFilter(uint64(len(v)))
			n += mapEntrySize + 1 + sovEnvoyFilter(uint64(mapEntrySize))
		}
	}
	if len(m.ConfigPatches) > 0 {
		for _, e := range m.ConfigPatches {
			l = e.Size()
			n += 1 + l + sovEnvoyFilter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_DeprecatedListenerMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.PortNumber))
	}
	l = len(m.PortNamePrefix)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.ListenerType != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.ListenerType))
	}
	if m.ListenerProtocol != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.ListenerProtocol))
	}
	if len(m.Address) > 0 {
		for _, s := range m.Address {
			l = len(s)
			n += 1 + l + sovEnvoyFilter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_InsertPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.Index))
	}
	l = len(m.RelativeTo)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ListenerMatch != nil {
		l = m.ListenerMatch.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.InsertPosition != nil {
		l = m.InsertPosition.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.FilterType != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.FilterType))
	}
	l = len(m.FilterName)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.FilterConfig != nil {
		l = m.FilterConfig.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_ClusterMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.PortNumber))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	l = len(m.Subset)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_RouteConfigurationMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.PortNumber))
	}
	if m.GatewayServerPortName != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.GatewayServerPortName))
	}
	l = len(m.Gateway)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.Vhost != nil {
		l = m.Vhost.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_ListenerMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PortNumber != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.PortNumber))
	}
	l = len(m.ServicePortName)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.FilterChain != nil {
		l = m.FilterChain.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sni)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	l = len(m.TransportProtocol)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.SubFilter != nil {
		l = m.SubFilter.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_Patch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.Operation))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectTypes != nil {
		n += m.ObjectTypes.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch_Listener) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Listener != nil {
		l = m.Listener.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	return n
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RouteConfiguration != nil {
		l = m.RouteConfiguration.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	return n
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch_Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	return n
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Context != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.Context))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApplyTo != 0 {
		n += 1 + sovEnvoyFilter(uint64(m.ApplyTo))
	}
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.Patch != nil {
		l = m.Patch.Size()
		n += 1 + l + sovEnvoyFilter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovEnvoyFilter(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEnvoyFilter(x uint64) (n int) {
	return sovEnvoyFilter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EnvoyFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvoyFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvoyFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadLabels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadLabels == nil {
				m.WorkloadLabels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEnvoyFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEnvoyFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEnvoyFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WorkloadLabels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &EnvoyFilter_Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkloadSelector == nil {
				m.WorkloadSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEnvoyFilter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEnvoyFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEnvoyFilter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthEnvoyFilter
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WorkloadSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigPatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConfigPatches = append(m.ConfigPatches, &EnvoyFilter_EnvoyConfigObjectPatch{})
			if err := m.ConfigPatches[len(m.ConfigPatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_DeprecatedListenerMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeprecatedListenerMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeprecatedListenerMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNamePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortNamePrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerType", wireType)
			}
			m.ListenerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListenerType |= EnvoyFilter_DeprecatedListenerMatch_ListenerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerProtocol", wireType)
			}
			m.ListenerProtocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ListenerProtocol |= EnvoyFilter_DeprecatedListenerMatch_ListenerProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_InsertPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= EnvoyFilter_InsertPosition_Index(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelativeTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListenerMatch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ListenerMatch == nil {
				m.ListenerMatch = &EnvoyFilter_ListenerMatch{}
			}
			if err := m.ListenerMatch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertPosition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InsertPosition == nil {
				m.InsertPosition = &EnvoyFilter_InsertPosition{}
			}
			if err := m.InsertPosition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterType", wireType)
			}
			m.FilterType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilterType |= EnvoyFilter_Filter_FilterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FilterConfig == nil {
				m.FilterConfig = &types.Struct{}
			}
			if err := m.FilterConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_ClusterMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_RouteConfigurationMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteConfigurationMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteConfigurationMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayServerPortName", wireType)
			}
			m.GatewayServerPortName = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayServerPortName |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gateway", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gateway = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vhost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vhost == nil {
				m.Vhost = &EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch{}
			}
			if err := m.Vhost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualHostMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualHostMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_ListenerMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListenerMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListenerMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PortNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServicePortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServicePortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilterChain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FilterChain == nil {
				m.FilterChain = &EnvoyFilter_ListenerMatch_FilterChainMatch{}
			}
			if err := m.FilterChain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterChainMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterChainMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sni", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sni = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransportProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransportProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &EnvoyFilter_ListenerMatch_FilterMatch{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubFilter == nil {
				m.SubFilter = &EnvoyFilter_ListenerMatch_SubFilterMatch{}
			}
			if err := m.SubFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubFilterMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubFilterMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_Patch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Patch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Patch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= EnvoyFilter_Patch_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Value{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvoyConfigObjectMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvoyConfigObjectMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Listener", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnvoyFilter_ListenerMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_Listener{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnvoyFilter_RouteConfigurationMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EnvoyFilter_ClusterMatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ObjectTypes = &EnvoyFilter_EnvoyConfigObjectMatch_Cluster{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_EnvoyFilterMatchCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvoyFilterMatchCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvoyFilterMatchCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			m.Context = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Context |= EnvoyFilter_PatchContext(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &EnvoyFilter_EnvoyConfigObjectMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvoyConfigObjectPatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvoyConfigObjectPatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyTo", wireType)
			}
			m.ApplyTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyTo |= EnvoyFilter_ApplyTo(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &EnvoyFilter_EnvoyConfigObjectMatch{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Patch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Patch == nil {
				m.Patch = &EnvoyFilter_Patch{}
			}
			if err := m.Patch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEnvoyFilter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthEnvoyFilter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEnvoyFilter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEnvoyFilter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnvoyFilter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEnvoyFilter
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthEnvoyFilter
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEnvoyFilter
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEnvoyFilter(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthEnvoyFilter
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEnvoyFilter = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEnvoyFilter   = fmt.Errorf("proto: integer overflow")
)
