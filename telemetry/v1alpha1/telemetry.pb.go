// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: telemetry/v1alpha1/telemetry.proto

package v1alpha1

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	v1beta1 "istio.io/api/type/v1beta1"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// WorkloadMode allows selection of the role of the underlying workload in
// network traffic. A workload is considered as acting as a SERVER if it is
// the destination of the traffic (that is, traffic direction, from the
// perspective of the workload is *inbound*). If the workload is the source of
// the network traffic, it is considered to be in CLIENT mode (traffic is
// *outbound* from the workload).
type WorkloadMode int32

const (
	// Selects for scenarios when the workload is either the
	// source or destination of the network traffic.
	WorkloadMode_CLIENT_AND_SERVER WorkloadMode = 0
	// Selects for scenarios when the workload is the
	// source of the network traffic.
	WorkloadMode_CLIENT WorkloadMode = 1
	// Selects for scenarios when the workload is the
	// destination of the network traffic.
	WorkloadMode_SERVER WorkloadMode = 2
)

var WorkloadMode_name = map[int32]string{
	0: "CLIENT_AND_SERVER",
	1: "CLIENT",
	2: "SERVER",
}

var WorkloadMode_value = map[string]int32{
	"CLIENT_AND_SERVER": 0,
	"CLIENT":            1,
	"SERVER":            2,
}

func (x WorkloadMode) String() string {
	return proto.EnumName(WorkloadMode_name, int32(x))
}

func (WorkloadMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{0}
}

// Curated list of known metric types that is supported by Istio metric providers.
// See also: https://istio.io/latest/docs/reference/config/metrics/#metrics
type MetricSelector_IstioMetric int32

const (
	// Use of this enum indicates that the override should apply to all Istio default metrics.
	MetricSelector_ALL_METRICS MetricSelector_IstioMetric = 0
	// Counter of requests to/from an application, generated for HTTP, HTTP/2, and GRPC traffic.
	//
	// The Prometheus provider exports this metric as: `istio_requests_total`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/request_count` (SERVER mode)
	// - `istio.io/service/client/request_count` (CLIENT mode)
	MetricSelector_REQUEST_COUNT MetricSelector_IstioMetric = 1
	// Histogram of request durations, generated for HTTP, HTTP/2, and GRPC traffic.
	//
	// The Prometheus provider exports this metric as: `istio_request_duration_milliseconds`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/response_latencies` (SERVER mode)
	// - `istio.io/service/client/roundtrip_latencies` (CLIENT mode)
	MetricSelector_REQUEST_DURATION MetricSelector_IstioMetric = 2
	// Histogram of request body sizes, generated for HTTP, HTTP/2, and GRPC traffic.
	//
	// The Prometheus provider exports this metric as: `istio_request_bytes`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/request_bytes` (SERVER mode)
	// - `istio.io/service/client/request_bytes` (CLIENT mode)
	MetricSelector_REQUEST_SIZE MetricSelector_IstioMetric = 3
	// Histogram of response body sizes, generated for HTTP, HTTP/2, and GRPC traffic.
	//
	// The Prometheus provider exports this metric as: `istio_response_bytes`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/response_bytes` (SERVER mode)
	// - `istio.io/service/client/response_bytes` (CLIENT mode)
	MetricSelector_RESPONSE_SIZE MetricSelector_IstioMetric = 4
	// Counter of TCP connections opened over lifetime of workload.
	//
	// The Prometheus provider exports this metric as: `istio_tcp_connections_opened_total`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/connection_open_count` (SERVER mode)
	// - `istio.io/service/client/connection_open_count` (CLIENT mode)
	MetricSelector_TCP_OPENED_CONNECTIONS MetricSelector_IstioMetric = 5
	// Counter of TCP connections closed over lifetime of workload.
	//
	// The Prometheus provider exports this metric as: `istio_tcp_connections_closed_total`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/connection_close_count` (SERVER mode)
	// - `istio.io/service/client/connection_close_count` (CLIENT mode)
	MetricSelector_TCP_CLOSED_CONNECTIONS MetricSelector_IstioMetric = 6
	// Counter of bytes sent during a response over a TCP connection.
	//
	// The Prometheus provider exports this metric as: `istio_tcp_sent_bytes_total`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/sent_bytes_count` (SERVER mode)
	// - `istio.io/service/client/sent_bytes_count` (CLIENT mode)
	MetricSelector_TCP_SENT_BYTES MetricSelector_IstioMetric = 7
	// Counter of bytes received during a request over a TCP connection.
	//
	// The Prometheus provider exports this metric as: `istio_tcp_received_bytes_total`.
	//
	// The Stackdriver provider exports this metric as:
	// - `istio.io/service/server/received_bytes_count` (SERVER mode)
	// - `istio.io/service/client/received_bytes_count` (CLIENT mode)
	MetricSelector_TCP_RECEIVED_BYTES MetricSelector_IstioMetric = 8
	// Counter incremented for every gRPC messages sent from a client.
	//
	// The Prometheus provider exports this metric as: `istio_request_messages_total`
	MetricSelector_GRPC_REQUEST_MESSAGES MetricSelector_IstioMetric = 9
	// Counter incremented for every gRPC messages sent from a server.
	//
	// The Prometheus provider exports this metric as: `istio_response_messages_total`
	MetricSelector_GRPC_RESPONSE_MESSAGES MetricSelector_IstioMetric = 10
)

var MetricSelector_IstioMetric_name = map[int32]string{
	0:  "ALL_METRICS",
	1:  "REQUEST_COUNT",
	2:  "REQUEST_DURATION",
	3:  "REQUEST_SIZE",
	4:  "RESPONSE_SIZE",
	5:  "TCP_OPENED_CONNECTIONS",
	6:  "TCP_CLOSED_CONNECTIONS",
	7:  "TCP_SENT_BYTES",
	8:  "TCP_RECEIVED_BYTES",
	9:  "GRPC_REQUEST_MESSAGES",
	10: "GRPC_RESPONSE_MESSAGES",
}

var MetricSelector_IstioMetric_value = map[string]int32{
	"ALL_METRICS":            0,
	"REQUEST_COUNT":          1,
	"REQUEST_DURATION":       2,
	"REQUEST_SIZE":           3,
	"RESPONSE_SIZE":          4,
	"TCP_OPENED_CONNECTIONS": 5,
	"TCP_CLOSED_CONNECTIONS": 6,
	"TCP_SENT_BYTES":         7,
	"TCP_RECEIVED_BYTES":     8,
	"GRPC_REQUEST_MESSAGES":  9,
	"GRPC_RESPONSE_MESSAGES": 10,
}

func (x MetricSelector_IstioMetric) String() string {
	return proto.EnumName(MetricSelector_IstioMetric_name, int32(x))
}

func (MetricSelector_IstioMetric) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4, 0}
}

type MetricsOverrides_TagOverride_Operation int32

const (
	// Insert or Update the tag with the provided value expression. The `value`
	// field MUST be specified if UPSERT is used as the operation.
	MetricsOverrides_TagOverride_UPSERT MetricsOverrides_TagOverride_Operation = 0
	// Specifies that the tag should not be included in the metric when
	// generated.
	MetricsOverrides_TagOverride_REMOVE MetricsOverrides_TagOverride_Operation = 1
)

var MetricsOverrides_TagOverride_Operation_name = map[int32]string{
	0: "UPSERT",
	1: "REMOVE",
}

var MetricsOverrides_TagOverride_Operation_value = map[string]int32{
	"UPSERT": 0,
	"REMOVE": 1,
}

func (x MetricsOverrides_TagOverride_Operation) String() string {
	return proto.EnumName(MetricsOverrides_TagOverride_Operation_name, int32(x))
}

func (MetricsOverrides_TagOverride_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{5, 0, 0}
}

// <!-- crd generation tags
// +cue-gen:Telemetry:groupName:telemetry.istio.io
// +cue-gen:Telemetry:version:v1alpha1
// +cue-gen:Telemetry:storageVersion
// +cue-gen:Telemetry:annotations:helm.sh/resource-policy=keep
// +cue-gen:Telemetry:labels:app=istio-pilot,chart=istio,istio=telemetry,heritage=Tiller,release=istio
// +cue-gen:Telemetry:subresource:status
// +cue-gen:Telemetry:scope:Namespaced
// +cue-gen:Telemetry:resource:categories=istio-io,telemetry-istio-io,shortNames=telemetry,plural=telemetries
// +cue-gen:Telemetry:preserveUnknownFields:false
// +cue-gen:Telemetry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
// representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
// Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=telemetry.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Telemetry struct {
	// Optional. The selector decides where to apply the Telemetry policy.
	// If not set, the Telemetry policy will be applied to all workloads in the
	// same namespace as the Telemetry policy.
	Selector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Optional. Tracing configures the tracing behavior for all
	// selected workloads.
	Tracing []*Tracing `protobuf:"bytes,2,rep,name=tracing,proto3" json:"tracing,omitempty"`
	// Optional. Metrics configure the metrics behavior for all
	// selected workloads.
	Metrics []*Metrics `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics,omitempty"`
	// Optional. AccessLogging configures the access logging behavior for all
	// selected workloads.
	AccessLogging        []*AccessLogging `protobuf:"bytes,4,rep,name=access_logging,json=accessLogging,proto3" json:"access_logging,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Telemetry) Reset()         { *m = Telemetry{} }
func (m *Telemetry) String() string { return proto.CompactTextString(m) }
func (*Telemetry) ProtoMessage()    {}
func (*Telemetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{0}
}
func (m *Telemetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Telemetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Telemetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Telemetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Telemetry.Merge(m, src)
}
func (m *Telemetry) XXX_Size() int {
	return m.Size()
}
func (m *Telemetry) XXX_DiscardUnknown() {
	xxx_messageInfo_Telemetry.DiscardUnknown(m)
}

var xxx_messageInfo_Telemetry proto.InternalMessageInfo

func (m *Telemetry) GetSelector() *v1beta1.WorkloadSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *Telemetry) GetTracing() []*Tracing {
	if m != nil {
		return m.Tracing
	}
	return nil
}

func (m *Telemetry) GetMetrics() []*Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Telemetry) GetAccessLogging() []*AccessLogging {
	if m != nil {
		return m.AccessLogging
	}
	return nil
}

// Tracing configures tracing behavior for workloads within a mesh.
// It can be used to enable/disable tracing, as well as to set sampling
// rates and custom tag extraction.
//
// Tracing configuration support overrides of the fields `providers`,
// `random_sampling_percentage`, `disable_span_reporting`, and `custom_tags` at
// each level in the configuration hierarchy, with missing values filled in
// from parent resources. However, when specified, `custom_tags` will
// fully replace any values provided by parent configuration.
type Tracing struct {
	// Optional. Name of provider(s) to use for span reporting. If a provider is
	// not specified, the [default tracing provider][istio.mesh.v1alpha1.MeshConfig.default_providers.tracing]
	// will be used.
	// NOTE: At the moment, only a single provider can be specified in a given
	// Tracing rule.
	Providers []*ProviderRef `protobuf:"bytes,2,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls the rate at which traffic will be selected for tracing if no
	// prior sampling decision has been made. If a prior sampling decision has been
	// made, that decision will be respected. However, if no sampling decision
	// has been made (example: no `x-b3-sampled` tracing header was present in the
	// requests), the traffic will be selected for telemetry generation at the
	// percentage specified.
	//
	// Defaults to 0%. Valid values [0.00-100.00]. Can be specified in 0.01%
	// increments.
	RandomSamplingPercentage *types.DoubleValue `protobuf:"bytes,3,opt,name=random_sampling_percentage,json=randomSamplingPercentage,proto3" json:"random_sampling_percentage,omitempty"`
	// Controls span reporting. If set to true, no spans will be reported for
	// impacted workloads. This does NOT impact context propagation or trace
	// sampling behavior.
	DisableSpanReporting *types.BoolValue `protobuf:"bytes,4,opt,name=disable_span_reporting,json=disableSpanReporting,proto3" json:"disable_span_reporting,omitempty"`
	// Optional. Configures additional custom tags to the generated trace spans.
	CustomTags           map[string]*Tracing_CustomTag `protobuf:"bytes,5,rep,name=custom_tags,json=customTags,proto3" json:"custom_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *Tracing) Reset()         { *m = Tracing{} }
func (m *Tracing) String() string { return proto.CompactTextString(m) }
func (*Tracing) ProtoMessage()    {}
func (*Tracing) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1}
}
func (m *Tracing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing.Merge(m, src)
}
func (m *Tracing) XXX_Size() int {
	return m.Size()
}
func (m *Tracing) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing proto.InternalMessageInfo

func (m *Tracing) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Tracing) GetRandomSamplingPercentage() *types.DoubleValue {
	if m != nil {
		return m.RandomSamplingPercentage
	}
	return nil
}

func (m *Tracing) GetDisableSpanReporting() *types.BoolValue {
	if m != nil {
		return m.DisableSpanReporting
	}
	return nil
}

func (m *Tracing) GetCustomTags() map[string]*Tracing_CustomTag {
	if m != nil {
		return m.CustomTags
	}
	return nil
}

// CustomTag defines a tag to be added to a trace span that is based on
// an operator-supplied value. This value can either be a hard-coded value,
// a value taken from an environment variable known to the sidecar proxy, or
// from a request header.
//
// NOTE: when specified, `custom_tags` will fully replace any values provided
// by parent configuration.
type Tracing_CustomTag struct {
	// Types that are valid to be assigned to Type:
	//	*Tracing_CustomTag_Literal
	//	*Tracing_CustomTag_Environment
	//	*Tracing_CustomTag_Header
	Type                 isTracing_CustomTag_Type `protobuf_oneof:"type"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Tracing_CustomTag) Reset()         { *m = Tracing_CustomTag{} }
func (m *Tracing_CustomTag) String() string { return proto.CompactTextString(m) }
func (*Tracing_CustomTag) ProtoMessage()    {}
func (*Tracing_CustomTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 0}
}
func (m *Tracing_CustomTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_CustomTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_CustomTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_CustomTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_CustomTag.Merge(m, src)
}
func (m *Tracing_CustomTag) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_CustomTag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_CustomTag.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_CustomTag proto.InternalMessageInfo

type isTracing_CustomTag_Type interface {
	isTracing_CustomTag_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Tracing_CustomTag_Literal struct {
	Literal *Tracing_Literal `protobuf:"bytes,1,opt,name=literal,proto3,oneof" json:"literal,omitempty"`
}
type Tracing_CustomTag_Environment struct {
	Environment *Tracing_Environment `protobuf:"bytes,2,opt,name=environment,proto3,oneof" json:"environment,omitempty"`
}
type Tracing_CustomTag_Header struct {
	Header *Tracing_RequestHeader `protobuf:"bytes,3,opt,name=header,proto3,oneof" json:"header,omitempty"`
}

func (*Tracing_CustomTag_Literal) isTracing_CustomTag_Type()     {}
func (*Tracing_CustomTag_Environment) isTracing_CustomTag_Type() {}
func (*Tracing_CustomTag_Header) isTracing_CustomTag_Type()      {}

func (m *Tracing_CustomTag) GetType() isTracing_CustomTag_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Tracing_CustomTag) GetLiteral() *Tracing_Literal {
	if x, ok := m.GetType().(*Tracing_CustomTag_Literal); ok {
		return x.Literal
	}
	return nil
}

func (m *Tracing_CustomTag) GetEnvironment() *Tracing_Environment {
	if x, ok := m.GetType().(*Tracing_CustomTag_Environment); ok {
		return x.Environment
	}
	return nil
}

func (m *Tracing_CustomTag) GetHeader() *Tracing_RequestHeader {
	if x, ok := m.GetType().(*Tracing_CustomTag_Header); ok {
		return x.Header
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Tracing_CustomTag) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Tracing_CustomTag_Literal)(nil),
		(*Tracing_CustomTag_Environment)(nil),
		(*Tracing_CustomTag_Header)(nil),
	}
}

type Tracing_Literal struct {
	// The tag value to use.
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Literal) Reset()         { *m = Tracing_Literal{} }
func (m *Tracing_Literal) String() string { return proto.CompactTextString(m) }
func (*Tracing_Literal) ProtoMessage()    {}
func (*Tracing_Literal) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 1}
}
func (m *Tracing_Literal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Literal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Literal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Literal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Literal.Merge(m, src)
}
func (m *Tracing_Literal) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Literal) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Literal.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Literal proto.InternalMessageInfo

func (m *Tracing_Literal) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Tracing_Environment struct {
	// Name of the environment variable from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the environment variable is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_Environment) Reset()         { *m = Tracing_Environment{} }
func (m *Tracing_Environment) String() string { return proto.CompactTextString(m) }
func (*Tracing_Environment) ProtoMessage()    {}
func (*Tracing_Environment) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 2}
}
func (m *Tracing_Environment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_Environment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_Environment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_Environment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_Environment.Merge(m, src)
}
func (m *Tracing_Environment) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_Environment) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_Environment.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_Environment proto.InternalMessageInfo

func (m *Tracing_Environment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_Environment) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

type Tracing_RequestHeader struct {
	// Name of the header from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the header is not found, this value will be
	// used instead.
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tracing_RequestHeader) Reset()         { *m = Tracing_RequestHeader{} }
func (m *Tracing_RequestHeader) String() string { return proto.CompactTextString(m) }
func (*Tracing_RequestHeader) ProtoMessage()    {}
func (*Tracing_RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{1, 3}
}
func (m *Tracing_RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tracing_RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tracing_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tracing_RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tracing_RequestHeader.Merge(m, src)
}
func (m *Tracing_RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *Tracing_RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_Tracing_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_Tracing_RequestHeader proto.InternalMessageInfo

func (m *Tracing_RequestHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Tracing_RequestHeader) GetDefaultValue() string {
	if m != nil {
		return m.DefaultValue
	}
	return ""
}

// Used to bind Telemetry configuration to specific providers for
// targeted customization.
type ProviderRef struct {
	// Required. Name of Telemetry provider in MeshConfig.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProviderRef) Reset()         { *m = ProviderRef{} }
func (m *ProviderRef) String() string { return proto.CompactTextString(m) }
func (*ProviderRef) ProtoMessage()    {}
func (*ProviderRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{2}
}
func (m *ProviderRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProviderRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProviderRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProviderRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProviderRef.Merge(m, src)
}
func (m *ProviderRef) XXX_Size() int {
	return m.Size()
}
func (m *ProviderRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ProviderRef.DiscardUnknown(m)
}

var xxx_messageInfo_ProviderRef proto.InternalMessageInfo

func (m *ProviderRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Metrics defines the workload-level overrides for metrics generation behavior
// within a mesh. It can be used to enable/disable metrics generation, as well
// as to customize the dimensions of the generated metrics.
type Metrics struct {
	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default metrics provider][istio.mesh.v1alpha1.MeshConfig.default_providers.metrics]
	// will be used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Optional. Ordered list of overrides to metrics generation behavior.
	//
	// Specified overrides will be applied in order. They will be applied on
	// top of inherited overrides from other resources in the hierarchy in the
	// following order:
	// 1. Mesh-scoped overrides
	// 2. Namespace-scoped overrides
	// 3. Workload-scoped overrides
	//
	// Because overrides are applied in order, users are advised to order their
	// overrides from least specific to most specific matches. That is, it is
	// a best practice to list any universal overrides first, with tailored
	// overrides following them.
	Overrides            []*MetricsOverrides `protobuf:"bytes,2,rep,name=overrides,proto3" json:"overrides,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{3}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *Metrics) GetOverrides() []*MetricsOverrides {
	if m != nil {
		return m.Overrides
	}
	return nil
}

// Provides a mechanism for matching metrics for the application of override
// behaviors.
type MetricSelector struct {
	// Controls which metric(s) are selected by the selector.
	//
	// Types that are valid to be assigned to MetricMatch:
	//	*MetricSelector_Metric
	//	*MetricSelector_CustomMetric
	MetricMatch isMetricSelector_MetricMatch `protobuf_oneof:"metric_match"`
	// Controls which mode of metrics generation is selected: CLIENT and/or SERVER.
	Mode                 WorkloadMode `protobuf:"varint,3,opt,name=mode,proto3,enum=istio.telemetry.v1alpha1.WorkloadMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MetricSelector) Reset()         { *m = MetricSelector{} }
func (m *MetricSelector) String() string { return proto.CompactTextString(m) }
func (*MetricSelector) ProtoMessage()    {}
func (*MetricSelector) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{4}
}
func (m *MetricSelector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricSelector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricSelector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricSelector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricSelector.Merge(m, src)
}
func (m *MetricSelector) XXX_Size() int {
	return m.Size()
}
func (m *MetricSelector) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricSelector.DiscardUnknown(m)
}

var xxx_messageInfo_MetricSelector proto.InternalMessageInfo

type isMetricSelector_MetricMatch interface {
	isMetricSelector_MetricMatch()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MetricSelector_Metric struct {
	Metric MetricSelector_IstioMetric `protobuf:"varint,1,opt,name=metric,proto3,enum=istio.telemetry.v1alpha1.MetricSelector_IstioMetric,oneof" json:"metric,omitempty"`
}
type MetricSelector_CustomMetric struct {
	CustomMetric string `protobuf:"bytes,2,opt,name=custom_metric,json=customMetric,proto3,oneof" json:"custom_metric,omitempty"`
}

func (*MetricSelector_Metric) isMetricSelector_MetricMatch()       {}
func (*MetricSelector_CustomMetric) isMetricSelector_MetricMatch() {}

func (m *MetricSelector) GetMetricMatch() isMetricSelector_MetricMatch {
	if m != nil {
		return m.MetricMatch
	}
	return nil
}

func (m *MetricSelector) GetMetric() MetricSelector_IstioMetric {
	if x, ok := m.GetMetricMatch().(*MetricSelector_Metric); ok {
		return x.Metric
	}
	return MetricSelector_ALL_METRICS
}

func (m *MetricSelector) GetCustomMetric() string {
	if x, ok := m.GetMetricMatch().(*MetricSelector_CustomMetric); ok {
		return x.CustomMetric
	}
	return ""
}

func (m *MetricSelector) GetMode() WorkloadMode {
	if m != nil {
		return m.Mode
	}
	return WorkloadMode_CLIENT_AND_SERVER
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MetricSelector) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MetricSelector_Metric)(nil),
		(*MetricSelector_CustomMetric)(nil),
	}
}

// MetricsOverrides defines custom metric generation behavior for an individual
// metric or the set of all standard metrics.
type MetricsOverrides struct {
	// Match allows provides the scope of the override. It can be used to select
	// individual metrics, as well as the workload modes (server and/or client)
	// in which the metrics will be generated.
	//
	// If match is not specified, the overrides will apply to *all* metrics for
	// *both* modes of operation (client and server).
	Match *MetricSelector `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Optional. Must explicitly set this to "true" to turn off metrics reporting
	// for the listed metrics. If disabled has been set to "true" in a parent
	// configuration, it must explicitly be set to "false" to turn metrics
	// reporting on in the workloads selected by the Telemetry resource.
	Disabled *types.BoolValue `protobuf:"bytes,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Optional. Collection of tag names and tag expressions to override in the
	// selected metric(s).
	// The key in the map is the name of the tag.
	// The value in the map is the operation to perform on the the tag.
	// WARNING: some providers may not support adding/removing tags.
	// See also: https://istio.io/latest/docs/reference/config/metrics/#labels
	TagOverrides         map[string]*MetricsOverrides_TagOverride `protobuf:"bytes,3,rep,name=tag_overrides,json=tagOverrides,proto3" json:"tag_overrides,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                 `json:"-"`
	XXX_unrecognized     []byte                                   `json:"-"`
	XXX_sizecache        int32                                    `json:"-"`
}

func (m *MetricsOverrides) Reset()         { *m = MetricsOverrides{} }
func (m *MetricsOverrides) String() string { return proto.CompactTextString(m) }
func (*MetricsOverrides) ProtoMessage()    {}
func (*MetricsOverrides) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{5}
}
func (m *MetricsOverrides) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsOverrides) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsOverrides.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsOverrides) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsOverrides.Merge(m, src)
}
func (m *MetricsOverrides) XXX_Size() int {
	return m.Size()
}
func (m *MetricsOverrides) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsOverrides.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsOverrides proto.InternalMessageInfo

func (m *MetricsOverrides) GetMatch() *MetricSelector {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *MetricsOverrides) GetDisabled() *types.BoolValue {
	if m != nil {
		return m.Disabled
	}
	return nil
}

func (m *MetricsOverrides) GetTagOverrides() map[string]*MetricsOverrides_TagOverride {
	if m != nil {
		return m.TagOverrides
	}
	return nil
}

// TagOverride specifies an operation to perform on a metric dimension (also
// known as a `label`). Tags may be added, removed, or have their default
// values overridden.
type MetricsOverrides_TagOverride struct {
	// Operation controls whether or not to update/add a tag, or to remove it.
	Operation MetricsOverrides_TagOverride_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_TagOverride_Operation" json:"operation,omitempty"`
	// Value is only considered if the operation is `UPSERT`.
	// Values are [CEL expressions](https://opensource.google/projects/cel) over attributes.
	// Examples include: "string(destination.port)" and "request.host".
	// Istio exposes all standard [Envoy attributes](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes).
	// Additionally, Istio exposes node metadata as attributes.
	// More information is provided in the [customization docs](https://istio.io/latest/docs/tasks/observability/metrics/customize-metrics/#use-expressions-for-values).
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricsOverrides_TagOverride) Reset()         { *m = MetricsOverrides_TagOverride{} }
func (m *MetricsOverrides_TagOverride) String() string { return proto.CompactTextString(m) }
func (*MetricsOverrides_TagOverride) ProtoMessage()    {}
func (*MetricsOverrides_TagOverride) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{5, 0}
}
func (m *MetricsOverrides_TagOverride) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetricsOverrides_TagOverride) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetricsOverrides_TagOverride.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetricsOverrides_TagOverride) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsOverrides_TagOverride.Merge(m, src)
}
func (m *MetricsOverrides_TagOverride) XXX_Size() int {
	return m.Size()
}
func (m *MetricsOverrides_TagOverride) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsOverrides_TagOverride.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsOverrides_TagOverride proto.InternalMessageInfo

func (m *MetricsOverrides_TagOverride) GetOperation() MetricsOverrides_TagOverride_Operation {
	if m != nil {
		return m.Operation
	}
	return MetricsOverrides_TagOverride_UPSERT
}

func (m *MetricsOverrides_TagOverride) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Access logging defines the workload-level overrides for access log generation.
// It can be used to select provider or enable/disable access log generation for a workload.
type AccessLogging struct {
	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default logging provider][istio.mesh.v1alpha1.MeshConfig.default_providers.]
	// will be used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls logging. If set to true, no access logs will be generated for
	// impacted workloads (for the specified providers).
	// NOTE: currently default behavior will be controlled by the provider(s)
	// selected above. Customization controls will be added to this API in
	// future releases.
	Disabled *types.BoolValue `protobuf:"bytes,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Optional. Controls the format of the generated log records.
	// If not specified, the istio default logging format will be used.
	LogFormat            *LogFormat `protobuf:"bytes,3,opt,name=log_format,json=logFormat,proto3" json:"log_format,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AccessLogging) Reset()         { *m = AccessLogging{} }
func (m *AccessLogging) String() string { return proto.CompactTextString(m) }
func (*AccessLogging) ProtoMessage()    {}
func (*AccessLogging) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{6}
}
func (m *AccessLogging) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessLogging) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessLogging.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessLogging) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessLogging.Merge(m, src)
}
func (m *AccessLogging) XXX_Size() int {
	return m.Size()
}
func (m *AccessLogging) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessLogging.DiscardUnknown(m)
}

var xxx_messageInfo_AccessLogging proto.InternalMessageInfo

func (m *AccessLogging) GetProviders() []*ProviderRef {
	if m != nil {
		return m.Providers
	}
	return nil
}

func (m *AccessLogging) GetDisabled() *types.BoolValue {
	if m != nil {
		return m.Disabled
	}
	return nil
}

func (m *AccessLogging) GetLogFormat() *LogFormat {
	if m != nil {
		return m.LogFormat
	}
	return nil
}

// LogFormat provides control over the generated access log records.
// It adopts portions of the Open Telemetry model for record formatting,
// allowing mapping into various access logging providers.
type LogFormat struct {
	// Optional. A value containing the body of the log record. Valid uses include
	// a human-readable free-form string message and  structured data composed of arrays and maps
	// of other values.
	//
	// TODO(dougreid): discuss mapping into supported providers?
	//
	// Example: ``body { string_value: "%PROTOCOL%" }``.
	Body *AnyValue `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// Optional. Provides additional information about the specific event occurrence.
	// This can be used in structured logging scenarios to provide request context info
	// beyond what is included in the body.
	//
	// Example: ``attributes { values { key: "user_agent" value { string_value: "%REQ(USER-AGENT)%" } } }``.
	Attributes           *KeyValueList `protobuf:"bytes,2,opt,name=attributes,proto3" json:"attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LogFormat) Reset()         { *m = LogFormat{} }
func (m *LogFormat) String() string { return proto.CompactTextString(m) }
func (*LogFormat) ProtoMessage()    {}
func (*LogFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{7}
}
func (m *LogFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogFormat.Merge(m, src)
}
func (m *LogFormat) XXX_Size() int {
	return m.Size()
}
func (m *LogFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_LogFormat.DiscardUnknown(m)
}

var xxx_messageInfo_LogFormat proto.InternalMessageInfo

func (m *LogFormat) GetBody() *AnyValue {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *LogFormat) GetAttributes() *KeyValueList {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Taken from OTel ("opentelemetry/proto/common/v1/common.proto")
type AnyValue struct {
	// The value is one of the listed fields. It is valid for all values to be unspecified
	// in which case this AnyValue is considered to be "null".
	//
	// Types that are valid to be assigned to Value:
	//	*AnyValue_StringValue
	//	*AnyValue_BoolValue
	//	*AnyValue_IntValue
	//	*AnyValue_DoubleValue
	//	*AnyValue_ArrayValue
	//	*AnyValue_KvlistValue
	//	*AnyValue_BytesValue
	Value                isAnyValue_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AnyValue) Reset()         { *m = AnyValue{} }
func (m *AnyValue) String() string { return proto.CompactTextString(m) }
func (*AnyValue) ProtoMessage()    {}
func (*AnyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{8}
}
func (m *AnyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnyValue.Merge(m, src)
}
func (m *AnyValue) XXX_Size() int {
	return m.Size()
}
func (m *AnyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_AnyValue.DiscardUnknown(m)
}

var xxx_messageInfo_AnyValue proto.InternalMessageInfo

type isAnyValue_Value interface {
	isAnyValue_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AnyValue_StringValue struct {
	StringValue string `protobuf:"bytes,1,opt,name=string_value,json=stringValue,proto3,oneof" json:"string_value,omitempty"`
}
type AnyValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,2,opt,name=bool_value,json=boolValue,proto3,oneof" json:"bool_value,omitempty"`
}
type AnyValue_IntValue struct {
	IntValue int64 `protobuf:"varint,3,opt,name=int_value,json=intValue,proto3,oneof" json:"int_value,omitempty"`
}
type AnyValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,proto3,oneof" json:"double_value,omitempty"`
}
type AnyValue_ArrayValue struct {
	ArrayValue *ArrayValue `protobuf:"bytes,5,opt,name=array_value,json=arrayValue,proto3,oneof" json:"array_value,omitempty"`
}
type AnyValue_KvlistValue struct {
	KvlistValue *KeyValueList `protobuf:"bytes,6,opt,name=kvlist_value,json=kvlistValue,proto3,oneof" json:"kvlist_value,omitempty"`
}
type AnyValue_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,7,opt,name=bytes_value,json=bytesValue,proto3,oneof" json:"bytes_value,omitempty"`
}

func (*AnyValue_StringValue) isAnyValue_Value() {}
func (*AnyValue_BoolValue) isAnyValue_Value()   {}
func (*AnyValue_IntValue) isAnyValue_Value()    {}
func (*AnyValue_DoubleValue) isAnyValue_Value() {}
func (*AnyValue_ArrayValue) isAnyValue_Value()  {}
func (*AnyValue_KvlistValue) isAnyValue_Value() {}
func (*AnyValue_BytesValue) isAnyValue_Value()  {}

func (m *AnyValue) GetValue() isAnyValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *AnyValue) GetStringValue() string {
	if x, ok := m.GetValue().(*AnyValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *AnyValue) GetBoolValue() bool {
	if x, ok := m.GetValue().(*AnyValue_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *AnyValue) GetIntValue() int64 {
	if x, ok := m.GetValue().(*AnyValue_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *AnyValue) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*AnyValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *AnyValue) GetArrayValue() *ArrayValue {
	if x, ok := m.GetValue().(*AnyValue_ArrayValue); ok {
		return x.ArrayValue
	}
	return nil
}

func (m *AnyValue) GetKvlistValue() *KeyValueList {
	if x, ok := m.GetValue().(*AnyValue_KvlistValue); ok {
		return x.KvlistValue
	}
	return nil
}

func (m *AnyValue) GetBytesValue() []byte {
	if x, ok := m.GetValue().(*AnyValue_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AnyValue) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AnyValue_StringValue)(nil),
		(*AnyValue_BoolValue)(nil),
		(*AnyValue_IntValue)(nil),
		(*AnyValue_DoubleValue)(nil),
		(*AnyValue_ArrayValue)(nil),
		(*AnyValue_KvlistValue)(nil),
		(*AnyValue_BytesValue)(nil),
	}
}

// ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
// since oneof in AnyValue does not allow repeated fields.
//
// Taken from OTel ("opentelemetry/proto/common/v1/common.proto")
type ArrayValue struct {
	// Array of values. The array may be empty (contain 0 elements).
	Values               []*AnyValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ArrayValue) Reset()         { *m = ArrayValue{} }
func (m *ArrayValue) String() string { return proto.CompactTextString(m) }
func (*ArrayValue) ProtoMessage()    {}
func (*ArrayValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{9}
}
func (m *ArrayValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ArrayValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ArrayValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ArrayValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ArrayValue.Merge(m, src)
}
func (m *ArrayValue) XXX_Size() int {
	return m.Size()
}
func (m *ArrayValue) XXX_DiscardUnknown() {
	xxx_messageInfo_ArrayValue.DiscardUnknown(m)
}

var xxx_messageInfo_ArrayValue proto.InternalMessageInfo

func (m *ArrayValue) GetValues() []*AnyValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
// since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
// a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
// avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
// are semantically equivalent.
//
// Taken from OTel ("opentelemetry/proto/common/v1/common.proto")
type KeyValueList struct {
	// A collection of key/value pairs of key-value pairs. The list may be empty (may
	// contain 0 elements).
	Values               []*KeyValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *KeyValueList) Reset()         { *m = KeyValueList{} }
func (m *KeyValueList) String() string { return proto.CompactTextString(m) }
func (*KeyValueList) ProtoMessage()    {}
func (*KeyValueList) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{10}
}
func (m *KeyValueList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValueList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValueList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValueList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValueList.Merge(m, src)
}
func (m *KeyValueList) XXX_Size() int {
	return m.Size()
}
func (m *KeyValueList) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValueList.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValueList proto.InternalMessageInfo

func (m *KeyValueList) GetValues() []*KeyValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// KeyValue is a key-value pair that is used to store Span attributes, Link
// attributes, etc.
//
// Taken from OTel ("opentelemetry/proto/common/v1/common.proto")
type KeyValue struct {
	Key                  string    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                *AnyValue `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *KeyValue) Reset()         { *m = KeyValue{} }
func (m *KeyValue) String() string { return proto.CompactTextString(m) }
func (*KeyValue) ProtoMessage()    {}
func (*KeyValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_991c84745e2b7651, []int{11}
}
func (m *KeyValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyValue.Merge(m, src)
}
func (m *KeyValue) XXX_Size() int {
	return m.Size()
}
func (m *KeyValue) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyValue.DiscardUnknown(m)
}

var xxx_messageInfo_KeyValue proto.InternalMessageInfo

func (m *KeyValue) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KeyValue) GetValue() *AnyValue {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.telemetry.v1alpha1.WorkloadMode", WorkloadMode_name, WorkloadMode_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricSelector_IstioMetric", MetricSelector_IstioMetric_name, MetricSelector_IstioMetric_value)
	proto.RegisterEnum("istio.telemetry.v1alpha1.MetricsOverrides_TagOverride_Operation", MetricsOverrides_TagOverride_Operation_name, MetricsOverrides_TagOverride_Operation_value)
	proto.RegisterType((*Telemetry)(nil), "istio.telemetry.v1alpha1.Telemetry")
	proto.RegisterType((*Tracing)(nil), "istio.telemetry.v1alpha1.Tracing")
	proto.RegisterMapType((map[string]*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTagsEntry")
	proto.RegisterType((*Tracing_CustomTag)(nil), "istio.telemetry.v1alpha1.Tracing.CustomTag")
	proto.RegisterType((*Tracing_Literal)(nil), "istio.telemetry.v1alpha1.Tracing.Literal")
	proto.RegisterType((*Tracing_Environment)(nil), "istio.telemetry.v1alpha1.Tracing.Environment")
	proto.RegisterType((*Tracing_RequestHeader)(nil), "istio.telemetry.v1alpha1.Tracing.RequestHeader")
	proto.RegisterType((*ProviderRef)(nil), "istio.telemetry.v1alpha1.ProviderRef")
	proto.RegisterType((*Metrics)(nil), "istio.telemetry.v1alpha1.Metrics")
	proto.RegisterType((*MetricSelector)(nil), "istio.telemetry.v1alpha1.MetricSelector")
	proto.RegisterType((*MetricsOverrides)(nil), "istio.telemetry.v1alpha1.MetricsOverrides")
	proto.RegisterMapType((map[string]*MetricsOverrides_TagOverride)(nil), "istio.telemetry.v1alpha1.MetricsOverrides.TagOverridesEntry")
	proto.RegisterType((*MetricsOverrides_TagOverride)(nil), "istio.telemetry.v1alpha1.MetricsOverrides.TagOverride")
	proto.RegisterType((*AccessLogging)(nil), "istio.telemetry.v1alpha1.AccessLogging")
	proto.RegisterType((*LogFormat)(nil), "istio.telemetry.v1alpha1.LogFormat")
	proto.RegisterType((*AnyValue)(nil), "istio.telemetry.v1alpha1.AnyValue")
	proto.RegisterType((*ArrayValue)(nil), "istio.telemetry.v1alpha1.ArrayValue")
	proto.RegisterType((*KeyValueList)(nil), "istio.telemetry.v1alpha1.KeyValueList")
	proto.RegisterType((*KeyValue)(nil), "istio.telemetry.v1alpha1.KeyValue")
}

func init() {
	proto.RegisterFile("telemetry/v1alpha1/telemetry.proto", fileDescriptor_991c84745e2b7651)
}

var fileDescriptor_991c84745e2b7651 = []byte{
	// 1333 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x16, 0x65, 0x5b, 0xb2, 0x46, 0xb2, 0xc3, 0x2c, 0x92, 0x40, 0x3f, 0xfd, 0x5a, 0x27, 0xa1,
	0x9b, 0xd6, 0x4d, 0x11, 0x0a, 0x76, 0x8b, 0x20, 0x48, 0xff, 0x20, 0xb6, 0xcc, 0x44, 0x6a, 0x64,
	0x49, 0x59, 0xca, 0x2e, 0x9a, 0x43, 0x89, 0x95, 0xb4, 0x56, 0xd8, 0x50, 0x5c, 0x96, 0x5c, 0x29,
	0xd0, 0x13, 0xf4, 0xd0, 0x53, 0x4f, 0xed, 0x23, 0xf4, 0x51, 0x7a, 0xcc, 0xa9, 0xb7, 0x02, 0x45,
	0x8e, 0x7d, 0x82, 0x1e, 0x0b, 0x72, 0x77, 0x25, 0x3a, 0xb1, 0x23, 0xc7, 0xe8, 0x8d, 0x3b, 0xf3,
	0x7d, 0xdf, 0xcc, 0xfe, 0x99, 0xd9, 0x25, 0x18, 0x9c, 0x7a, 0x74, 0x44, 0x79, 0x38, 0xad, 0x4e,
	0xb6, 0x89, 0x17, 0x3c, 0x23, 0xdb, 0xd5, 0x99, 0xc9, 0x0c, 0x42, 0xc6, 0x19, 0x2a, 0xbb, 0x11,
	0x77, 0x99, 0x39, 0x37, 0x2b, 0x64, 0xe5, 0xff, 0x7c, 0x1a, 0xd0, 0xea, 0x64, 0xbb, 0x47, 0x39,
	0xd9, 0xae, 0x46, 0xd4, 0xa3, 0x7d, 0xce, 0x42, 0x41, 0xab, 0x6c, 0x0c, 0x19, 0x1b, 0x7a, 0xb4,
	0x9a, 0x8c, 0x7a, 0xe3, 0xe3, 0xea, 0x8b, 0x90, 0x04, 0x01, 0x0d, 0x23, 0xe1, 0x37, 0x7e, 0xc9,
	0x42, 0xa1, 0xab, 0x34, 0xd1, 0x03, 0x58, 0x55, 0xfc, 0xb2, 0x76, 0x43, 0xdb, 0x2a, 0xee, 0x7c,
	0x60, 0xca, 0xb8, 0xd3, 0x80, 0x9a, 0x32, 0x86, 0xf9, 0x0d, 0x0b, 0x9f, 0x7b, 0x8c, 0x0c, 0x6c,
	0x89, 0xc5, 0x33, 0x16, 0xfa, 0x1c, 0xf2, 0x3c, 0x24, 0x7d, 0xd7, 0x1f, 0x96, 0xb3, 0x37, 0x96,
	0xb6, 0x8a, 0x3b, 0x37, 0xcd, 0xb3, 0x12, 0x37, 0xbb, 0x02, 0x88, 0x15, 0x23, 0x26, 0xc7, 0x10,
	0xb7, 0x1f, 0x95, 0x97, 0x16, 0x91, 0x0f, 0x04, 0x10, 0x2b, 0x06, 0x6a, 0xc1, 0x3a, 0xe9, 0xf7,
	0x69, 0x14, 0x39, 0x1e, 0x1b, 0x0e, 0xe3, 0x04, 0x96, 0x13, 0x8d, 0x8f, 0xce, 0xd6, 0xd8, 0x4d,
	0xf0, 0x4d, 0x01, 0xc7, 0x6b, 0x24, 0x3d, 0x34, 0xfe, 0xce, 0x41, 0x5e, 0x66, 0x88, 0x6a, 0x50,
	0x08, 0x42, 0x36, 0x71, 0x07, 0x34, 0x8c, 0xe4, 0xbc, 0x6e, 0x9d, 0x2d, 0xdb, 0x91, 0x50, 0x4c,
	0x8f, 0xf1, 0x9c, 0x87, 0x9e, 0x42, 0x25, 0x24, 0xfe, 0x80, 0x8d, 0x9c, 0x88, 0x8c, 0x02, 0xcf,
	0xf5, 0x87, 0x4e, 0x40, 0xc3, 0x3e, 0xf5, 0x39, 0x19, 0xd2, 0xf2, 0x52, 0xb2, 0xdc, 0xef, 0x99,
	0x62, 0xbf, 0x4c, 0xb5, 0x5f, 0xe6, 0x3e, 0x1b, 0xf7, 0x3c, 0x7a, 0x44, 0xbc, 0x31, 0xc5, 0x65,
	0xc1, 0xb7, 0x25, 0xbd, 0x33, 0x63, 0xa3, 0x0e, 0x5c, 0x1b, 0xb8, 0x11, 0xe9, 0x79, 0xd4, 0x89,
	0x02, 0xe2, 0x3b, 0x21, 0x0d, 0x58, 0xc8, 0xc5, 0x22, 0xc4, 0xba, 0x95, 0x37, 0x74, 0xf7, 0x18,
	0xf3, 0x84, 0xea, 0x15, 0xc9, 0xb4, 0x03, 0xe2, 0x63, 0xc5, 0x43, 0x18, 0x8a, 0xfd, 0x71, 0xc4,
	0xd9, 0xc8, 0xe1, 0x64, 0x18, 0x95, 0x57, 0x92, 0x49, 0x6f, 0x2f, 0xdc, 0x4c, 0xb3, 0x96, 0x90,
	0xba, 0x64, 0x18, 0x59, 0x3e, 0x0f, 0xa7, 0x18, 0xfa, 0x33, 0x43, 0xe5, 0x1f, 0x0d, 0x0a, 0x33,
	0x3f, 0xb2, 0x20, 0xef, 0xb9, 0x9c, 0x86, 0xc4, 0x93, 0x67, 0xed, 0xe3, 0xc5, 0xea, 0x4d, 0x41,
	0xa8, 0x67, 0xb0, 0xe2, 0xa2, 0x27, 0x50, 0xa4, 0xfe, 0xc4, 0x0d, 0x99, 0x3f, 0xa2, 0x3e, 0x2f,
	0x67, 0x13, 0xa9, 0x3b, 0x8b, 0xa5, 0xac, 0x39, 0xa9, 0x9e, 0xc1, 0x69, 0x0d, 0xd4, 0x80, 0xdc,
	0x33, 0x4a, 0x06, 0x34, 0x94, 0xbb, 0x52, 0x5d, 0xac, 0x86, 0xe9, 0x0f, 0x63, 0x1a, 0xf1, 0x7a,
	0x42, 0xab, 0x67, 0xb0, 0x14, 0xd8, 0xcb, 0xc1, 0x72, 0x5c, 0x3a, 0x95, 0xeb, 0x90, 0x97, 0xb9,
	0xa3, 0x2b, 0xb0, 0x32, 0x89, 0x17, 0x3e, 0x99, 0x75, 0x01, 0x8b, 0x41, 0xe5, 0x21, 0x14, 0x53,
	0x19, 0x21, 0x04, 0xcb, 0x3e, 0x19, 0x29, 0x4c, 0xf2, 0x8d, 0x36, 0x61, 0x6d, 0x40, 0x8f, 0xc9,
	0xd8, 0xe3, 0x8e, 0x10, 0xc8, 0x26, 0xce, 0x92, 0x34, 0x26, 0xbb, 0x59, 0xa9, 0xc3, 0xda, 0x89,
	0x5c, 0x2e, 0xae, 0xf4, 0x3d, 0x5c, 0x7a, 0x6d, 0x33, 0x91, 0x0e, 0x4b, 0xcf, 0xe9, 0x54, 0x4a,
	0xc5, 0x9f, 0x68, 0x57, 0x4d, 0x46, 0xac, 0xfb, 0x27, 0xef, 0x70, 0x40, 0xe4, 0xcc, 0xef, 0x67,
	0xef, 0x69, 0xc6, 0x4d, 0x28, 0xa6, 0xaa, 0xe6, 0xb4, 0x9c, 0x8d, 0x5f, 0x35, 0xc8, 0xcb, 0xa2,
	0x3f, 0x59, 0x8f, 0xda, 0x05, 0xeb, 0xb1, 0x0e, 0x05, 0x36, 0xa1, 0x61, 0xe8, 0x0e, 0xa8, 0x2a,
	0xea, 0xdb, 0x0b, 0xfb, 0x4d, 0x5b, 0x31, 0xf0, 0x9c, 0x6c, 0xfc, 0xb9, 0x04, 0xeb, 0xc2, 0xaf,
	0x3a, 0x22, 0x6a, 0x41, 0x4e, 0x34, 0xa6, 0x64, 0x0e, 0xeb, 0x3b, 0x9f, 0x2d, 0x52, 0x56, 0x4c,
	0xb3, 0x11, 0xe3, 0x84, 0x2d, 0x3e, 0x47, 0x42, 0x05, 0xdd, 0x82, 0x35, 0x59, 0x8e, 0x52, 0x36,
	0xd9, 0xb1, 0x7a, 0x06, 0x97, 0x84, 0x59, 0x10, 0xd0, 0x7d, 0x58, 0x1e, 0xb1, 0x81, 0xe8, 0x26,
	0xeb, 0x3b, 0x1f, 0x9e, 0x1d, 0x54, 0xb5, 0xf0, 0x03, 0x36, 0xa0, 0x38, 0xe1, 0x18, 0x3f, 0x66,
	0xa1, 0x98, 0x0a, 0x8e, 0x2e, 0x41, 0x71, 0xb7, 0xd9, 0x74, 0x0e, 0xac, 0x2e, 0x6e, 0xd4, 0x6c,
	0x3d, 0x83, 0x2e, 0xc3, 0x1a, 0xb6, 0x9e, 0x1c, 0x5a, 0x76, 0xd7, 0xa9, 0xb5, 0x0f, 0x5b, 0x5d,
	0x5d, 0x43, 0x57, 0x40, 0x57, 0xa6, 0xfd, 0x43, 0xbc, 0xdb, 0x6d, 0xb4, 0x5b, 0x7a, 0x16, 0xe9,
	0x50, 0x52, 0x56, 0xbb, 0xf1, 0xd4, 0xd2, 0x97, 0x04, 0xd5, 0xee, 0xb4, 0x5b, 0xb6, 0x25, 0x4c,
	0xcb, 0xa8, 0x02, 0xd7, 0xba, 0xb5, 0x8e, 0xd3, 0xee, 0x58, 0x2d, 0x6b, 0xdf, 0xa9, 0xb5, 0x5b,
	0x2d, 0xab, 0x16, 0xf3, 0x6d, 0x7d, 0x45, 0xf9, 0x6a, 0xcd, 0xb6, 0xfd, 0x9a, 0x2f, 0x87, 0x10,
	0xac, 0xc7, 0x3e, 0xdb, 0x6a, 0x75, 0x9d, 0xbd, 0x6f, 0xbb, 0x96, 0xad, 0xe7, 0xd1, 0x35, 0x40,
	0xb1, 0x0d, 0x5b, 0x35, 0xab, 0x71, 0x64, 0xed, 0x4b, 0xfb, 0x2a, 0xfa, 0x1f, 0x5c, 0x7d, 0x84,
	0x3b, 0x35, 0x47, 0x65, 0x73, 0x60, 0xd9, 0xf6, 0xee, 0x23, 0xcb, 0xd6, 0x0b, 0x71, 0x08, 0xe9,
	0x92, 0x69, 0xcd, 0x7c, 0xb0, 0xb7, 0x0e, 0x25, 0xb1, 0xca, 0xce, 0x88, 0xf0, 0xfe, 0x33, 0xe3,
	0xe7, 0x65, 0xd0, 0x5f, 0xdf, 0x7f, 0xf4, 0x15, 0xac, 0x24, 0x5e, 0xd9, 0xbc, 0xb6, 0xce, 0xbb,
	0xc1, 0x58, 0xd0, 0xd0, 0x5d, 0x58, 0x95, 0x8d, 0x77, 0x20, 0x8b, 0xe7, 0x6d, 0x4d, 0x7a, 0x86,
	0x45, 0x04, 0xd6, 0x38, 0x19, 0x3a, 0xf3, 0xa3, 0x2b, 0xae, 0xca, 0x2f, 0xce, 0x7f, 0x74, 0xcd,
	0x2e, 0x19, 0xce, 0x06, 0xa2, 0x4b, 0x97, 0x78, 0xca, 0x54, 0xf9, 0x4d, 0x83, 0x62, 0x0a, 0x83,
	0xbe, 0x83, 0x02, 0x0b, 0x68, 0x48, 0xb8, 0xcb, 0x7c, 0x79, 0x9e, 0x1f, 0x5c, 0x2c, 0x9c, 0xd9,
	0x56, 0x3a, 0x78, 0x2e, 0x39, 0xef, 0x88, 0xd9, 0x54, 0x47, 0x34, 0x36, 0xa1, 0x30, 0x43, 0x23,
	0x80, 0xdc, 0x61, 0xc7, 0xb6, 0x70, 0x57, 0xcf, 0xc4, 0xdf, 0xd8, 0x3a, 0x68, 0x1f, 0x59, 0xba,
	0x56, 0x79, 0x01, 0x97, 0xdf, 0x98, 0xcd, 0x29, 0x6d, 0xaa, 0x79, 0xb2, 0x4d, 0xdd, 0xbd, 0x58,
	0xf6, 0xe9, 0x8e, 0xf5, 0x52, 0x83, 0xb5, 0x13, 0xef, 0x87, 0xff, 0xa6, 0x29, 0x5d, 0xf4, 0x54,
	0xec, 0x01, 0x78, 0x6c, 0xe8, 0x1c, 0xb3, 0x70, 0x44, 0xb8, 0xbc, 0xb6, 0x36, 0xcf, 0x8e, 0xde,
	0x64, 0xc3, 0x87, 0x09, 0x14, 0x17, 0x3c, 0xf5, 0x69, 0xfc, 0xa4, 0x41, 0x61, 0xe6, 0x40, 0x77,
	0x61, 0xb9, 0xc7, 0x06, 0x53, 0x79, 0xbc, 0x8d, 0xb7, 0xbc, 0xa2, 0xfc, 0xa9, 0xc8, 0x26, 0xc1,
	0xa3, 0x87, 0x00, 0x84, 0xf3, 0xd0, 0xed, 0x8d, 0x79, 0xd2, 0x57, 0x63, 0xf6, 0x5b, 0x1a, 0xd1,
	0x63, 0x2a, 0xd8, 0x4d, 0x37, 0xe2, 0x38, 0xc5, 0x34, 0xfe, 0xc8, 0xc2, 0xaa, 0x92, 0x46, 0x9b,
	0x50, 0x8a, 0x78, 0x18, 0x3f, 0x99, 0x52, 0x57, 0x67, 0x7c, 0x6d, 0x0b, 0xab, 0x00, 0x5d, 0x07,
	0xe8, 0x31, 0xe6, 0xa5, 0xae, 0xb4, 0xd5, 0x7a, 0x06, 0x17, 0x7a, 0x6a, 0xb9, 0xd0, 0xfb, 0x50,
	0x70, 0x7d, 0x75, 0xe5, 0xc5, 0x6b, 0xb4, 0x54, 0xcf, 0xe0, 0x55, 0xd7, 0xe7, 0xb3, 0x20, 0x83,
	0xe4, 0xb5, 0x25, 0x11, 0xf1, 0xd3, 0x49, 0x8b, 0x83, 0x0c, 0xe6, 0x6f, 0x30, 0xf4, 0x08, 0x8a,
	0x24, 0x0c, 0xc9, 0x54, 0x62, 0x56, 0x4e, 0xbe, 0x92, 0x4f, 0x59, 0x9d, 0x18, 0x9c, 0x50, 0xeb,
	0x19, 0x0c, 0x64, 0x36, 0x42, 0x8f, 0xa1, 0xf4, 0x7c, 0xe2, 0xb9, 0x91, 0xca, 0x27, 0xf7, 0x2e,
	0x2b, 0x15, 0x67, 0x25, 0xd8, 0x42, 0xec, 0x26, 0x14, 0x7b, 0x53, 0x4e, 0x23, 0xa9, 0x95, 0xbf,
	0xa1, 0x6d, 0x95, 0xe2, 0x78, 0x89, 0x31, 0x81, 0xec, 0xe5, 0x65, 0x09, 0x18, 0x75, 0x80, 0x79,
	0x52, 0xe8, 0x3e, 0xe4, 0x12, 0xb3, 0x3a, 0xb2, 0xe7, 0xd9, 0x68, 0xc9, 0x30, 0xbe, 0x86, 0x52,
	0x3a, 0xa9, 0x77, 0xd1, 0x52, 0xbc, 0x99, 0xd6, 0x11, 0xac, 0x2a, 0xdb, 0x29, 0xf5, 0x7b, 0xef,
	0x64, 0xfd, 0x9e, 0x27, 0x49, 0x41, 0xb8, 0xfd, 0x25, 0x94, 0xd2, 0x77, 0x1d, 0xba, 0x0a, 0x97,
	0x6b, 0xcd, 0x46, 0x7c, 0x79, 0xec, 0xb6, 0xf6, 0x1d, 0xdb, 0xc2, 0x47, 0x16, 0x16, 0x3d, 0x45,
	0x98, 0x75, 0x2d, 0xfe, 0x96, 0xf6, 0xec, 0xde, 0x9d, 0xdf, 0x5f, 0x6d, 0x68, 0x2f, 0x5f, 0x6d,
	0x68, 0x7f, 0xbd, 0xda, 0xd0, 0x9e, 0x5e, 0x17, 0x61, 0x5d, 0x56, 0x25, 0x81, 0x5b, 0x7d, 0xf3,
	0xaf, 0xad, 0x97, 0x4b, 0x8a, 0xf4, 0xd3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xe8, 0x82,
	0x07, 0xd2, 0x0d, 0x00, 0x00,
}

func (m *Telemetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Telemetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Telemetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AccessLogging) > 0 {
		for iNdEx := len(m.AccessLogging) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AccessLogging[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Metrics) > 0 {
		for iNdEx := len(m.Metrics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Metrics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Tracing) > 0 {
		for iNdEx := len(m.Tracing) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tracing[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Selector != nil {
		{
			size, err := m.Selector.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CustomTags) > 0 {
		for k := range m.CustomTags {
			v := m.CustomTags[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTelemetry(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.DisableSpanReporting != nil {
		{
			size, err := m.DisableSpanReporting.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.RandomSamplingPercentage != nil {
		{
			size, err := m.RandomSamplingPercentage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_CustomTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_CustomTag_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Literal != nil {
		{
			size, err := m.Literal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Environment != nil {
		{
			size, err := m.Environment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_CustomTag_Header) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_CustomTag_Header) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Tracing_Literal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Literal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Literal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_Environment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_Environment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_Environment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tracing_RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tracing_RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tracing_RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DefaultValue) > 0 {
		i -= len(m.DefaultValue)
		copy(dAtA[i:], m.DefaultValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.DefaultValue)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProviderRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProviderRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProviderRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Overrides) > 0 {
		for iNdEx := len(m.Overrides) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Overrides[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricSelector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSelector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Mode != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x18
	}
	if m.MetricMatch != nil {
		{
			size := m.MetricMatch.Size()
			i -= size
			if _, err := m.MetricMatch.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MetricSelector_Metric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSelector_Metric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTelemetry(dAtA, i, uint64(m.Metric))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}
func (m *MetricSelector_CustomMetric) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricSelector_CustomMetric) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CustomMetric)
	copy(dAtA[i:], m.CustomMetric)
	i = encodeVarintTelemetry(dAtA, i, uint64(len(m.CustomMetric)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *MetricsOverrides) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsOverrides) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsOverrides) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TagOverrides) > 0 {
		for k := range m.TagOverrides {
			v := m.TagOverrides[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintTelemetry(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTelemetry(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTelemetry(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Match != nil {
		{
			size, err := m.Match.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MetricsOverrides_TagOverride) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetricsOverrides_TagOverride) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetricsOverrides_TagOverride) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Operation != 0 {
		i = encodeVarintTelemetry(dAtA, i, uint64(m.Operation))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AccessLogging) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessLogging) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessLogging) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogFormat != nil {
		{
			size, err := m.LogFormat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Disabled != nil {
		{
			size, err := m.Disabled.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Providers) > 0 {
		for iNdEx := len(m.Providers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Providers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LogFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Attributes != nil {
		{
			size, err := m.Attributes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Body != nil {
		{
			size, err := m.Body.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AnyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *AnyValue_StringValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_StringValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.StringValue)
	copy(dAtA[i:], m.StringValue)
	i = encodeVarintTelemetry(dAtA, i, uint64(len(m.StringValue)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *AnyValue_BoolValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_BoolValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.BoolValue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *AnyValue_IntValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_IntValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTelemetry(dAtA, i, uint64(m.IntValue))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *AnyValue_DoubleValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_DoubleValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= 8
	encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.DoubleValue))))
	i--
	dAtA[i] = 0x21
	return len(dAtA) - i, nil
}
func (m *AnyValue_ArrayValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_ArrayValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ArrayValue != nil {
		{
			size, err := m.ArrayValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *AnyValue_KvlistValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_KvlistValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KvlistValue != nil {
		{
			size, err := m.KvlistValue.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *AnyValue_BytesValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnyValue_BytesValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BytesValue != nil {
		i -= len(m.BytesValue)
		copy(dAtA[i:], m.BytesValue)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.BytesValue)))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ArrayValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ArrayValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ArrayValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyValueList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValueList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValueList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTelemetry(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTelemetry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintTelemetry(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTelemetry(dAtA []byte, offset int, v uint64) int {
	offset -= sovTelemetry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Telemetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selector != nil {
		l = m.Selector.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.Tracing) > 0 {
		for _, e := range m.Tracing {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.AccessLogging) > 0 {
		for _, e := range m.AccessLogging {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.RandomSamplingPercentage != nil {
		l = m.RandomSamplingPercentage.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.DisableSpanReporting != nil {
		l = m.DisableSpanReporting.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.CustomTags) > 0 {
		for k, v := range m.CustomTags {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTelemetry(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_CustomTag_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Literal != nil {
		l = m.Literal.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Environment != nil {
		l = m.Environment.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_CustomTag_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *Tracing_Literal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_Environment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Tracing_RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProviderRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if len(m.Overrides) > 0 {
		for _, e := range m.Overrides {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricSelector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetricMatch != nil {
		n += m.MetricMatch.Size()
	}
	if m.Mode != 0 {
		n += 1 + sovTelemetry(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricSelector_Metric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTelemetry(uint64(m.Metric))
	return n
}
func (m *MetricSelector_CustomMetric) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomMetric)
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}
func (m *MetricsOverrides) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Match != nil {
		l = m.Match.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if len(m.TagOverrides) > 0 {
		for k, v := range m.TagOverrides {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTelemetry(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTelemetry(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTelemetry(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetricsOverrides_TagOverride) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operation != 0 {
		n += 1 + sovTelemetry(uint64(m.Operation))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccessLogging) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Providers) > 0 {
		for _, e := range m.Providers {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.Disabled != nil {
		l = m.Disabled.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.LogFormat != nil {
		l = m.LogFormat.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		l = m.Body.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Attributes != nil {
		l = m.Attributes.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnyValue_StringValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StringValue)
	n += 1 + l + sovTelemetry(uint64(l))
	return n
}
func (m *AnyValue_BoolValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *AnyValue_IntValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTelemetry(uint64(m.IntValue))
	return n
}
func (m *AnyValue_DoubleValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 9
	return n
}
func (m *AnyValue_ArrayValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ArrayValue != nil {
		l = m.ArrayValue.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *AnyValue_KvlistValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KvlistValue != nil {
		l = m.KvlistValue.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *AnyValue_BytesValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovTelemetry(uint64(l))
	}
	return n
}
func (m *ArrayValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValueList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovTelemetry(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovTelemetry(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTelemetry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTelemetry(x uint64) (n int) {
	return sovTelemetry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Telemetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Telemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Telemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selector == nil {
				m.Selector = &v1beta1.WorkloadSelector{}
			}
			if err := m.Selector.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tracing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tracing = append(m.Tracing, &Tracing{})
			if err := m.Tracing[len(m.Tracing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &Metrics{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessLogging", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessLogging = append(m.AccessLogging, &AccessLogging{})
			if err := m.AccessLogging[len(m.AccessLogging)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tracing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tracing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomSamplingPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomSamplingPercentage == nil {
				m.RandomSamplingPercentage = &types.DoubleValue{}
			}
			if err := m.RandomSamplingPercentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableSpanReporting", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DisableSpanReporting == nil {
				m.DisableSpanReporting = &types.BoolValue{}
			}
			if err := m.DisableSpanReporting.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CustomTags == nil {
				m.CustomTags = make(map[string]*Tracing_CustomTag)
			}
			var mapkey string
			var mapvalue *Tracing_CustomTag
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTelemetry
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Tracing_CustomTag{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CustomTags[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_CustomTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Literal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Literal{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_Environment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Environment{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tracing_RequestHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Tracing_CustomTag_Header{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Literal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Literal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Literal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_Environment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Environment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Environment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tracing_RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProviderRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProviderRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProviderRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Overrides = append(m.Overrides, &MetricsOverrides{})
			if err := m.Overrides[len(m.Overrides)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var v MetricSelector_IstioMetric
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= MetricSelector_IstioMetric(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MetricMatch = &MetricSelector_Metric{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomMetric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetricMatch = &MetricSelector_CustomMetric{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= WorkloadMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsOverrides) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricsOverrides: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricsOverrides: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Match == nil {
				m.Match = &MetricSelector{}
			}
			if err := m.Match.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disabled == nil {
				m.Disabled = &types.BoolValue{}
			}
			if err := m.Disabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagOverrides", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TagOverrides == nil {
				m.TagOverrides = make(map[string]*MetricsOverrides_TagOverride)
			}
			var mapkey string
			var mapvalue *MetricsOverrides_TagOverride
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTelemetry
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTelemetry
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTelemetry
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTelemetry
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MetricsOverrides_TagOverride{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTelemetry(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTelemetry
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TagOverrides[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricsOverrides_TagOverride) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagOverride: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagOverride: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			m.Operation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operation |= MetricsOverrides_TagOverride_Operation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessLogging) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessLogging: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessLogging: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Providers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Providers = append(m.Providers, &ProviderRef{})
			if err := m.Providers[len(m.Providers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Disabled == nil {
				m.Disabled = &types.BoolValue{}
			}
			if err := m.Disabled.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogFormat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogFormat == nil {
				m.LogFormat = &LogFormat{}
			}
			if err := m.LogFormat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Body == nil {
				m.Body = &AnyValue{}
			}
			if err := m.Body.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Attributes == nil {
				m.Attributes = &KeyValueList{}
			}
			if err := m.Attributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &AnyValue_StringValue{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &AnyValue_BoolValue{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &AnyValue_IntValue{v}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &AnyValue_DoubleValue{float64(math.Float64frombits(v))}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrayValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ArrayValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AnyValue_ArrayValue{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvlistValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &KeyValueList{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &AnyValue_KvlistValue{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Value = &AnyValue_BytesValue{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ArrayValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ArrayValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ArrayValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &AnyValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValueList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValueList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValueList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &KeyValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTelemetry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTelemetry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &AnyValue{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTelemetry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTelemetry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTelemetry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTelemetry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTelemetry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTelemetry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTelemetry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTelemetry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTelemetry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTelemetry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTelemetry = fmt.Errorf("proto: unexpected end of group")
)
