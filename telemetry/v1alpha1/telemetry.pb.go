// Copyright Istio Authors
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        (unknown)
// source: telemetry/v1alpha1/telemetry.proto

// $schema: istio.telemetry.v1alpha1.Telemetry
// $title: Telemetry
// $description: Telemetry configuration for workloads.
// $location: https://istio.io/docs/reference/config/telemetry.html
// $aliases: [/docs/reference/config/telemetry/v1alpha1/telemetry]

// Telemetry defines how the telemetry is generated for workloads within a mesh.
//
// For mesh level configuration, put the resource in root configuration
// namespace for your Istio installation *without* a workload selector.
//
// For any namespace, including the root configuration namespace, it is only
// valid to have a single workload selector-less Telemetry resource.
//
// For resources with a workload selector, it is only valid to have one resource
// selecting any given workload.
//
// The hierarchy of Telemetry configuration is as follows:
//
// 1. Workload-specific configuration
// 2. Namespace-specific configuration
// 3. Root namespace configuration
//
// Examples:
//
// Policy to enable random sampling for 10% of traffic:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   tracing:
//   - randomSamplingPercentage: 10.00
// ```
//
// Policy to disable trace reporting for the "foo" workload (note: tracing
// context will still be propagated):
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing
//   namespace: bar
// spec:
//   selector:
//     matchLabels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - disableSpanReporting: true
// ```
//
// Policy to select the alternate zipkin provider for trace reporting:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: foo-tracing-alternate
//   namespace: baz
// spec:
//   selector:
//     matchLabels:
//       service.istio.io/canonical-name: foo
//   tracing:
//   - providers:
//     - name: "zipkin-alternate"
//     randomSamplingPercentage: 10.00
// ```
//
// Policy to add a custom tag from a literal value:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   tracing:
//   - randomSamplingPercentage: 10.00
//     customTags:
//       my_new_foo_tag:
//         literal:
//           value: "foo"
// ```
//
// Policy to disable server-side metrics for Stackdriver for an entire mesh:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   metrics:
//   - providers:
//     - name: stackdriver
//     overrides:
//     - match:
//         metric: ALL_METRICS
//         mode: SERVER
//       disabled: true
// ```
//
// Policy to add dimensions to all Prometheus metrics for the `foo` namespace:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: namespace-metrics
//   namespace: foo
// spec:
//   # no selector specified, applies to all workloads in the namespace
//   metrics:
//   - providers:
//     - name: prometheus
//     overrides:
//     # match clause left off matches all istio metrics, client and server
//     - tagOverrides:
//         request_method:
//           value: "request.method"
//         request_host:
//           value: "request.host"
// ```
//
// Policy to remove the response_code dimension on some Prometheus metrics for
// the `bar.foo` workload:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: remove-response-code
//   namespace: foo
// spec:
//   selector:
//     matchLabels:
//       service.istio.io/canonical-name: bar
//   metrics:
//   - providers:
//     - name: prometheus
//     overrides:
//     - match:
//         metric: REQUEST_COUNT
//       tagOverrides:
//         response_code:
//           operation: REMOVE
//     - match:
//         metric: REQUEST_DURATION
//       tagOverrides:
//         response_code:
//           operation: REMOVE
//     - match:
//         metric: REQUEST_SIZE
//       tagOverrides:
//         response_code:
//           operation: REMOVE
//     - match:
//         metric: RESPONSE_SIZE
//       tagOverrides:
//         response_code:
//           operation: REMOVE
// ```
//
// Policy to enable access logging for the entire mesh:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: mesh-default
//   namespace: istio-system
// spec:
//   # no selector specified, applies to all workloads
//   accessLogging:
//   - providers:
//     - name: envoy
//     # By default, this turns on access logging (no need to set `disabled: false`).
//     # Unspecified `disabled` will be treated as `disabled: false`, except in
//     # cases where a parent configuration has marked as `disabled: true`. In
//     # those cases, `disabled: false` must be set explicitly to override.
// ```
//
// Policy to disable access logging for the `foo` namespace:
// ```yaml
// apiVersion: telemetry.istio.io/v1alpha1
// kind: Telemetry
// metadata:
//   name: namespace-no-log
//   namespace: foo
// spec:
//   # no selector specified, applies to all workloads in the namespace
//   accessLogging:
//   - disabled: true
// ```
//

package v1alpha1

import (
	duration "github.com/golang/protobuf/ptypes/duration"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	v1beta1 "istio.io/api/type/v1beta1"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WorkloadMode allows selection of the role of the underlying workload in
// network traffic. A workload is considered as acting as a SERVER if it is
// the destination of the traffic (that is, traffic direction, from the
// perspective of the workload is *inbound*). If the workload is the source of
// the network traffic, it is considered to be in CLIENT mode (traffic is
// *outbound* from the workload).
type WorkloadMode int32

const (
	// Selects for scenarios when the workload is either the
	// source or destination of the network traffic.
	WorkloadMode_CLIENT_AND_SERVER WorkloadMode = 0
	// Selects for scenarios when the workload is the
	// source of the network traffic.
	WorkloadMode_CLIENT WorkloadMode = 1
	// Selects for scenarios when the workload is the
	// destination of the network traffic.
	WorkloadMode_SERVER WorkloadMode = 2
)

// Enum value maps for WorkloadMode.
var (
	WorkloadMode_name = map[int32]string{
		0: "CLIENT_AND_SERVER",
		1: "CLIENT",
		2: "SERVER",
	}
	WorkloadMode_value = map[string]int32{
		"CLIENT_AND_SERVER": 0,
		"CLIENT":            1,
		"SERVER":            2,
	}
)

func (x WorkloadMode) Enum() *WorkloadMode {
	p := new(WorkloadMode)
	*p = x
	return p
}

func (x WorkloadMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (WorkloadMode) Descriptor() protoreflect.EnumDescriptor {
	return file_telemetry_v1alpha1_telemetry_proto_enumTypes[0].Descriptor()
}

func (WorkloadMode) Type() protoreflect.EnumType {
	return &file_telemetry_v1alpha1_telemetry_proto_enumTypes[0]
}

func (x WorkloadMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use WorkloadMode.Descriptor instead.
func (WorkloadMode) EnumDescriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{0}
}

// Curated list of known metric types that is supported by Istio metric
// providers. See also:
// https://istio.io/latest/docs/reference/config/metrics/#metrics
type MetricSelector_IstioMetric int32

const (
	// Use of this enum indicates that the override should apply to all Istio
	// default metrics.
	MetricSelector_ALL_METRICS MetricSelector_IstioMetric = 0
	// Counter of requests to/from an application, generated for HTTP, HTTP/2,
	// and GRPC traffic.
	//
	// The Prometheus provider exports this metric as: `istio_requests_total`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/request_count` (SERVER mode)
	// - `istio.io/service/client/request_count` (CLIENT mode)
	MetricSelector_REQUEST_COUNT MetricSelector_IstioMetric = 1
	// Histogram of request durations, generated for HTTP, HTTP/2, and GRPC
	// traffic.
	//
	// The Prometheus provider exports this metric as:
	// `istio_request_duration_milliseconds`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/response_latencies` (SERVER mode)
	// - `istio.io/service/client/roundtrip_latencies` (CLIENT mode)
	MetricSelector_REQUEST_DURATION MetricSelector_IstioMetric = 2
	// Histogram of request body sizes, generated for HTTP, HTTP/2, and GRPC
	// traffic.
	//
	// The Prometheus provider exports this metric as: `istio_request_bytes`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/request_bytes` (SERVER mode)
	// - `istio.io/service/client/request_bytes` (CLIENT mode)
	MetricSelector_REQUEST_SIZE MetricSelector_IstioMetric = 3
	// Histogram of response body sizes, generated for HTTP, HTTP/2, and GRPC
	// traffic.
	//
	// The Prometheus provider exports this metric as: `istio_response_bytes`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/response_bytes` (SERVER mode)
	// - `istio.io/service/client/response_bytes` (CLIENT mode)
	MetricSelector_RESPONSE_SIZE MetricSelector_IstioMetric = 4
	// Counter of TCP connections opened over lifetime of workload.
	//
	// The Prometheus provider exports this metric as:
	// `istio_tcp_connections_opened_total`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/connection_open_count` (SERVER mode)
	// - `istio.io/service/client/connection_open_count` (CLIENT mode)
	MetricSelector_TCP_OPENED_CONNECTIONS MetricSelector_IstioMetric = 5
	// Counter of TCP connections closed over lifetime of workload.
	//
	// The Prometheus provider exports this metric as:
	// `istio_tcp_connections_closed_total`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/connection_close_count` (SERVER mode)
	// - `istio.io/service/client/connection_close_count` (CLIENT mode)
	MetricSelector_TCP_CLOSED_CONNECTIONS MetricSelector_IstioMetric = 6
	// Counter of bytes sent during a response over a TCP connection.
	//
	// The Prometheus provider exports this metric as:
	// `istio_tcp_sent_bytes_total`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/sent_bytes_count` (SERVER mode)
	// - `istio.io/service/client/sent_bytes_count` (CLIENT mode)
	MetricSelector_TCP_SENT_BYTES MetricSelector_IstioMetric = 7
	// Counter of bytes received during a request over a TCP connection.
	//
	// The Prometheus provider exports this metric as:
	// `istio_tcp_received_bytes_total`.
	//
	// The Stackdriver provider exports this metric as:
	//
	// - `istio.io/service/server/received_bytes_count` (SERVER mode)
	// - `istio.io/service/client/received_bytes_count` (CLIENT mode)
	MetricSelector_TCP_RECEIVED_BYTES MetricSelector_IstioMetric = 8
	// Counter incremented for every gRPC messages sent from a client.
	//
	// The Prometheus provider exports this metric as:
	// `istio_request_messages_total`
	MetricSelector_GRPC_REQUEST_MESSAGES MetricSelector_IstioMetric = 9
	// Counter incremented for every gRPC messages sent from a server.
	//
	// The Prometheus provider exports this metric as:
	// `istio_response_messages_total`
	MetricSelector_GRPC_RESPONSE_MESSAGES MetricSelector_IstioMetric = 10
)

// Enum value maps for MetricSelector_IstioMetric.
var (
	MetricSelector_IstioMetric_name = map[int32]string{
		0:  "ALL_METRICS",
		1:  "REQUEST_COUNT",
		2:  "REQUEST_DURATION",
		3:  "REQUEST_SIZE",
		4:  "RESPONSE_SIZE",
		5:  "TCP_OPENED_CONNECTIONS",
		6:  "TCP_CLOSED_CONNECTIONS",
		7:  "TCP_SENT_BYTES",
		8:  "TCP_RECEIVED_BYTES",
		9:  "GRPC_REQUEST_MESSAGES",
		10: "GRPC_RESPONSE_MESSAGES",
	}
	MetricSelector_IstioMetric_value = map[string]int32{
		"ALL_METRICS":            0,
		"REQUEST_COUNT":          1,
		"REQUEST_DURATION":       2,
		"REQUEST_SIZE":           3,
		"RESPONSE_SIZE":          4,
		"TCP_OPENED_CONNECTIONS": 5,
		"TCP_CLOSED_CONNECTIONS": 6,
		"TCP_SENT_BYTES":         7,
		"TCP_RECEIVED_BYTES":     8,
		"GRPC_REQUEST_MESSAGES":  9,
		"GRPC_RESPONSE_MESSAGES": 10,
	}
)

func (x MetricSelector_IstioMetric) Enum() *MetricSelector_IstioMetric {
	p := new(MetricSelector_IstioMetric)
	*p = x
	return p
}

func (x MetricSelector_IstioMetric) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MetricSelector_IstioMetric) Descriptor() protoreflect.EnumDescriptor {
	return file_telemetry_v1alpha1_telemetry_proto_enumTypes[1].Descriptor()
}

func (MetricSelector_IstioMetric) Type() protoreflect.EnumType {
	return &file_telemetry_v1alpha1_telemetry_proto_enumTypes[1]
}

func (x MetricSelector_IstioMetric) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MetricSelector_IstioMetric.Descriptor instead.
func (MetricSelector_IstioMetric) EnumDescriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{4, 0}
}

type MetricsOverrides_TagOverride_Operation int32

const (
	// Insert or Update the tag with the provided value expression. The
	// `value` field MUST be specified if UPSERT is used as the operation.
	MetricsOverrides_TagOverride_UPSERT MetricsOverrides_TagOverride_Operation = 0
	// Specifies that the tag should not be included in the metric when
	// generated.
	MetricsOverrides_TagOverride_REMOVE MetricsOverrides_TagOverride_Operation = 1
)

// Enum value maps for MetricsOverrides_TagOverride_Operation.
var (
	MetricsOverrides_TagOverride_Operation_name = map[int32]string{
		0: "UPSERT",
		1: "REMOVE",
	}
	MetricsOverrides_TagOverride_Operation_value = map[string]int32{
		"UPSERT": 0,
		"REMOVE": 1,
	}
)

func (x MetricsOverrides_TagOverride_Operation) Enum() *MetricsOverrides_TagOverride_Operation {
	p := new(MetricsOverrides_TagOverride_Operation)
	*p = x
	return p
}

func (x MetricsOverrides_TagOverride_Operation) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MetricsOverrides_TagOverride_Operation) Descriptor() protoreflect.EnumDescriptor {
	return file_telemetry_v1alpha1_telemetry_proto_enumTypes[2].Descriptor()
}

func (MetricsOverrides_TagOverride_Operation) Type() protoreflect.EnumType {
	return &file_telemetry_v1alpha1_telemetry_proto_enumTypes[2]
}

func (x MetricsOverrides_TagOverride_Operation) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MetricsOverrides_TagOverride_Operation.Descriptor instead.
func (MetricsOverrides_TagOverride_Operation) EnumDescriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{5, 0, 0}
}

// <!-- crd generation tags
// +cue-gen:Telemetry:groupName:telemetry.istio.io
// +cue-gen:Telemetry:version:v1alpha1
// +cue-gen:Telemetry:storageVersion
// +cue-gen:Telemetry:annotations:helm.sh/resource-policy=keep
// +cue-gen:Telemetry:labels:app=istio-pilot,chart=istio,istio=telemetry,heritage=Tiller,release=istio
// +cue-gen:Telemetry:subresource:status
// +cue-gen:Telemetry:scope:Namespaced
// +cue-gen:Telemetry:resource:categories=istio-io,telemetry-istio-io,shortNames=telemetry,plural=telemetries
// +cue-gen:Telemetry:preserveUnknownFields:false
// +cue-gen:Telemetry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp
// is a timestamp representing the server time when this object was created. It
// is not guaranteed to be set in happens-before order across separate
// operations. Clients may not set this value. It is represented in RFC3339 form
// and is in UTC. Populated by the system. Read-only. Null for lists. More info:
// https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=telemetry.istio.io/v1alpha1
// +genclient
// +k8s:deepcopy-gen=true
// -->
type Telemetry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. The selector decides where to apply the Telemetry policy.
	// If not set, the Telemetry policy will be applied to all workloads in the
	// same namespace as the Telemetry policy.
	Selector *v1beta1.WorkloadSelector `protobuf:"bytes,1,opt,name=selector,proto3" json:"selector,omitempty"`
	// Optional. Tracing configures the tracing behavior for all
	// selected workloads.
	Tracing []*Tracing `protobuf:"bytes,2,rep,name=tracing,proto3" json:"tracing,omitempty"`
	// Optional. Metrics configure the metrics behavior for all
	// selected workloads.
	Metrics []*Metrics `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics,omitempty"`
	// Optional. AccessLogging configures the access logging behavior for all
	// selected workloads.
	AccessLogging []*AccessLogging `protobuf:"bytes,4,rep,name=access_logging,json=accessLogging,proto3" json:"access_logging,omitempty"`
}

func (x *Telemetry) Reset() {
	*x = Telemetry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Telemetry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Telemetry) ProtoMessage() {}

func (x *Telemetry) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Telemetry.ProtoReflect.Descriptor instead.
func (*Telemetry) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{0}
}

func (x *Telemetry) GetSelector() *v1beta1.WorkloadSelector {
	if x != nil {
		return x.Selector
	}
	return nil
}

func (x *Telemetry) GetTracing() []*Tracing {
	if x != nil {
		return x.Tracing
	}
	return nil
}

func (x *Telemetry) GetMetrics() []*Metrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

func (x *Telemetry) GetAccessLogging() []*AccessLogging {
	if x != nil {
		return x.AccessLogging
	}
	return nil
}

// Tracing configures tracing behavior for workloads within a mesh.
// It can be used to enable/disable tracing, as well as to set sampling
// rates and custom tag extraction.
//
// Tracing configuration support overrides of the fields `providers`,
// `random_sampling_percentage`, `disable_span_reporting`, and `custom_tags` at
// each level in the configuration hierarchy, with missing values filled in
// from parent resources. However, when specified, `custom_tags` will
// fully replace any values provided by parent configuration.
type Tracing struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Allows tailoring of behavior to specific conditions.
	Match *Tracing_TracingSelector `protobuf:"bytes,7,opt,name=match,proto3" json:"match,omitempty"`
	// Optional. Name of provider(s) to use for span reporting. If a provider is
	// not specified, the [default tracing
	// provider](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-DefaultProviders) will be
	// used. NOTE: At the moment, only a single provider can be specified in a
	// given Tracing rule.
	Providers []*ProviderRef `protobuf:"bytes,2,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls the rate at which traffic will be selected for tracing if no
	// prior sampling decision has been made. If a prior sampling decision has
	// been made, that decision will be respected. However, if no sampling
	// decision has been made (example: no `x-b3-sampled` tracing header was
	// present in the requests), the traffic will be selected for telemetry
	// generation at the percentage specified.
	//
	// Defaults to 0%. Valid values [0.00-100.00]. Can be specified in 0.01%
	// increments.
	RandomSamplingPercentage *wrappers.DoubleValue `protobuf:"bytes,3,opt,name=random_sampling_percentage,json=randomSamplingPercentage,proto3" json:"random_sampling_percentage,omitempty"`
	// Controls span reporting. If set to true, no spans will be reported for
	// impacted workloads. This does NOT impact context propagation or trace
	// sampling behavior.
	DisableSpanReporting *wrappers.BoolValue `protobuf:"bytes,4,opt,name=disable_span_reporting,json=disableSpanReporting,proto3" json:"disable_span_reporting,omitempty"`
	// Optional. Configures additional custom tags to the generated trace spans.
	CustomTags map[string]*Tracing_CustomTag `protobuf:"bytes,5,rep,name=custom_tags,json=customTags,proto3" json:"custom_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// This value is true by default; Envoy decides whether or not to sample based
	// on the value of the Request ID generated by Ingress in distributed tracing.
	// The format of this Request ID is specific to Envoy, and if the Request ID
	// generated by the proxy that receives user traffic first is not specific to
	// Envoy, Envoy will break the trace because it cannot interpret the Request
	// ID. By setting this value to false, we can prevent Envoy from sampling
	// based on the Request ID. As a result, the trace will not be broken even if
	// the Request ID is not in the Envoy format. [Trace Context
	// Propagation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/observability/tracing#trace-context-propagation)
	// provides more information on Request ID handling.
	// $hide_from_docs
	UseRequestIdForTraceSampling *wrappers.BoolValue `protobuf:"bytes,6,opt,name=use_request_id_for_trace_sampling,json=useRequestIdForTraceSampling,proto3" json:"use_request_id_for_trace_sampling,omitempty"`
}

func (x *Tracing) Reset() {
	*x = Tracing{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing) ProtoMessage() {}

func (x *Tracing) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing.ProtoReflect.Descriptor instead.
func (*Tracing) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1}
}

func (x *Tracing) GetMatch() *Tracing_TracingSelector {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *Tracing) GetProviders() []*ProviderRef {
	if x != nil {
		return x.Providers
	}
	return nil
}

func (x *Tracing) GetRandomSamplingPercentage() *wrappers.DoubleValue {
	if x != nil {
		return x.RandomSamplingPercentage
	}
	return nil
}

func (x *Tracing) GetDisableSpanReporting() *wrappers.BoolValue {
	if x != nil {
		return x.DisableSpanReporting
	}
	return nil
}

func (x *Tracing) GetCustomTags() map[string]*Tracing_CustomTag {
	if x != nil {
		return x.CustomTags
	}
	return nil
}

func (x *Tracing) GetUseRequestIdForTraceSampling() *wrappers.BoolValue {
	if x != nil {
		return x.UseRequestIdForTraceSampling
	}
	return nil
}

// Used to bind Telemetry configuration to specific providers for
// targeted customization.
type ProviderRef struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Required. Name of Telemetry provider in MeshConfig.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *ProviderRef) Reset() {
	*x = ProviderRef{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ProviderRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProviderRef) ProtoMessage() {}

func (x *ProviderRef) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProviderRef.ProtoReflect.Descriptor instead.
func (*ProviderRef) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{2}
}

func (x *ProviderRef) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Metrics defines the workload-level overrides for metrics generation behavior
// within a mesh. It can be used to enable/disable metrics generation, as well
// as to customize the dimensions of the generated metrics.
type Metrics struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default metrics
	// provider](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-DefaultProviders) will be
	// used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Optional. Ordered list of overrides to metrics generation behavior.
	//
	// Specified overrides will be applied in order. They will be applied on
	// top of inherited overrides from other resources in the hierarchy in the
	// following order:
	// 1. Mesh-scoped overrides
	// 2. Namespace-scoped overrides
	// 3. Workload-scoped overrides
	//
	// Because overrides are applied in order, users are advised to order their
	// overrides from least specific to most specific matches. That is, it is
	// a best practice to list any universal overrides first, with tailored
	// overrides following them.
	Overrides []*MetricsOverrides `protobuf:"bytes,2,rep,name=overrides,proto3" json:"overrides,omitempty"`
	// Optional. Reporting interval allows configuration of the time between calls out to for metrics reporting.
	// This currently only supports TCP metrics but we may use this for long duration HTTP streams in the future.
	// The default duration is `5s`.
	ReportingInterval *duration.Duration `protobuf:"bytes,3,opt,name=reporting_interval,json=reportingInterval,proto3" json:"reporting_interval,omitempty"`
}

func (x *Metrics) Reset() {
	*x = Metrics{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Metrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Metrics) ProtoMessage() {}

func (x *Metrics) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Metrics.ProtoReflect.Descriptor instead.
func (*Metrics) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{3}
}

func (x *Metrics) GetProviders() []*ProviderRef {
	if x != nil {
		return x.Providers
	}
	return nil
}

func (x *Metrics) GetOverrides() []*MetricsOverrides {
	if x != nil {
		return x.Overrides
	}
	return nil
}

func (x *Metrics) GetReportingInterval() *duration.Duration {
	if x != nil {
		return x.ReportingInterval
	}
	return nil
}

// Provides a mechanism for matching metrics for the application of override
// behaviors.
type MetricSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Controls which metric(s) are selected by the selector.
	//
	// Types that are assignable to MetricMatch:
	//
	//	*MetricSelector_Metric
	//	*MetricSelector_CustomMetric
	MetricMatch isMetricSelector_MetricMatch `protobuf_oneof:"metric_match"`
	// Controls which mode of metrics generation is selected: CLIENT and/or
	// SERVER.
	Mode WorkloadMode `protobuf:"varint,3,opt,name=mode,proto3,enum=istio.telemetry.v1alpha1.WorkloadMode" json:"mode,omitempty"`
}

func (x *MetricSelector) Reset() {
	*x = MetricSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetricSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricSelector) ProtoMessage() {}

func (x *MetricSelector) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricSelector.ProtoReflect.Descriptor instead.
func (*MetricSelector) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{4}
}

func (m *MetricSelector) GetMetricMatch() isMetricSelector_MetricMatch {
	if m != nil {
		return m.MetricMatch
	}
	return nil
}

func (x *MetricSelector) GetMetric() MetricSelector_IstioMetric {
	if x, ok := x.GetMetricMatch().(*MetricSelector_Metric); ok {
		return x.Metric
	}
	return MetricSelector_ALL_METRICS
}

func (x *MetricSelector) GetCustomMetric() string {
	if x, ok := x.GetMetricMatch().(*MetricSelector_CustomMetric); ok {
		return x.CustomMetric
	}
	return ""
}

func (x *MetricSelector) GetMode() WorkloadMode {
	if x != nil {
		return x.Mode
	}
	return WorkloadMode_CLIENT_AND_SERVER
}

type isMetricSelector_MetricMatch interface {
	isMetricSelector_MetricMatch()
}

type MetricSelector_Metric struct {
	// One of the well-known Istio Standard Metrics.
	Metric MetricSelector_IstioMetric `protobuf:"varint,1,opt,name=metric,proto3,enum=istio.telemetry.v1alpha1.MetricSelector_IstioMetric,oneof"`
}

type MetricSelector_CustomMetric struct {
	// Allows free-form specification of a metric. No validation of custom
	// metrics is provided.
	CustomMetric string `protobuf:"bytes,2,opt,name=custom_metric,json=customMetric,proto3,oneof"`
}

func (*MetricSelector_Metric) isMetricSelector_MetricMatch() {}

func (*MetricSelector_CustomMetric) isMetricSelector_MetricMatch() {}

// MetricsOverrides defines custom metric generation behavior for an individual
// metric or the set of all standard metrics.
type MetricsOverrides struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Match allows provides the scope of the override. It can be used to select
	// individual metrics, as well as the workload modes (server and/or client)
	// in which the metrics will be generated.
	//
	// If match is not specified, the overrides will apply to *all* metrics for
	// *both* modes of operation (client and server).
	Match *MetricSelector `protobuf:"bytes,1,opt,name=match,proto3" json:"match,omitempty"`
	// Optional. Must explicitly set this to "true" to turn off metrics reporting
	// for the listed metrics. If disabled has been set to "true" in a parent
	// configuration, it must explicitly be set to "false" to turn metrics
	// reporting on in the workloads selected by the Telemetry resource.
	Disabled *wrappers.BoolValue `protobuf:"bytes,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Optional. Collection of tag names and tag expressions to override in the
	// selected metric(s).
	// The key in the map is the name of the tag.
	// The value in the map is the operation to perform on the the tag.
	// WARNING: some providers may not support adding/removing tags.
	// See also: https://istio.io/latest/docs/reference/config/metrics/#labels
	TagOverrides map[string]*MetricsOverrides_TagOverride `protobuf:"bytes,3,rep,name=tag_overrides,json=tagOverrides,proto3" json:"tag_overrides,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *MetricsOverrides) Reset() {
	*x = MetricsOverrides{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetricsOverrides) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricsOverrides) ProtoMessage() {}

func (x *MetricsOverrides) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricsOverrides.ProtoReflect.Descriptor instead.
func (*MetricsOverrides) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{5}
}

func (x *MetricsOverrides) GetMatch() *MetricSelector {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *MetricsOverrides) GetDisabled() *wrappers.BoolValue {
	if x != nil {
		return x.Disabled
	}
	return nil
}

func (x *MetricsOverrides) GetTagOverrides() map[string]*MetricsOverrides_TagOverride {
	if x != nil {
		return x.TagOverrides
	}
	return nil
}

// Access logging defines the workload-level overrides for access log
// generation. It can be used to select provider or enable/disable access log
// generation for a workload.
type AccessLogging struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Allows tailoring of logging behavior to specific conditions.
	Match *AccessLogging_LogSelector `protobuf:"bytes,4,opt,name=match,proto3" json:"match,omitempty"`
	// Optional. Name of providers to which this configuration should apply.
	// If a provider is not specified, the [default logging
	// provider](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-DefaultProviders) will be used.
	Providers []*ProviderRef `protobuf:"bytes,1,rep,name=providers,proto3" json:"providers,omitempty"`
	// Controls logging. If set to true, no access logs will be generated for
	// impacted workloads (for the specified providers).
	// NOTE: currently default behavior will be controlled by the provider(s)
	// selected above. Customization controls will be added to this API in
	// future releases.
	Disabled *wrappers.BoolValue `protobuf:"bytes,2,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Optional. If specified, this filter will be used to select specific
	// requests/connections for logging.
	Filter *AccessLogging_Filter `protobuf:"bytes,3,opt,name=filter,proto3" json:"filter,omitempty"`
}

func (x *AccessLogging) Reset() {
	*x = AccessLogging{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogging) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogging) ProtoMessage() {}

func (x *AccessLogging) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogging.ProtoReflect.Descriptor instead.
func (*AccessLogging) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{6}
}

func (x *AccessLogging) GetMatch() *AccessLogging_LogSelector {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *AccessLogging) GetProviders() []*ProviderRef {
	if x != nil {
		return x.Providers
	}
	return nil
}

func (x *AccessLogging) GetDisabled() *wrappers.BoolValue {
	if x != nil {
		return x.Disabled
	}
	return nil
}

func (x *AccessLogging) GetFilter() *AccessLogging_Filter {
	if x != nil {
		return x.Filter
	}
	return nil
}

// TracingSelector provides a coarse-grained ability to configure tracing
// behavior based on certain traffic metadata (such as traffic direction).
type Tracing_TracingSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// This determines whether or not to apply the tracing configuration
	// based on the direction of traffic relative to the proxied workload.
	Mode WorkloadMode `protobuf:"varint,1,opt,name=mode,proto3,enum=istio.telemetry.v1alpha1.WorkloadMode" json:"mode,omitempty"`
}

func (x *Tracing_TracingSelector) Reset() {
	*x = Tracing_TracingSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing_TracingSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing_TracingSelector) ProtoMessage() {}

func (x *Tracing_TracingSelector) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing_TracingSelector.ProtoReflect.Descriptor instead.
func (*Tracing_TracingSelector) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Tracing_TracingSelector) GetMode() WorkloadMode {
	if x != nil {
		return x.Mode
	}
	return WorkloadMode_CLIENT_AND_SERVER
}

// CustomTag defines a tag to be added to a trace span that is based on
// an operator-supplied value. This value can either be a hard-coded value,
// a value taken from an environment variable known to the sidecar proxy, or
// from a request header.
//
// NOTE: when specified, `custom_tags` will fully replace any values provided
// by parent configuration.
type Tracing_CustomTag struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Types that are assignable to Type:
	//
	//	*Tracing_CustomTag_Literal
	//	*Tracing_CustomTag_Environment
	//	*Tracing_CustomTag_Header
	Type isTracing_CustomTag_Type `protobuf_oneof:"type"`
}

func (x *Tracing_CustomTag) Reset() {
	*x = Tracing_CustomTag{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing_CustomTag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing_CustomTag) ProtoMessage() {}

func (x *Tracing_CustomTag) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing_CustomTag.ProtoReflect.Descriptor instead.
func (*Tracing_CustomTag) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1, 1}
}

func (m *Tracing_CustomTag) GetType() isTracing_CustomTag_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (x *Tracing_CustomTag) GetLiteral() *Tracing_Literal {
	if x, ok := x.GetType().(*Tracing_CustomTag_Literal); ok {
		return x.Literal
	}
	return nil
}

func (x *Tracing_CustomTag) GetEnvironment() *Tracing_Environment {
	if x, ok := x.GetType().(*Tracing_CustomTag_Environment); ok {
		return x.Environment
	}
	return nil
}

func (x *Tracing_CustomTag) GetHeader() *Tracing_RequestHeader {
	if x, ok := x.GetType().(*Tracing_CustomTag_Header); ok {
		return x.Header
	}
	return nil
}

type isTracing_CustomTag_Type interface {
	isTracing_CustomTag_Type()
}

type Tracing_CustomTag_Literal struct {
	// Literal adds the same, hard-coded value to each span.
	Literal *Tracing_Literal `protobuf:"bytes,1,opt,name=literal,proto3,oneof"`
}

type Tracing_CustomTag_Environment struct {
	// Environment adds the value of an environment variable to each span.
	Environment *Tracing_Environment `protobuf:"bytes,2,opt,name=environment,proto3,oneof"`
}

type Tracing_CustomTag_Header struct {
	// RequestHeader adds the value of an header from the request to each
	// span.
	Header *Tracing_RequestHeader `protobuf:"bytes,3,opt,name=header,proto3,oneof"` // TODO: add support for Metadata tags
}

func (*Tracing_CustomTag_Literal) isTracing_CustomTag_Type() {}

func (*Tracing_CustomTag_Environment) isTracing_CustomTag_Type() {}

func (*Tracing_CustomTag_Header) isTracing_CustomTag_Type() {}

type Tracing_Literal struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The tag value to use.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Tracing_Literal) Reset() {
	*x = Tracing_Literal{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing_Literal) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing_Literal) ProtoMessage() {}

func (x *Tracing_Literal) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing_Literal.ProtoReflect.Descriptor instead.
func (*Tracing_Literal) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1, 2}
}

func (x *Tracing_Literal) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type Tracing_Environment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name of the environment variable from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the environment variable is not found, this value will be
	// used instead.
	DefaultValue string `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (x *Tracing_Environment) Reset() {
	*x = Tracing_Environment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing_Environment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing_Environment) ProtoMessage() {}

func (x *Tracing_Environment) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing_Environment.ProtoReflect.Descriptor instead.
func (*Tracing_Environment) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1, 3}
}

func (x *Tracing_Environment) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Tracing_Environment) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

type Tracing_RequestHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Name of the header from which to extract the tag value.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Optional. If the header is not found, this value will be
	// used instead.
	DefaultValue string `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
}

func (x *Tracing_RequestHeader) Reset() {
	*x = Tracing_RequestHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Tracing_RequestHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tracing_RequestHeader) ProtoMessage() {}

func (x *Tracing_RequestHeader) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tracing_RequestHeader.ProtoReflect.Descriptor instead.
func (*Tracing_RequestHeader) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{1, 4}
}

func (x *Tracing_RequestHeader) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Tracing_RequestHeader) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

// TagOverride specifies an operation to perform on a metric dimension (also
// known as a `label`). Tags may be added, removed, or have their default
// values overridden.
type MetricsOverrides_TagOverride struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Operation controls whether or not to update/add a tag, or to remove it.
	Operation MetricsOverrides_TagOverride_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=istio.telemetry.v1alpha1.MetricsOverrides_TagOverride_Operation" json:"operation,omitempty"`
	// Value is only considered if the operation is `UPSERT`.
	// Values are [CEL expressions](https://opensource.google/projects/cel) over
	// attributes. Examples include: "string(destination.port)" and
	// "request.host". Istio exposes all standard [Envoy
	// attributes](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes).
	// Additionally, Istio exposes node metadata as attributes.
	// More information is provided in the [customization
	// docs](https://istio.io/latest/docs/tasks/observability/metrics/customize-metrics/#use-expressions-for-values).
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *MetricsOverrides_TagOverride) Reset() {
	*x = MetricsOverrides_TagOverride{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *MetricsOverrides_TagOverride) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MetricsOverrides_TagOverride) ProtoMessage() {}

func (x *MetricsOverrides_TagOverride) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MetricsOverrides_TagOverride.ProtoReflect.Descriptor instead.
func (*MetricsOverrides_TagOverride) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{5, 0}
}

func (x *MetricsOverrides_TagOverride) GetOperation() MetricsOverrides_TagOverride_Operation {
	if x != nil {
		return x.Operation
	}
	return MetricsOverrides_TagOverride_UPSERT
}

func (x *MetricsOverrides_TagOverride) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// LogSelector provides a coarse-grained ability to configure logging behavior
// based on certain traffic metadata (such as traffic direction). LogSelector
// applies to traffic metadata which is not represented in the attribute set
// currently supported by Filters. It allows control planes to limit the
// configuration sent to individual workloads. Finer-grained logging behavior
// can be further configured via `filter`.
type AccessLogging_LogSelector struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// This determines whether or not to apply the access logging configuration
	// based on the direction of traffic relative to the proxied workload.
	Mode WorkloadMode `protobuf:"varint,1,opt,name=mode,proto3,enum=istio.telemetry.v1alpha1.WorkloadMode" json:"mode,omitempty"`
}

func (x *AccessLogging_LogSelector) Reset() {
	*x = AccessLogging_LogSelector{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogging_LogSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogging_LogSelector) ProtoMessage() {}

func (x *AccessLogging_LogSelector) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogging_LogSelector.ProtoReflect.Descriptor instead.
func (*AccessLogging_LogSelector) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{6, 0}
}

func (x *AccessLogging_LogSelector) GetMode() WorkloadMode {
	if x != nil {
		return x.Mode
	}
	return WorkloadMode_CLIENT_AND_SERVER
}

// Allows specification of an access log filter.
type AccessLogging_Filter struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// CEL expression for selecting when requests/connections should be logged.
	//
	// Examples:
	//
	// - `response.code >= 400`
	// - `connection.mtls && request.url_path.contains('v1beta3')`
	Expression string `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
}

func (x *AccessLogging_Filter) Reset() {
	*x = AccessLogging_Filter{}
	if protoimpl.UnsafeEnabled {
		mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AccessLogging_Filter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessLogging_Filter) ProtoMessage() {}

func (x *AccessLogging_Filter) ProtoReflect() protoreflect.Message {
	mi := &file_telemetry_v1alpha1_telemetry_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessLogging_Filter.ProtoReflect.Descriptor instead.
func (*AccessLogging_Filter) Descriptor() ([]byte, []int) {
	return file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP(), []int{6, 1}
}

func (x *AccessLogging_Filter) GetExpression() string {
	if x != nil {
		return x.Expression
	}
	return ""
}

var File_telemetry_v1alpha1_telemetry_proto protoreflect.FileDescriptor

var file_telemetry_v1alpha1_telemetry_proto_rawDesc = []byte{
	0x0a, 0x22, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2f, 0x76, 0x31, 0x61, 0x6c,
	0x70, 0x68, 0x61, 0x31, 0x2f, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65,
	0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x1a, 0x1b,
	0x74, 0x79, 0x70, 0x65, 0x2f, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61, 0x31, 0x2f, 0x73, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f,
	0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x62, 0x65,
	0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x77, 0x72,
	0x61, 0x70, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x97, 0x02, 0x0a,
	0x09, 0x54, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x12, 0x40, 0x0a, 0x08, 0x73, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x69,
	0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x76, 0x31, 0x62, 0x65, 0x74, 0x61,
	0x31, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74,
	0x6f, 0x72, 0x52, 0x08, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3b, 0x0a, 0x07,
	0x74, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e,
	0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67,
	0x52, 0x07, 0x74, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x12, 0x3b, 0x0a, 0x07, 0x6d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x69, 0x73, 0x74,
	0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61,
	0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x52, 0x07, 0x6d,
	0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x4e, 0x0a, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x5f, 0x6c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27,
	0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
	0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x52, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c,
	0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x22, 0xe7, 0x08, 0x0a, 0x07, 0x54, 0x72, 0x61, 0x63, 0x69,
	0x6e, 0x67, 0x12, 0x47, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x31, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x54, 0x72, 0x61,
	0x63, 0x69, 0x6e, 0x67, 0x2e, 0x54, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x6f, 0x72, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x43, 0x0a, 0x09, 0x70,
	0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25,
	0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64,
	0x65, 0x72, 0x52, 0x65, 0x66, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73,
	0x12, 0x5a, 0x0a, 0x1a, 0x72, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x5f, 0x73, 0x61, 0x6d, 0x70, 0x6c,
	0x69, 0x6e, 0x67, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x52, 0x18, 0x72, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x69,
	0x6e, 0x67, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x61, 0x67, 0x65, 0x12, 0x50, 0x0a, 0x16,
	0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x72, 0x65, 0x70,
	0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x42,
	0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x14, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c,
	0x65, 0x53, 0x70, 0x61, 0x6e, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x12, 0x52,
	0x0a, 0x0b, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x05, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65,
	0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x54,
	0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x54, 0x61, 0x67,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x54, 0x61,
	0x67, 0x73, 0x12, 0x63, 0x0a, 0x21, 0x75, 0x73, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x5f, 0x69, 0x64, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x73,
	0x61, 0x6d, 0x70, 0x6c, 0x69, 0x6e, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x1c, 0x75, 0x73, 0x65, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x46, 0x6f, 0x72, 0x54, 0x72, 0x61, 0x63, 0x65, 0x53,
	0x61, 0x6d, 0x70, 0x6c, 0x69, 0x6e, 0x67, 0x1a, 0x4d, 0x0a, 0x0f, 0x54, 0x72, 0x61, 0x63, 0x69,
	0x6e, 0x67, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x3a, 0x0a, 0x04, 0x6d, 0x6f,
	0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f,
	0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65,
	0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x1a, 0xf8, 0x01, 0x0a, 0x09, 0x43, 0x75, 0x73, 0x74, 0x6f,
	0x6d, 0x54, 0x61, 0x67, 0x12, 0x45, 0x0a, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65,
	0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31,
	0x2e, 0x54, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x48, 0x00, 0x52, 0x07, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x12, 0x51, 0x0a, 0x0b, 0x65,
	0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2d, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74,
	0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x63,
	0x69, 0x6e, 0x67, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x48,
	0x00, 0x52, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x49,
	0x0a, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79,
	0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x63, 0x69, 0x6e,
	0x67, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x48,
	0x00, 0x52, 0x06, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x42, 0x06, 0x0a, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x1a, 0x1f, 0x0a, 0x07, 0x4c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x12, 0x14, 0x0a, 0x05,
	0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x1a, 0x46, 0x0a, 0x0b, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e,
	0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x23, 0x0a, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74,
	0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65,
	0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x1a, 0x48, 0x0a, 0x0d, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
	0x23, 0x0a, 0x0d, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56,
	0x61, 0x6c, 0x75, 0x65, 0x1a, 0x6a, 0x0a, 0x0f, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x54, 0x61,
	0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x41, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f,
	0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x54, 0x72, 0x61, 0x63, 0x69, 0x6e, 0x67, 0x2e, 0x43, 0x75, 0x73, 0x74,
	0x6f, 0x6d, 0x54, 0x61, 0x67, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
	0x22, 0x27, 0x0a, 0x0b, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x65, 0x66, 0x12,
	0x18, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x42, 0x04, 0xe2,
	0x41, 0x01, 0x02, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0xe2, 0x01, 0x0a, 0x07, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x12, 0x43, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
	0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f,
	0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70,
	0x68, 0x61, 0x31, 0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x65, 0x66, 0x52,
	0x09, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x12, 0x48, 0x0a, 0x09, 0x6f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e,
	0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e,
	0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73,
	0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x52, 0x09, 0x6f, 0x76, 0x65, 0x72, 0x72,
	0x69, 0x64, 0x65, 0x73, 0x12, 0x48, 0x0a, 0x12, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x69, 0x6e,
	0x67, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x11, 0x72, 0x65, 0x70,
	0x6f, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x22, 0xdd,
	0x03, 0x0a, 0x0e, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f,
	0x72, 0x12, 0x4e, 0x0a, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x34, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x49, 0x73, 0x74, 0x69,
	0x6f, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x48, 0x00, 0x52, 0x06, 0x6d, 0x65, 0x74, 0x72, 0x69,
	0x63, 0x12, 0x25, 0x0a, 0x0d, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x6d, 0x65, 0x74, 0x72,
	0x69, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x0c, 0x63, 0x75, 0x73, 0x74,
	0x6f, 0x6d, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x12, 0x3a, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x26, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74,
	0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61,
	0x31, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x04,
	0x6d, 0x6f, 0x64, 0x65, 0x22, 0x87, 0x02, 0x0a, 0x0b, 0x49, 0x73, 0x74, 0x69, 0x6f, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x12, 0x0f, 0x0a, 0x0b, 0x41, 0x4c, 0x4c, 0x5f, 0x4d, 0x45, 0x54, 0x52,
	0x49, 0x43, 0x53, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54,
	0x5f, 0x43, 0x4f, 0x55, 0x4e, 0x54, 0x10, 0x01, 0x12, 0x14, 0x0a, 0x10, 0x52, 0x45, 0x51, 0x55,
	0x45, 0x53, 0x54, 0x5f, 0x44, 0x55, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x02, 0x12, 0x10,
	0x0a, 0x0c, 0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x5f, 0x53, 0x49, 0x5a, 0x45, 0x10, 0x03,
	0x12, 0x11, 0x0a, 0x0d, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x5f, 0x53, 0x49, 0x5a,
	0x45, 0x10, 0x04, 0x12, 0x1a, 0x0a, 0x16, 0x54, 0x43, 0x50, 0x5f, 0x4f, 0x50, 0x45, 0x4e, 0x45,
	0x44, 0x5f, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x10, 0x05, 0x12,
	0x1a, 0x0a, 0x16, 0x54, 0x43, 0x50, 0x5f, 0x43, 0x4c, 0x4f, 0x53, 0x45, 0x44, 0x5f, 0x43, 0x4f,
	0x4e, 0x4e, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x53, 0x10, 0x06, 0x12, 0x12, 0x0a, 0x0e, 0x54,
	0x43, 0x50, 0x5f, 0x53, 0x45, 0x4e, 0x54, 0x5f, 0x42, 0x59, 0x54, 0x45, 0x53, 0x10, 0x07, 0x12,
	0x16, 0x0a, 0x12, 0x54, 0x43, 0x50, 0x5f, 0x52, 0x45, 0x43, 0x45, 0x49, 0x56, 0x45, 0x44, 0x5f,
	0x42, 0x59, 0x54, 0x45, 0x53, 0x10, 0x08, 0x12, 0x19, 0x0a, 0x15, 0x47, 0x52, 0x50, 0x43, 0x5f,
	0x52, 0x45, 0x51, 0x55, 0x45, 0x53, 0x54, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x53,
	0x10, 0x09, 0x12, 0x1a, 0x0a, 0x16, 0x47, 0x52, 0x50, 0x43, 0x5f, 0x52, 0x45, 0x53, 0x50, 0x4f,
	0x4e, 0x53, 0x45, 0x5f, 0x4d, 0x45, 0x53, 0x53, 0x41, 0x47, 0x45, 0x53, 0x10, 0x0a, 0x42, 0x0e,
	0x0a, 0x0c, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x5f, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x22, 0x91,
	0x04, 0x0a, 0x10, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69,
	0x64, 0x65, 0x73, 0x12, 0x3e, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x28, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x05, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x12, 0x36, 0x0a, 0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x75,
	0x65, 0x52, 0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x61, 0x0a, 0x0d, 0x74,
	0x61, 0x67, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65,
	0x74, 0x72, 0x69, 0x63, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x2e, 0x54,
	0x61, 0x67, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x52, 0x0c, 0x74, 0x61, 0x67, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x1a, 0xa8,
	0x01, 0x0a, 0x0b, 0x54, 0x61, 0x67, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x12, 0x5e,
	0x0a, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x40, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74,
	0x72, 0x69, 0x63, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x2e, 0x54, 0x61,
	0x67, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x09, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x22, 0x23, 0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x55, 0x50, 0x53, 0x45, 0x52, 0x54, 0x10, 0x00, 0x12, 0x0a, 0x0a,
	0x06, 0x52, 0x45, 0x4d, 0x4f, 0x56, 0x45, 0x10, 0x01, 0x1a, 0x77, 0x0a, 0x11, 0x54, 0x61, 0x67,
	0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x4c, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x36, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72,
	0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x4d, 0x65, 0x74, 0x72, 0x69,
	0x63, 0x73, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x2e, 0x54, 0x61, 0x67, 0x4f,
	0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x22, 0x94, 0x03, 0x0a, 0x0d, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67,
	0x67, 0x69, 0x6e, 0x67, 0x12, 0x49, 0x0a, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65,
	0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x41,
	0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x2e, 0x4c, 0x6f, 0x67,
	0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x05, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x12,
	0x43, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x25, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x50, 0x72,
	0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x52, 0x65, 0x66, 0x52, 0x09, 0x70, 0x72, 0x6f, 0x76, 0x69,
	0x64, 0x65, 0x72, 0x73, 0x12, 0x36, 0x0a, 0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x56, 0x61, 0x6c,
	0x75, 0x65, 0x52, 0x08, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x46, 0x0a, 0x06,
	0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x69,
	0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x2e, 0x76,
	0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x4c, 0x6f,
	0x67, 0x67, 0x69, 0x6e, 0x67, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x52, 0x06, 0x66, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x1a, 0x49, 0x0a, 0x0b, 0x4c, 0x6f, 0x67, 0x53, 0x65, 0x6c, 0x65, 0x63,
	0x74, 0x6f, 0x72, 0x12, 0x3a, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x26, 0x2e, 0x69, 0x73, 0x74, 0x69, 0x6f, 0x2e, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65,
	0x74, 0x72, 0x79, 0x2e, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x2e, 0x57, 0x6f, 0x72,
	0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x1a,
	0x28, 0x0a, 0x06, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x1e, 0x0a, 0x0a, 0x65, 0x78, 0x70,
	0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x65,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2a, 0x3d, 0x0a, 0x0c, 0x57, 0x6f, 0x72,
	0x6b, 0x6c, 0x6f, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x15, 0x0a, 0x11, 0x43, 0x4c, 0x49,
	0x45, 0x4e, 0x54, 0x5f, 0x41, 0x4e, 0x44, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x10, 0x00,
	0x12, 0x0a, 0x0a, 0x06, 0x43, 0x4c, 0x49, 0x45, 0x4e, 0x54, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06,
	0x53, 0x45, 0x52, 0x56, 0x45, 0x52, 0x10, 0x02, 0x42, 0x21, 0x5a, 0x1f, 0x69, 0x73, 0x74, 0x69,
	0x6f, 0x2e, 0x69, 0x6f, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x74, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x74,
	0x72, 0x79, 0x2f, 0x76, 0x31, 0x61, 0x6c, 0x70, 0x68, 0x61, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_telemetry_v1alpha1_telemetry_proto_rawDescOnce sync.Once
	file_telemetry_v1alpha1_telemetry_proto_rawDescData = file_telemetry_v1alpha1_telemetry_proto_rawDesc
)

func file_telemetry_v1alpha1_telemetry_proto_rawDescGZIP() []byte {
	file_telemetry_v1alpha1_telemetry_proto_rawDescOnce.Do(func() {
		file_telemetry_v1alpha1_telemetry_proto_rawDescData = protoimpl.X.CompressGZIP(file_telemetry_v1alpha1_telemetry_proto_rawDescData)
	})
	return file_telemetry_v1alpha1_telemetry_proto_rawDescData
}

var file_telemetry_v1alpha1_telemetry_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_telemetry_v1alpha1_telemetry_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_telemetry_v1alpha1_telemetry_proto_goTypes = []interface{}{
	(WorkloadMode)(0),                           // 0: istio.telemetry.v1alpha1.WorkloadMode
	(MetricSelector_IstioMetric)(0),             // 1: istio.telemetry.v1alpha1.MetricSelector.IstioMetric
	(MetricsOverrides_TagOverride_Operation)(0), // 2: istio.telemetry.v1alpha1.MetricsOverrides.TagOverride.Operation
	(*Telemetry)(nil),                           // 3: istio.telemetry.v1alpha1.Telemetry
	(*Tracing)(nil),                             // 4: istio.telemetry.v1alpha1.Tracing
	(*ProviderRef)(nil),                         // 5: istio.telemetry.v1alpha1.ProviderRef
	(*Metrics)(nil),                             // 6: istio.telemetry.v1alpha1.Metrics
	(*MetricSelector)(nil),                      // 7: istio.telemetry.v1alpha1.MetricSelector
	(*MetricsOverrides)(nil),                    // 8: istio.telemetry.v1alpha1.MetricsOverrides
	(*AccessLogging)(nil),                       // 9: istio.telemetry.v1alpha1.AccessLogging
	(*Tracing_TracingSelector)(nil),             // 10: istio.telemetry.v1alpha1.Tracing.TracingSelector
	(*Tracing_CustomTag)(nil),                   // 11: istio.telemetry.v1alpha1.Tracing.CustomTag
	(*Tracing_Literal)(nil),                     // 12: istio.telemetry.v1alpha1.Tracing.Literal
	(*Tracing_Environment)(nil),                 // 13: istio.telemetry.v1alpha1.Tracing.Environment
	(*Tracing_RequestHeader)(nil),               // 14: istio.telemetry.v1alpha1.Tracing.RequestHeader
	nil,                                         // 15: istio.telemetry.v1alpha1.Tracing.CustomTagsEntry
	(*MetricsOverrides_TagOverride)(nil),        // 16: istio.telemetry.v1alpha1.MetricsOverrides.TagOverride
	nil,                                         // 17: istio.telemetry.v1alpha1.MetricsOverrides.TagOverridesEntry
	(*AccessLogging_LogSelector)(nil),           // 18: istio.telemetry.v1alpha1.AccessLogging.LogSelector
	(*AccessLogging_Filter)(nil),                // 19: istio.telemetry.v1alpha1.AccessLogging.Filter
	(*v1beta1.WorkloadSelector)(nil),            // 20: istio.type.v1beta1.WorkloadSelector
	(*wrappers.DoubleValue)(nil),                // 21: google.protobuf.DoubleValue
	(*wrappers.BoolValue)(nil),                  // 22: google.protobuf.BoolValue
	(*duration.Duration)(nil),                   // 23: google.protobuf.Duration
}
var file_telemetry_v1alpha1_telemetry_proto_depIdxs = []int32{
	20, // 0: istio.telemetry.v1alpha1.Telemetry.selector:type_name -> istio.type.v1beta1.WorkloadSelector
	4,  // 1: istio.telemetry.v1alpha1.Telemetry.tracing:type_name -> istio.telemetry.v1alpha1.Tracing
	6,  // 2: istio.telemetry.v1alpha1.Telemetry.metrics:type_name -> istio.telemetry.v1alpha1.Metrics
	9,  // 3: istio.telemetry.v1alpha1.Telemetry.access_logging:type_name -> istio.telemetry.v1alpha1.AccessLogging
	10, // 4: istio.telemetry.v1alpha1.Tracing.match:type_name -> istio.telemetry.v1alpha1.Tracing.TracingSelector
	5,  // 5: istio.telemetry.v1alpha1.Tracing.providers:type_name -> istio.telemetry.v1alpha1.ProviderRef
	21, // 6: istio.telemetry.v1alpha1.Tracing.random_sampling_percentage:type_name -> google.protobuf.DoubleValue
	22, // 7: istio.telemetry.v1alpha1.Tracing.disable_span_reporting:type_name -> google.protobuf.BoolValue
	15, // 8: istio.telemetry.v1alpha1.Tracing.custom_tags:type_name -> istio.telemetry.v1alpha1.Tracing.CustomTagsEntry
	22, // 9: istio.telemetry.v1alpha1.Tracing.use_request_id_for_trace_sampling:type_name -> google.protobuf.BoolValue
	5,  // 10: istio.telemetry.v1alpha1.Metrics.providers:type_name -> istio.telemetry.v1alpha1.ProviderRef
	8,  // 11: istio.telemetry.v1alpha1.Metrics.overrides:type_name -> istio.telemetry.v1alpha1.MetricsOverrides
	23, // 12: istio.telemetry.v1alpha1.Metrics.reporting_interval:type_name -> google.protobuf.Duration
	1,  // 13: istio.telemetry.v1alpha1.MetricSelector.metric:type_name -> istio.telemetry.v1alpha1.MetricSelector.IstioMetric
	0,  // 14: istio.telemetry.v1alpha1.MetricSelector.mode:type_name -> istio.telemetry.v1alpha1.WorkloadMode
	7,  // 15: istio.telemetry.v1alpha1.MetricsOverrides.match:type_name -> istio.telemetry.v1alpha1.MetricSelector
	22, // 16: istio.telemetry.v1alpha1.MetricsOverrides.disabled:type_name -> google.protobuf.BoolValue
	17, // 17: istio.telemetry.v1alpha1.MetricsOverrides.tag_overrides:type_name -> istio.telemetry.v1alpha1.MetricsOverrides.TagOverridesEntry
	18, // 18: istio.telemetry.v1alpha1.AccessLogging.match:type_name -> istio.telemetry.v1alpha1.AccessLogging.LogSelector
	5,  // 19: istio.telemetry.v1alpha1.AccessLogging.providers:type_name -> istio.telemetry.v1alpha1.ProviderRef
	22, // 20: istio.telemetry.v1alpha1.AccessLogging.disabled:type_name -> google.protobuf.BoolValue
	19, // 21: istio.telemetry.v1alpha1.AccessLogging.filter:type_name -> istio.telemetry.v1alpha1.AccessLogging.Filter
	0,  // 22: istio.telemetry.v1alpha1.Tracing.TracingSelector.mode:type_name -> istio.telemetry.v1alpha1.WorkloadMode
	12, // 23: istio.telemetry.v1alpha1.Tracing.CustomTag.literal:type_name -> istio.telemetry.v1alpha1.Tracing.Literal
	13, // 24: istio.telemetry.v1alpha1.Tracing.CustomTag.environment:type_name -> istio.telemetry.v1alpha1.Tracing.Environment
	14, // 25: istio.telemetry.v1alpha1.Tracing.CustomTag.header:type_name -> istio.telemetry.v1alpha1.Tracing.RequestHeader
	11, // 26: istio.telemetry.v1alpha1.Tracing.CustomTagsEntry.value:type_name -> istio.telemetry.v1alpha1.Tracing.CustomTag
	2,  // 27: istio.telemetry.v1alpha1.MetricsOverrides.TagOverride.operation:type_name -> istio.telemetry.v1alpha1.MetricsOverrides.TagOverride.Operation
	16, // 28: istio.telemetry.v1alpha1.MetricsOverrides.TagOverridesEntry.value:type_name -> istio.telemetry.v1alpha1.MetricsOverrides.TagOverride
	0,  // 29: istio.telemetry.v1alpha1.AccessLogging.LogSelector.mode:type_name -> istio.telemetry.v1alpha1.WorkloadMode
	30, // [30:30] is the sub-list for method output_type
	30, // [30:30] is the sub-list for method input_type
	30, // [30:30] is the sub-list for extension type_name
	30, // [30:30] is the sub-list for extension extendee
	0,  // [0:30] is the sub-list for field type_name
}

func init() { file_telemetry_v1alpha1_telemetry_proto_init() }
func file_telemetry_v1alpha1_telemetry_proto_init() {
	if File_telemetry_v1alpha1_telemetry_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Telemetry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ProviderRef); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Metrics); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetricSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetricsOverrides); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogging); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing_TracingSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing_CustomTag); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing_Literal); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing_Environment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Tracing_RequestHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*MetricsOverrides_TagOverride); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogging_LogSelector); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_telemetry_v1alpha1_telemetry_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AccessLogging_Filter); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_telemetry_v1alpha1_telemetry_proto_msgTypes[4].OneofWrappers = []interface{}{
		(*MetricSelector_Metric)(nil),
		(*MetricSelector_CustomMetric)(nil),
	}
	file_telemetry_v1alpha1_telemetry_proto_msgTypes[8].OneofWrappers = []interface{}{
		(*Tracing_CustomTag_Literal)(nil),
		(*Tracing_CustomTag_Environment)(nil),
		(*Tracing_CustomTag_Header)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_telemetry_v1alpha1_telemetry_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_telemetry_v1alpha1_telemetry_proto_goTypes,
		DependencyIndexes: file_telemetry_v1alpha1_telemetry_proto_depIdxs,
		EnumInfos:         file_telemetry_v1alpha1_telemetry_proto_enumTypes,
		MessageInfos:      file_telemetry_v1alpha1_telemetry_proto_msgTypes,
	}.Build()
	File_telemetry_v1alpha1_telemetry_proto = out.File
	file_telemetry_v1alpha1_telemetry_proto_rawDesc = nil
	file_telemetry_v1alpha1_telemetry_proto_goTypes = nil
	file_telemetry_v1alpha1_telemetry_proto_depIdxs = nil
}
