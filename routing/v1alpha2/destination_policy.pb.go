// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha2/destination_policy.proto

/*
Package v1alpha2 is a generated protocol buffer package.

It is generated from these files:
	routing/v1alpha2/destination_policy.proto
	routing/v1alpha2/external_service.proto
	routing/v1alpha2/gateway.proto
	routing/v1alpha2/traffic_policy.proto

It has these top-level messages:
	DestinationPolicy
	Subset
	LoadBalancerSettings
	ConnectionPoolSettings
	OutlierDetection
	TLSSettings
	ExternalService
	Gateway
	Server
	Port
	TrafficPolicy
	Destination
	HTTPRoute
	TCPRoute
	HTTPMatchRequest
	DestinationWeight
	L4MatchAttributes
	HTTPRedirect
	HTTPRewrite
	StringMatch
	HTTPRetry
	CorsPolicy
	HTTPFaultInjection
	PortSelector
*/
package v1alpha2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/duration"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Standard load balancing algorithms that require no tuning.
type LoadBalancerSettings_SimpleLB int32

const (
	// Round Robin policy. Default
	LoadBalancerSettings_ROUND_ROBIN LoadBalancerSettings_SimpleLB = 0
	// The least request load balancer uses an O(1) algorithm which selects
	// two random healthy hosts and picks the host which has fewer active
	// requests.
	LoadBalancerSettings_LEAST_CONN LoadBalancerSettings_SimpleLB = 1
	// The random load balancer selects a random healthy host. The random
	// load balancer generally performs better than round robin if no health
	// checking policy is configured.
	LoadBalancerSettings_RANDOM LoadBalancerSettings_SimpleLB = 2
	// This option will forward the connection to the original IP address
	// requested by the caller without doing any form of load
	// balancing. This option must be used with care. It is meant for
	// advanced use cases. Refer to Original Destination load balancer in
	// Envoy for further details.
	LoadBalancerSettings_PASSTHROUGH LoadBalancerSettings_SimpleLB = 3
)

var LoadBalancerSettings_SimpleLB_name = map[int32]string{
	0: "ROUND_ROBIN",
	1: "LEAST_CONN",
	2: "RANDOM",
	3: "PASSTHROUGH",
}
var LoadBalancerSettings_SimpleLB_value = map[string]int32{
	"ROUND_ROBIN": 0,
	"LEAST_CONN":  1,
	"RANDOM":      2,
	"PASSTHROUGH": 3,
}

func (x LoadBalancerSettings_SimpleLB) String() string {
	return proto.EnumName(LoadBalancerSettings_SimpleLB_name, int32(x))
}
func (LoadBalancerSettings_SimpleLB) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

// TLS connection mode
type TLSSettings_TLSmode int32

const (
	// If set to "disable", the proxy will use not setup a TLS connection to the
	// upstream server.
	TLSSettings_DISABLE TLSSettings_TLSmode = 0
	// If set to "simple", the proxy will originate a TLS connection to the
	// upstream server.
	TLSSettings_SIMPLE TLSSettings_TLSmode = 1
	// If set to "mutual", the proxy will secure connections to the
	// upstream using mutual TLS by presenting client certificates for
	// authentication.
	TLSSettings_MUTUAL TLSSettings_TLSmode = 2
)

var TLSSettings_TLSmode_name = map[int32]string{
	0: "DISABLE",
	1: "SIMPLE",
	2: "MUTUAL",
}
var TLSSettings_TLSmode_value = map[string]int32{
	"DISABLE": 0,
	"SIMPLE":  1,
	"MUTUAL":  2,
}

func (x TLSSettings_TLSmode) String() string {
	return proto.EnumName(TLSSettings_TLSmode_name, int32(x))
}
func (TLSSettings_TLSmode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

// DestinationPolicy defines policies that apply to traffic intended for a
// service after routing has occurred. These policies specify configuration
// for load balancing, connection pool size from the sidecar, and outlier
// detection settings to detect and evict unhealthy hosts from the load
// balancing pool. For example, a simple load balancing policy for the
// ratings service would look as follows:
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-ratings
//     spec:
//       name: ratings
//       destinationPolicy:
//         loadBalancer:
//           simple: LEAST_CONN
//
// Version specific DestinationPolicy can be specified by defining a named
// subset and overriding the settings specified at the service level. The
// following rule uses a round robin load balancing policy for all traffic
// going to a subset named testversion that is composed of endpoints (e.g.,
// pods) with labels (version:v3).
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-ratings
//     spec:
//       name: ratings
//       destinationPolicy:
//         loadBalancer:
//           simple: LEAST_CONN
//       subsets:
//       - name: testversion
//         labels:
//           version: v3
//         destinationPolicy:
//           loadBalancer:
//             simple: ROUND_ROBIN
//
// Note that policies specified for subsets will not take effect until
// the traffic policy explicitly routes traffic to this subset.
type DestinationPolicy struct {
	// Settings controlling the load balancer algorithms.
	LoadBalancer *LoadBalancerSettings `protobuf:"bytes,1,opt,name=load_balancer,json=loadBalancer" json:"load_balancer,omitempty"`
	// Settings controlling the volume of connections to an upstream service
	ConnectionPool *ConnectionPoolSettings `protobuf:"bytes,2,opt,name=connection_pool,json=connectionPool" json:"connection_pool,omitempty"`
	// Settings controlling eviction of unhealthy hosts from the load balancing pool
	OutlierDetection *OutlierDetection `protobuf:"bytes,3,opt,name=outlier_detection,json=outlierDetection" json:"outlier_detection,omitempty"`
	// TLS related settings for connections to the upstream service.
	Tls *TLSSettings `protobuf:"bytes,4,opt,name=tls" json:"tls,omitempty"`
}

func (m *DestinationPolicy) Reset()                    { *m = DestinationPolicy{} }
func (m *DestinationPolicy) String() string            { return proto.CompactTextString(m) }
func (*DestinationPolicy) ProtoMessage()               {}
func (*DestinationPolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DestinationPolicy) GetLoadBalancer() *LoadBalancerSettings {
	if m != nil {
		return m.LoadBalancer
	}
	return nil
}

func (m *DestinationPolicy) GetConnectionPool() *ConnectionPoolSettings {
	if m != nil {
		return m.ConnectionPool
	}
	return nil
}

func (m *DestinationPolicy) GetOutlierDetection() *OutlierDetection {
	if m != nil {
		return m.OutlierDetection
	}
	return nil
}

func (m *DestinationPolicy) GetTls() *TLSSettings {
	if m != nil {
		return m.Tls
	}
	return nil
}

// A subset of endpoints of a service. Subsets can be used for scenarios
// like A/B testing, or routing to a specific version of a service. Refer
// to TrafficPolicy documentation for examples on using subsets in these
// scenarios. In addition, destination policies defined at the service-level
// can be overridden at a subset-level. The following rule uses a round
// robin load balancing policy for all traffic going to a subset named
// testversion that is composed of endpoints (e.g., pods) with labels
// (version:v3).
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-ratings
//     spec:
//       name: ratings
//       destinationPolicy:
//         loadBalancer:
//           simple: LEAST_CONN
//       subsets:
//       - name: testversion
//         labels:
//           version: v3
//         destinationPolicy:
//           loadBalancer:
//             simple: ROUND_ROBIN
//
// Note that policies specified for subsets will not take effect until
// a traffic policy explicitly routes traffic to this subset.
type Subset struct {
	// REQUIRED. name of the subset. The service name and the subset name can
	// be used for traffic splitting in a traffic policy.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// REQUIRED. Labels apply a filter over the endpoints of a service in the
	// service registry. See traffic policies for examples of usage.
	Labels map[string]string `protobuf:"bytes,2,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Destination policies that apply to this subset. Subsets inherit the
	// destination policies specified at the TrafficPolicy level. Settings
	// specified at the subset level will override the corresponding settings
	// specified at the TrafficPolicy level.
	DestinationPolicy *DestinationPolicy `protobuf:"bytes,3,opt,name=destination_policy,json=destinationPolicy" json:"destination_policy,omitempty"`
}

func (m *Subset) Reset()                    { *m = Subset{} }
func (m *Subset) String() string            { return proto.CompactTextString(m) }
func (*Subset) ProtoMessage()               {}
func (*Subset) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Subset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subset) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Subset) GetDestinationPolicy() *DestinationPolicy {
	if m != nil {
		return m.DestinationPolicy
	}
	return nil
}

// Load balancing policies to apply for a specific destination. See Envoy's
// load balancing
// [documentation](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/load_balancing.html)
// for more details.
//
// For example, the following rule uses a round robin load balancing policy
// for all traffic going to the ratings service.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-ratings
//     spec:
//       name: ratings
//       destinationPolicy:
//         loadBalancer:
//           simple: ROUND_ROBIN
//
// The following example uses the consistent hashing based load balancer
// for the same ratings service using the Cookie header as the hash key.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-ratings
//     spec:
//       name: ratings
//       destinationPolicy:
//         loadBalancer:
//           consistentHash:
//             http_header: Cookie
//
type LoadBalancerSettings struct {
	// Upstream load balancing policy.
	//
	// Types that are valid to be assigned to LbPolicy:
	//	*LoadBalancerSettings_Simple
	//	*LoadBalancerSettings_ConsistentHash
	LbPolicy isLoadBalancerSettings_LbPolicy `protobuf_oneof:"lb_policy"`
}

func (m *LoadBalancerSettings) Reset()                    { *m = LoadBalancerSettings{} }
func (m *LoadBalancerSettings) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancerSettings) ProtoMessage()               {}
func (*LoadBalancerSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isLoadBalancerSettings_LbPolicy interface {
	isLoadBalancerSettings_LbPolicy()
}

type LoadBalancerSettings_Simple struct {
	Simple LoadBalancerSettings_SimpleLB `protobuf:"varint,1,opt,name=simple,enum=istio.routing.v1alpha2.LoadBalancerSettings_SimpleLB,oneof"`
}
type LoadBalancerSettings_ConsistentHash struct {
	ConsistentHash *LoadBalancerSettings_ConsistentHashLB `protobuf:"bytes,2,opt,name=consistent_hash,json=consistentHash,oneof"`
}

func (*LoadBalancerSettings_Simple) isLoadBalancerSettings_LbPolicy()         {}
func (*LoadBalancerSettings_ConsistentHash) isLoadBalancerSettings_LbPolicy() {}

func (m *LoadBalancerSettings) GetLbPolicy() isLoadBalancerSettings_LbPolicy {
	if m != nil {
		return m.LbPolicy
	}
	return nil
}

func (m *LoadBalancerSettings) GetSimple() LoadBalancerSettings_SimpleLB {
	if x, ok := m.GetLbPolicy().(*LoadBalancerSettings_Simple); ok {
		return x.Simple
	}
	return LoadBalancerSettings_ROUND_ROBIN
}

func (m *LoadBalancerSettings) GetConsistentHash() *LoadBalancerSettings_ConsistentHashLB {
	if x, ok := m.GetLbPolicy().(*LoadBalancerSettings_ConsistentHash); ok {
		return x.ConsistentHash
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LoadBalancerSettings) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LoadBalancerSettings_OneofMarshaler, _LoadBalancerSettings_OneofUnmarshaler, _LoadBalancerSettings_OneofSizer, []interface{}{
		(*LoadBalancerSettings_Simple)(nil),
		(*LoadBalancerSettings_ConsistentHash)(nil),
	}
}

func _LoadBalancerSettings_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LoadBalancerSettings)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancerSettings_Simple:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Simple))
	case *LoadBalancerSettings_ConsistentHash:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConsistentHash); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LoadBalancerSettings.LbPolicy has unexpected type %T", x)
	}
	return nil
}

func _LoadBalancerSettings_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LoadBalancerSettings)
	switch tag {
	case 1: // lb_policy.simple
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.LbPolicy = &LoadBalancerSettings_Simple{LoadBalancerSettings_SimpleLB(x)}
		return true, err
	case 2: // lb_policy.consistent_hash
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoadBalancerSettings_ConsistentHashLB)
		err := b.DecodeMessage(msg)
		m.LbPolicy = &LoadBalancerSettings_ConsistentHash{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LoadBalancerSettings_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LoadBalancerSettings)
	// lb_policy
	switch x := m.LbPolicy.(type) {
	case *LoadBalancerSettings_Simple:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Simple))
	case *LoadBalancerSettings_ConsistentHash:
		s := proto.Size(x.ConsistentHash)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Consistent hashing (ketama hash) based load balancer for even load
// distribution/redistribution when the connection pool changes. This
// load balancing policy is applicable only for HTTP-based
// connections. A user specified HTTP header is used as the key with
// [xxHash](http://cyan4973.github.io/xxHash) hashing.
type LoadBalancerSettings_ConsistentHashLB struct {
	// REQUIRED. The name of the HTTP request header that will be used to
	// obtain the hash key. If the request header is not present, the load
	// balancer will use a random number as the hash, effectively making
	// the load balancing policy random.
	HttpHeader string `protobuf:"bytes,1,opt,name=http_header,json=httpHeader" json:"http_header,omitempty"`
	// The minimum number of virtual nodes to use for the hash
	// ring. Defaults to 1024. Larger ring sizes result in more granular
	// load distributions. If the number of hosts in the load balancing
	// pool is larger than the ring size, each host will be assigned a
	// single virtual node.
	MinimumRingSize uint32 `protobuf:"varint,2,opt,name=minimum_ring_size,json=minimumRingSize" json:"minimum_ring_size,omitempty"`
}

func (m *LoadBalancerSettings_ConsistentHashLB) Reset()         { *m = LoadBalancerSettings_ConsistentHashLB{} }
func (m *LoadBalancerSettings_ConsistentHashLB) String() string { return proto.CompactTextString(m) }
func (*LoadBalancerSettings_ConsistentHashLB) ProtoMessage()    {}
func (*LoadBalancerSettings_ConsistentHashLB) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{2, 0}
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetHttpHeader() string {
	if m != nil {
		return m.HttpHeader
	}
	return ""
}

func (m *LoadBalancerSettings_ConsistentHashLB) GetMinimumRingSize() uint32 {
	if m != nil {
		return m.MinimumRingSize
	}
	return 0
}

// Connection pool settings for an upstream host. The settings apply to
// each individual host in the upstream service.  See Envoy's [circuit
// breaker](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/circuit_breaking)
// for more details. Connection pool settings can be applied at the TCP
// level as well as at HTTP level.
//
// For example, the following rule sets a limit of 100 connections to redis
// service called myredissrv with a connect timeout of 30ms
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: bookinfo-redis
//     spec:
//       destination:
//         name: myredissrv
//       destinationPolicy:
//         connectionPool:
//           tcp:
//             maxConnections: 100
//             connectTimeout: 30ms
//
type ConnectionPoolSettings struct {
	// Settings common to both HTTP and TCP upstream connections.
	Tcp *ConnectionPoolSettings_TCPSettings `protobuf:"bytes,1,opt,name=tcp" json:"tcp,omitempty"`
	// HTTP connection pool settings.
	Http *ConnectionPoolSettings_HTTPSettings `protobuf:"bytes,2,opt,name=http" json:"http,omitempty"`
}

func (m *ConnectionPoolSettings) Reset()                    { *m = ConnectionPoolSettings{} }
func (m *ConnectionPoolSettings) String() string            { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings) ProtoMessage()               {}
func (*ConnectionPoolSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ConnectionPoolSettings) GetTcp() *ConnectionPoolSettings_TCPSettings {
	if m != nil {
		return m.Tcp
	}
	return nil
}

func (m *ConnectionPoolSettings) GetHttp() *ConnectionPoolSettings_HTTPSettings {
	if m != nil {
		return m.Http
	}
	return nil
}

// Settings common to both HTTP and TCP upstream connections.
type ConnectionPoolSettings_TCPSettings struct {
	// Maximum number of HTTP1 /TCP connections to a destination host.
	MaxConnections int32 `protobuf:"varint,1,opt,name=max_connections,json=maxConnections" json:"max_connections,omitempty"`
	// TCP connection timeout.
	ConnectTimeout *google_protobuf.Duration `protobuf:"bytes,2,opt,name=connect_timeout,json=connectTimeout" json:"connect_timeout,omitempty"`
}

func (m *ConnectionPoolSettings_TCPSettings) Reset()         { *m = ConnectionPoolSettings_TCPSettings{} }
func (m *ConnectionPoolSettings_TCPSettings) String() string { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings_TCPSettings) ProtoMessage()    {}
func (*ConnectionPoolSettings_TCPSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 0}
}

func (m *ConnectionPoolSettings_TCPSettings) GetMaxConnections() int32 {
	if m != nil {
		return m.MaxConnections
	}
	return 0
}

func (m *ConnectionPoolSettings_TCPSettings) GetConnectTimeout() *google_protobuf.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

// Settings applicable to HTTP1.1/HTTP2/GRPC connections.
type ConnectionPoolSettings_HTTPSettings struct {
	// Maximum number of pending HTTP requests to a destination. Default 1024.
	Http1MaxPendingRequests int32 `protobuf:"varint,1,opt,name=http1_max_pending_requests,json=http1MaxPendingRequests" json:"http1_max_pending_requests,omitempty"`
	// Maximum number of requests to a backend. Default 1024.
	Http2MaxRequests int32 `protobuf:"varint,2,opt,name=http2_max_requests,json=http2MaxRequests" json:"http2_max_requests,omitempty"`
	// Maximum number of requests per connection to a backend. Setting this
	// parameter to 1 disables keep alive.
	MaxRequestsPerConnection int32 `protobuf:"varint,3,opt,name=max_requests_per_connection,json=maxRequestsPerConnection" json:"max_requests_per_connection,omitempty"`
	// Maximum number of retries that can be outstanding to all hosts in a
	// cluster at a given time. Defaults to 3.
	MaxRetries int32 `protobuf:"varint,4,opt,name=max_retries,json=maxRetries" json:"max_retries,omitempty"`
}

func (m *ConnectionPoolSettings_HTTPSettings) Reset()         { *m = ConnectionPoolSettings_HTTPSettings{} }
func (m *ConnectionPoolSettings_HTTPSettings) String() string { return proto.CompactTextString(m) }
func (*ConnectionPoolSettings_HTTPSettings) ProtoMessage()    {}
func (*ConnectionPoolSettings_HTTPSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{3, 1}
}

func (m *ConnectionPoolSettings_HTTPSettings) GetHttp1MaxPendingRequests() int32 {
	if m != nil {
		return m.Http1MaxPendingRequests
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetHttp2MaxRequests() int32 {
	if m != nil {
		return m.Http2MaxRequests
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetMaxRequestsPerConnection() int32 {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return 0
}

func (m *ConnectionPoolSettings_HTTPSettings) GetMaxRetries() int32 {
	if m != nil {
		return m.MaxRetries
	}
	return 0
}

// A Circuit breaker implementation that tracks the status of each
// individual host in the upstream service.  While currently applicable to
// only HTTP services, future versions will support opaque TCP services as
// well. For HTTP services, hosts that continually return errors for API
// calls are ejected from the pool for a pre-defined period of time. See
// Envoy's [outlier
// detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/outlier)
// for more details.
//
// The following rule sets a connection pool size of 100 connections and
// 1000 concurrent HTTP2 requests, with no more than 10 req/connection to
// "reviews" service. In addition, it configures upstream hosts to be
// scanned every 5 mins, such that any host that fails 7 consecutive times
// with 5XX error code will be ejected for 15 minutes.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: reviews-cb-policy
//     spec:
//       destination:
//         name: reviews
//       destinationPolicy:
//         connectionPool:
//           tcp:
//             maxConnections: 100
//           http:
//             http2MaxRequests: 1000
//             maxRequestsPerConnection: 10
//         outlierDetection:
//           http:
//             consecutiveErrors: 7
//             interval: 5m
//             baseEjectionTime: 15m
//
type OutlierDetection struct {
	// Settings for HTTP1.1/HTTP2/GRPC connections.
	Http *OutlierDetection_HTTPSettings `protobuf:"bytes,1,opt,name=http" json:"http,omitempty"`
}

func (m *OutlierDetection) Reset()                    { *m = OutlierDetection{} }
func (m *OutlierDetection) String() string            { return proto.CompactTextString(m) }
func (*OutlierDetection) ProtoMessage()               {}
func (*OutlierDetection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OutlierDetection) GetHttp() *OutlierDetection_HTTPSettings {
	if m != nil {
		return m.Http
	}
	return nil
}

// Outlier detection settings for HTTP1.1/HTTP2/GRPC connections.
type OutlierDetection_HTTPSettings struct {
	// Number of 5XX errors before a host is ejected from the connection
	// pool. Defaults to 5.
	ConsecutiveErrors int32 `protobuf:"varint,1,opt,name=consecutive_errors,json=consecutiveErrors" json:"consecutive_errors,omitempty"`
	// Time interval between ejection sweep analysis. format:
	// 1h/1m/1s/1ms. MUST BE >=1ms. Default is 10s.
	Interval *google_protobuf.Duration `protobuf:"bytes,2,opt,name=interval" json:"interval,omitempty"`
	// Minimum ejection duration. A host will remain ejected for a period
	// equal to the product of minimum ejection duration and the number of
	// times the host has been ejected. This technique allows the system to
	// automatically increase the ejection period for unhealthy upstream
	// servers. format: 1h/1m/1s/1ms. MUST BE >=1ms. Default is 30s.
	BaseEjectionTime *google_protobuf.Duration `protobuf:"bytes,3,opt,name=base_ejection_time,json=baseEjectionTime" json:"base_ejection_time,omitempty"`
	// Maximum % of hosts in the load balancing pool for the upstream
	// service that can be ejected. Defaults to 10%.
	MaxEjectionPercent int32 `protobuf:"varint,4,opt,name=max_ejection_percent,json=maxEjectionPercent" json:"max_ejection_percent,omitempty"`
}

func (m *OutlierDetection_HTTPSettings) Reset()         { *m = OutlierDetection_HTTPSettings{} }
func (m *OutlierDetection_HTTPSettings) String() string { return proto.CompactTextString(m) }
func (*OutlierDetection_HTTPSettings) ProtoMessage()    {}
func (*OutlierDetection_HTTPSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *OutlierDetection_HTTPSettings) GetConsecutiveErrors() int32 {
	if m != nil {
		return m.ConsecutiveErrors
	}
	return 0
}

func (m *OutlierDetection_HTTPSettings) GetInterval() *google_protobuf.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *OutlierDetection_HTTPSettings) GetBaseEjectionTime() *google_protobuf.Duration {
	if m != nil {
		return m.BaseEjectionTime
	}
	return nil
}

func (m *OutlierDetection_HTTPSettings) GetMaxEjectionPercent() int32 {
	if m != nil {
		return m.MaxEjectionPercent
	}
	return 0
}

// SSL/TLS related settings for upstream connections. See Envoy's [TLS
// context](https://www.envoyproxy.io/docs/envoy/latest/api-v1/cluster_manager/cluster_ssl.html#config-cluster-manager-cluster-ssl)
// for more details. These settings are common to both HTTP and TCP upstreams.
//
// For example, the following rule configures a client to use mutual TLS
// for connections to upstream database cluster.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: db-mtls
//     spec:
//       destination:
//         name: mydbserver
//       tls:
//         mode: MUTUAL
//         clientCertificate: /etc/certs/myclientcert.pem
//         privateKey: /etc/certs/client_private_key.pem
//         caCertificates: /etc/certs/rootcacerts.pem
//
// The following rule configures a client to use TLS when talking to a foreign service whose domain matches *.foo.com.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: TrafficPolicy
//     metadata:
//       name: tls-foo
//     spec:
//       destination:
//         name: *.foo.com
//       tls:
//         mode: SIMPLE
//
type TLSSettings struct {
	// REQUIRED: Indicates whether connections to this port should be secured
	// using TLS. The value of this field determines how TLS is enforced.
	Mode TLSSettings_TLSmode `protobuf:"varint,1,opt,name=mode,enum=istio.routing.v1alpha2.TLSSettings_TLSmode" json:"mode,omitempty"`
	// REQUIRED if mode is "mutual". The path to the file holding the
	// client-side TLS certificate to use.
	ClientCertificate string `protobuf:"bytes,2,opt,name=client_certificate,json=clientCertificate" json:"client_certificate,omitempty"`
	// REQUIRED if mode is "mutual". The path to the file holding the
	// client's private key.
	PrivateKey string `protobuf:"bytes,3,opt,name=private_key,json=privateKey" json:"private_key,omitempty"`
	// OPTIONAL: The path to the file containing certificate authority
	// certificates to use in verifying a presented server certificate. If
	// omitted, the proxy will not verify the server's certificate.
	CaCertificates string `protobuf:"bytes,4,opt,name=ca_certificates,json=caCertificates" json:"ca_certificates,omitempty"`
	// A list of alternate names to verify the subject identity in the
	// certificate. If specified, the proxy will verify that the server
	// certificate's subject alt name matches one of the specified values.
	SubjectAltNames []string `protobuf:"bytes,5,rep,name=subject_alt_names,json=subjectAltNames" json:"subject_alt_names,omitempty"`
	// SNI string to present to the server during TLS handshake.
	Sni string `protobuf:"bytes,6,opt,name=sni" json:"sni,omitempty"`
}

func (m *TLSSettings) Reset()                    { *m = TLSSettings{} }
func (m *TLSSettings) String() string            { return proto.CompactTextString(m) }
func (*TLSSettings) ProtoMessage()               {}
func (*TLSSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TLSSettings) GetMode() TLSSettings_TLSmode {
	if m != nil {
		return m.Mode
	}
	return TLSSettings_DISABLE
}

func (m *TLSSettings) GetClientCertificate() string {
	if m != nil {
		return m.ClientCertificate
	}
	return ""
}

func (m *TLSSettings) GetPrivateKey() string {
	if m != nil {
		return m.PrivateKey
	}
	return ""
}

func (m *TLSSettings) GetCaCertificates() string {
	if m != nil {
		return m.CaCertificates
	}
	return ""
}

func (m *TLSSettings) GetSubjectAltNames() []string {
	if m != nil {
		return m.SubjectAltNames
	}
	return nil
}

func (m *TLSSettings) GetSni() string {
	if m != nil {
		return m.Sni
	}
	return ""
}

func init() {
	proto.RegisterType((*DestinationPolicy)(nil), "istio.routing.v1alpha2.DestinationPolicy")
	proto.RegisterType((*Subset)(nil), "istio.routing.v1alpha2.Subset")
	proto.RegisterType((*LoadBalancerSettings)(nil), "istio.routing.v1alpha2.LoadBalancerSettings")
	proto.RegisterType((*LoadBalancerSettings_ConsistentHashLB)(nil), "istio.routing.v1alpha2.LoadBalancerSettings.ConsistentHashLB")
	proto.RegisterType((*ConnectionPoolSettings)(nil), "istio.routing.v1alpha2.ConnectionPoolSettings")
	proto.RegisterType((*ConnectionPoolSettings_TCPSettings)(nil), "istio.routing.v1alpha2.ConnectionPoolSettings.TCPSettings")
	proto.RegisterType((*ConnectionPoolSettings_HTTPSettings)(nil), "istio.routing.v1alpha2.ConnectionPoolSettings.HTTPSettings")
	proto.RegisterType((*OutlierDetection)(nil), "istio.routing.v1alpha2.OutlierDetection")
	proto.RegisterType((*OutlierDetection_HTTPSettings)(nil), "istio.routing.v1alpha2.OutlierDetection.HTTPSettings")
	proto.RegisterType((*TLSSettings)(nil), "istio.routing.v1alpha2.TLSSettings")
	proto.RegisterEnum("istio.routing.v1alpha2.LoadBalancerSettings_SimpleLB", LoadBalancerSettings_SimpleLB_name, LoadBalancerSettings_SimpleLB_value)
	proto.RegisterEnum("istio.routing.v1alpha2.TLSSettings_TLSmode", TLSSettings_TLSmode_name, TLSSettings_TLSmode_value)
}

func init() { proto.RegisterFile("routing/v1alpha2/destination_policy.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1009 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x6e, 0x1b, 0xc5,
	0x17, 0x8e, 0xed, 0xc4, 0xad, 0x8f, 0x5b, 0x67, 0x3d, 0x8a, 0xfa, 0xf3, 0xcf, 0x08, 0x1a, 0x99,
	0x0b, 0xd2, 0x52, 0xd6, 0x34, 0x28, 0x12, 0xb4, 0xaa, 0x90, 0x1d, 0x5b, 0x75, 0x84, 0x63, 0x9b,
	0xb1, 0x23, 0x10, 0x37, 0xab, 0xf1, 0x7a, 0x1a, 0x0f, 0xec, 0xee, 0x2c, 0x3b, 0xb3, 0x51, 0x92,
	0x37, 0xe0, 0x8a, 0xa7, 0xe1, 0x31, 0x10, 0xd7, 0x3c, 0x05, 0x57, 0xdc, 0xa3, 0xf9, 0xe3, 0xf5,
	0xd6, 0x4d, 0xa0, 0xb9, 0x5b, 0x9f, 0x73, 0xbe, 0x6f, 0xce, 0x9c, 0x3f, 0xdf, 0x18, 0x9e, 0x24,
	0x3c, 0x95, 0x2c, 0x3a, 0x6f, 0x5f, 0x3c, 0x27, 0x41, 0xbc, 0x24, 0x87, 0xed, 0x05, 0x15, 0x92,
	0x45, 0x44, 0x32, 0x1e, 0x79, 0x31, 0x0f, 0x98, 0x7f, 0xe5, 0xc6, 0x09, 0x97, 0x1c, 0x3d, 0x62,
	0x42, 0x32, 0xee, 0x5a, 0x80, 0xbb, 0x02, 0x34, 0x3f, 0x3a, 0xe7, 0xfc, 0x3c, 0xa0, 0x6d, 0x1d,
	0x35, 0x4f, 0xdf, 0xb4, 0x17, 0x69, 0xa2, 0xe1, 0x06, 0xd7, 0xfa, 0xbd, 0x08, 0xf5, 0xde, 0x9a,
	0x74, 0xa2, 0x39, 0xd1, 0xb7, 0xf0, 0x30, 0xe0, 0x64, 0xe1, 0xcd, 0x49, 0x40, 0x22, 0x9f, 0x26,
	0x8d, 0xc2, 0x7e, 0xe1, 0xa0, 0x7a, 0xf8, 0xcc, 0xbd, 0xf9, 0x14, 0x77, 0xc8, 0xc9, 0xa2, 0x6b,
	0x63, 0xa7, 0x54, 0x2a, 0xa7, 0xc0, 0x0f, 0x82, 0x9c, 0x15, 0x7d, 0x07, 0xbb, 0x3e, 0x8f, 0x22,
	0xea, 0xdb, 0xdc, 0x79, 0xd0, 0x28, 0x6a, 0x52, 0xf7, 0x36, 0xd2, 0xe3, 0x2c, 0x7c, 0xc2, 0x79,
	0x90, 0xd1, 0xd6, 0xfc, 0xb7, 0xec, 0xe8, 0x0c, 0xea, 0x3c, 0x95, 0x01, 0xa3, 0x89, 0xb7, 0xa0,
	0xd2, 0x38, 0x1a, 0x25, 0x4d, 0x7d, 0x70, 0x1b, 0xf5, 0xd8, 0x00, 0x7a, 0xab, 0x78, 0xec, 0xf0,
	0x0d, 0x0b, 0x3a, 0x82, 0x92, 0x0c, 0x44, 0x63, 0x5b, 0x13, 0x7d, 0x7c, 0x1b, 0xd1, 0x6c, 0x38,
	0xcd, 0x12, 0x53, 0xf1, 0xad, 0xbf, 0x0b, 0x50, 0x9e, 0xa6, 0x73, 0x41, 0x25, 0x42, 0xb0, 0x1d,
	0x91, 0x90, 0xea, 0xda, 0x55, 0xb0, 0xfe, 0x46, 0x5d, 0x28, 0x07, 0x64, 0x4e, 0x03, 0xd1, 0x28,
	0xee, 0x97, 0x0e, 0xaa, 0x87, 0x4f, 0x6f, 0x23, 0x36, 0x1c, 0xee, 0x50, 0x07, 0xf7, 0x23, 0x99,
	0x5c, 0x61, 0x8b, 0x44, 0xdf, 0x03, 0x7a, 0x77, 0x0c, 0xec, 0x8d, 0x9f, 0xdc, 0xc6, 0xf7, 0x4e,
	0x8f, 0x71, 0x7d, 0xb1, 0x69, 0x6a, 0x7e, 0x05, 0xd5, 0xdc, 0x81, 0xc8, 0x81, 0xd2, 0x4f, 0xf4,
	0xca, 0xe6, 0xaf, 0x3e, 0xd1, 0x1e, 0xec, 0x5c, 0x90, 0x20, 0xa5, 0xba, 0x75, 0x15, 0x6c, 0x7e,
	0xbc, 0x28, 0x7e, 0x59, 0x68, 0xfd, 0x52, 0x82, 0xbd, 0x9b, 0xa6, 0x00, 0x8d, 0xa1, 0x2c, 0x58,
	0x18, 0x07, 0xa6, 0x0e, 0xb5, 0xc3, 0xa3, 0xbb, 0xcc, 0x90, 0x3b, 0xd5, 0xd0, 0x61, 0x77, 0xb0,
	0x85, 0x2d, 0x0d, 0x5a, 0xea, 0x41, 0x12, 0x4c, 0x48, 0x1a, 0x49, 0x6f, 0x49, 0xc4, 0xd2, 0x0e,
	0xd2, 0xab, 0x3b, 0x31, 0x1f, 0x67, 0x1c, 0x03, 0x22, 0x96, 0xfa, 0x84, 0x9a, 0xff, 0x96, 0xad,
	0xe9, 0x81, 0xb3, 0x19, 0x85, 0x1e, 0x43, 0x75, 0x29, 0x65, 0xec, 0x2d, 0x29, 0x59, 0xd8, 0xbd,
	0xa8, 0x60, 0x50, 0xa6, 0x81, 0xb6, 0xa0, 0xa7, 0x50, 0x0f, 0x59, 0xc4, 0xc2, 0x34, 0xf4, 0x12,
	0x16, 0x9d, 0x7b, 0x82, 0x5d, 0x9b, 0x72, 0x3d, 0xc4, 0xbb, 0xd6, 0x81, 0x59, 0x74, 0x3e, 0x65,
	0xd7, 0xb4, 0x35, 0x80, 0xfb, 0xab, 0x0b, 0xa2, 0x5d, 0xa8, 0xe2, 0xf1, 0xd9, 0xa8, 0xe7, 0xe1,
	0x71, 0xf7, 0x64, 0xe4, 0x6c, 0xa1, 0x1a, 0xc0, 0xb0, 0xdf, 0x99, 0xce, 0xbc, 0xe3, 0xf1, 0x68,
	0xe4, 0x14, 0x10, 0x40, 0x19, 0x77, 0x46, 0xbd, 0xf1, 0xa9, 0x53, 0x54, 0xc1, 0x93, 0xce, 0x74,
	0x3a, 0x1b, 0xe0, 0xf1, 0xd9, 0xeb, 0x81, 0x53, 0xea, 0x56, 0xa1, 0x12, 0xcc, 0xed, 0x28, 0xb4,
	0x7e, 0xdd, 0x86, 0x47, 0x37, 0x2f, 0x0f, 0x1a, 0x42, 0x49, 0xfa, 0xb1, 0x5d, 0xe7, 0x17, 0x77,
	0xdb, 0x3c, 0x77, 0x76, 0x3c, 0xc9, 0x0d, 0xbb, 0x1f, 0xa3, 0x31, 0x6c, 0xab, 0x9b, 0xdb, 0xfa,
	0xbf, 0xbc, 0x23, 0xdd, 0x60, 0x36, 0x5b, 0xf3, 0x69, 0xa2, 0xe6, 0x35, 0x54, 0x73, 0x87, 0xa0,
	0x4f, 0x60, 0x37, 0x24, 0x97, 0xde, 0x7a, 0xe1, 0x85, 0xce, 0x7c, 0x07, 0xd7, 0x42, 0x72, 0xb9,
	0x66, 0x15, 0xa8, 0x9b, 0x89, 0x8b, 0x27, 0x59, 0x48, 0x79, 0x2a, 0x6d, 0x4e, 0xff, 0x77, 0x8d,
	0xfe, 0xb9, 0x2b, 0xfd, 0x73, 0x7b, 0x56, 0xff, 0x32, 0x1d, 0x99, 0x19, 0x40, 0xf3, 0xcf, 0x02,
	0x3c, 0xc8, 0xa7, 0x84, 0x5e, 0x42, 0x53, 0x25, 0xf5, 0xdc, 0x53, 0x39, 0xc4, 0x34, 0x5a, 0xa8,
	0x76, 0x26, 0xf4, 0xe7, 0x94, 0x0a, 0xb9, 0x4a, 0xe4, 0x7f, 0x3a, 0xe2, 0x94, 0x5c, 0x4e, 0x8c,
	0x1f, 0x5b, 0x37, 0x7a, 0x06, 0x48, 0xb9, 0x0e, 0x35, 0x38, 0x03, 0x15, 0x35, 0xc8, 0xd1, 0x9e,
	0x53, 0x72, 0x99, 0x45, 0xbf, 0x82, 0x0f, 0xf2, 0x71, 0x5e, 0x4c, 0x93, 0xdc, 0xad, 0xf5, 0x6e,
	0xef, 0xe0, 0x46, 0xb8, 0x46, 0x4c, 0x68, 0xb2, 0xbe, 0xbf, 0x1a, 0x4a, 0x03, 0x97, 0x09, 0xa3,
	0x46, 0xb3, 0x76, 0x30, 0xe8, 0x70, 0x6d, 0x69, 0xfd, 0x51, 0x04, 0x67, 0x53, 0xf3, 0xd0, 0x89,
	0xed, 0x9e, 0x19, 0x86, 0xa3, 0xf7, 0xd5, 0xca, 0x9b, 0xfa, 0xf6, 0xd7, 0x66, 0xed, 0x3e, 0x03,
	0xa4, 0x96, 0x89, 0xfa, 0xa9, 0x64, 0x17, 0xd4, 0xa3, 0x49, 0xc2, 0x93, 0x55, 0xcd, 0xea, 0x39,
	0x4f, 0x5f, 0x3b, 0xd0, 0x11, 0xdc, 0x67, 0x91, 0xa4, 0xc9, 0x05, 0x09, 0xfe, 0xbb, 0x71, 0x59,
	0x28, 0x7a, 0x0d, 0x68, 0x4e, 0x04, 0xf5, 0xe8, 0x8f, 0xf6, 0x59, 0x51, 0xcd, 0xb7, 0x4a, 0xf8,
	0x2f, 0x04, 0x8e, 0x02, 0xf5, 0x2d, 0x46, 0xb5, 0x1f, 0x7d, 0x0e, 0x7b, 0xaa, 0x80, 0x19, 0x4f,
	0x4c, 0x13, 0x9f, 0x46, 0xd2, 0x56, 0x12, 0x85, 0xe4, 0x72, 0x15, 0x3e, 0x31, 0x9e, 0xd6, 0x6f,
	0x45, 0xa8, 0xe6, 0xc4, 0x1f, 0x7d, 0x0d, 0xdb, 0x21, 0x5f, 0xac, 0x44, 0xee, 0xd3, 0xf7, 0x78,
	0x2f, 0xd4, 0xb7, 0x82, 0x60, 0x0d, 0xd4, 0x15, 0x0b, 0x98, 0x92, 0x34, 0x9f, 0x26, 0x92, 0xbd,
	0x61, 0x3e, 0x91, 0x2b, 0x9d, 0xad, 0x1b, 0xcf, 0xf1, 0xda, 0xa1, 0x5a, 0x1e, 0x27, 0xec, 0x82,
	0x48, 0xea, 0x29, 0x8d, 0x2e, 0x19, 0x1d, 0xb2, 0xa6, 0x6f, 0xe8, 0x95, 0xda, 0x1d, 0x9f, 0xe4,
	0xb9, 0xcc, 0x5c, 0x54, 0x70, 0xcd, 0x27, 0x39, 0x22, 0xa1, 0x04, 0x4b, 0xa4, 0x73, 0x75, 0x3d,
	0x8f, 0x04, 0xd2, 0x53, 0xcf, 0x94, 0x68, 0xec, 0xec, 0x97, 0x0e, 0x2a, 0x78, 0xd7, 0x3a, 0x3a,
	0x81, 0x1c, 0x29, 0xb3, 0x7a, 0x11, 0x44, 0xc4, 0x1a, 0x65, 0xf3, 0x22, 0x88, 0x88, 0xb5, 0x5c,
	0xb8, 0x67, 0xef, 0x81, 0xaa, 0x70, 0xaf, 0x77, 0x32, 0xed, 0x74, 0x87, 0x7d, 0x67, 0x4b, 0xa9,
	0xd5, 0xf4, 0xe4, 0x74, 0x32, 0xec, 0x1b, 0xe5, 0x3a, 0x3d, 0x9b, 0x9d, 0x75, 0x86, 0x4e, 0xb1,
	0xfb, 0xf8, 0x87, 0x0f, 0x4d, 0x69, 0x18, 0x6f, 0x93, 0x98, 0xb5, 0x37, 0xff, 0xe1, 0xcc, 0xcb,
	0xba, 0x5f, 0x5f, 0xfc, 0x13, 0x00, 0x00, 0xff, 0xff, 0xa7, 0x54, 0x96, 0x5f, 0xfc, 0x08, 0x00,
	0x00,
}
